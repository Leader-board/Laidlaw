; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26433.0 

	TITLE	c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@	; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ ; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@	; `string'
PUBLIC	??_C@_0BO@DAJFEOKA@Type?51?5to?5start?5benchmarking?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@BHCOCDDO@Invalid?5number?0?5try?5again?5?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@BBLAGGGH@Invalid?5entry?4?5Program?5will?5clos@ ; `string'
PUBLIC	??_C@_0N@FDENFJAP@?5?$CF?5complete?$CB?$AA@	; `string'
PUBLIC	??_C@_0BN@KEIIGMGP@Time?5taken?5for?5that?5stage?3?9?5?$AA@ ; `string'
PUBLIC	??_C@_0CB@GCCJPACJ@Score?5obtained?5for?5that?5stage?3?9?5@ ; `string'
PUBLIC	??_C@_0L@NPJALOFP@?5seconds?5?6?$AA@		; `string'
PUBLIC	??_C@_04HNABGNME@?5is?5?$AA@			; `string'
PUBLIC	??_C@_0BO@NKJLBHOG@Average?5time?5taken?5for?5stage?5?$AA@ ; `string'
PUBLIC	??_C@_08HNCFKHPB@?5points?$CB?$AA@		; `string'
PUBLIC	??_C@_0CD@BOJLJHDN@Your?5system?5has?5scored?5a?5total?5o@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	??_C@_02MDKMJEGG@eE?$AA@			; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
PUBLIC	?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
PUBLIC	?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	__CTA2PAD
PUBLIC	__CTA1H
PUBLIC	__CT??_R0PAX@84
PUBLIC	__CT??_R0PAD@84
PUBLIC	__CT??_R0H@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__TI2PAD
PUBLIC	__TI1H
PUBLIC	?stagetime@@3PANA				; stagetime
PUBLIC	?totalscore@@3MA				; totalscore
PUBLIC	?score@@3PAMA					; score
PUBLIC	?c@@3NA						; c
PUBLIC	?y@@3NA						; y
PUBLIC	?x@@3NA						; x
PUBLIC	?d@@3NA						; d
PUBLIC	?k@@3NA						; k
PUBLIC	?powcheck@@3NA					; powcheck
PUBLIC	?b@@3NA						; b
PUBLIC	?a@@3NA						; a
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
EXTRN	__purecall:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z:PROC ; std::_Execute_once
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	_strcspn:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__Stolx:PROC
EXTRN	__Stollx:PROC
EXTRN	__Stoullx:PROC
EXTRN	__Stoulx:PROC
EXTRN	_system:PROC
EXTRN	_clock:PROC
EXTRN	_exit:PROC
EXTRN	__getch:PROC
EXTRN	?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cin
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	_strtof:PROC
EXTRN	_strtod:PROC
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	__Toupper:PROC
EXTRN	__Tolower:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	_calloc:PROC
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	_localeconv:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Getctype:PROC
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__errno:PROC
EXTRN	_terminate:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_exception_destroy:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	_free:PROC
EXTRN	___std_terminate:PROC
EXTRN	_ldexp:PROC
EXTRN	_frexp:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA DD 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
?stagetime@@3PANA DQ 05H DUP (?)			; stagetime
?totalscore@@3MA DD 01H DUP (?)				; totalscore
?score@@3PAMA DD 05H DUP (?)				; score
?c@@3NA	DQ	01H DUP (?)				; c
?y@@3NA	DQ	01H DUP (?)				; y
?x@@3NA	DQ	01H DUP (?)				; x
?d@@3NA	DQ	01H DUP (?)				; d
?k@@3NA	DQ	01H DUP (?)				; k
?powcheck@@3NA DQ 01H DUP (?)				; powcheck
?b@@3NA	DQ	01H DUP (?)				; b
?a@@3NA	DQ	01H DUP (?)				; a
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
data$r	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
data$r	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	FLAT:?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	02dH
	DB	02bH
	DB	045H
	DB	065H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	00H
CONST	ENDS
;	COMDAT ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB
CONST	SEGMENT
?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB DB 030H ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	02dH
	DB	02bH
	DB	058H
	DB	078H
	DB	050H
	DB	070H
	DB	00H
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$r	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$r	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$r	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$r	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$r	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$r	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP?$AA@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP?$AA@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE?$AA@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE?$AA@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BOJLJHDN@Your?5system?5has?5scored?5a?5total?5o@
CONST	SEGMENT
??_C@_0CD@BOJLJHDN@Your?5system?5has?5scored?5a?5total?5o@ DB 'Your syste'
	DB	'm has scored a total of ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNCFKHPB@?5points?$CB?$AA@
CONST	SEGMENT
??_C@_08HNCFKHPB@?5points?$CB?$AA@ DB ' points!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NKJLBHOG@Average?5time?5taken?5for?5stage?5?$AA@
CONST	SEGMENT
??_C@_0BO@NKJLBHOG@Average?5time?5taken?5for?5stage?5?$AA@ DB 'Average ti'
	DB	'me taken for stage ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNABGNME@?5is?5?$AA@
CONST	SEGMENT
??_C@_04HNABGNME@?5is?5?$AA@ DB ' is ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPJALOFP@?5seconds?5?6?$AA@
CONST	SEGMENT
??_C@_0L@NPJALOFP@?5seconds?5?6?$AA@ DB ' seconds ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GCCJPACJ@Score?5obtained?5for?5that?5stage?3?9?5@
CONST	SEGMENT
??_C@_0CB@GCCJPACJ@Score?5obtained?5for?5that?5stage?3?9?5@ DB 'Score obt'
	DB	'ained for that stage:- ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KEIIGMGP@Time?5taken?5for?5that?5stage?3?9?5?$AA@
CONST	SEGMENT
??_C@_0BN@KEIIGMGP@Time?5taken?5for?5that?5stage?3?9?5?$AA@ DB 'Time take'
	DB	'n for that stage:- ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDENFJAP@?5?$CF?5complete?$CB?$AA@
CONST	SEGMENT
??_C@_0N@FDENFJAP@?5?$CF?5complete?$CB?$AA@ DB ' % complete!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BBLAGGGH@Invalid?5entry?4?5Program?5will?5clos@
CONST	SEGMENT
??_C@_0CJ@BBLAGGGH@Invalid?5entry?4?5Program?5will?5clos@ DB 'Invalid ent'
	DB	'ry. Program will close now. ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BHCOCDDO@Invalid?5number?0?5try?5again?5?6?$AA@
CONST	SEGMENT
??_C@_0BM@BHCOCDDO@Invalid?5number?0?5try?5again?5?6?$AA@ DB 'Invalid num'
	DB	'ber, try again ', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DAJFEOKA@Type?51?5to?5start?5benchmarking?4?$AA@
CONST	SEGMENT
??_C@_0BO@DAJFEOKA@Type?51?5to?5start?5benchmarking?4?$AA@ DB 'Type 1 to '
	DB	'start benchmarking.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@ DB 'ios_base::failbit se'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf_s
PUBLIC	__vsprintf_s_l
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
PUBLIC	?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
PUBLIC	?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find_elem@D@std@@YAIPADD@Z			; std::_Find_elem<char>
PUBLIC	??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator!=<char,std::char_traits<char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
PUBLIC	??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ; std::operator==<char,std::char_traits<char> >
PUBLIC	??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ; std::_Immortalize<std::_Iostream_error_category>
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
PUBLIC	?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
PUBLIC	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??$_Max_value@I@std@@YAABIABI0@Z		; std::_Max_value<unsigned int>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	_main
PUBLIC	?mainbase@@YAXXZ				; mainbase
PUBLIC	?selection@@YAXXZ				; selection
PUBLIC	?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z		; std::_Stofx_v2
PUBLIC	?_Stodx_v2@std@@YANPBDPAPADHPAH@Z		; std::_Stodx_v2
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	?c_str@locale@std@@QBEPBDXZ			; std::locale::c_str
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@PBD@Z			; std::runtime_error::runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADQADID@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	?pow@@YANNH@Z					; pow
PUBLIC	_ldexpl
PUBLIC	_frexpl
PUBLIC	_fabsl
PUBLIC	_powf
PUBLIC	_ldexpf
PUBLIC	?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	__real@3b449ba6
PUBLIC	__real@3d0f5c29
PUBLIC	__real@3e8bc6a8
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff6b851eb851eb8
PUBLIC	__real@4000000000000000
PUBLIC	__real@400e6666
PUBLIC	__real@4024000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@4069000000000000
PUBLIC	__real@406f400000000000
PUBLIC	__real@407f400000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@4097700000000000
PUBLIC	__real@40a00000
PUBLIC	__real@40f126e9
PUBLIC	__real@4202a05f20000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	_ceil:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A DQ 01H DUP (?) ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT __real@40f126e9
CONST	SEGMENT
__real@40f126e9 DD 040f126e9r			; 7.536
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@4097700000000000
CONST	SEGMENT
__real@4097700000000000 DQ 04097700000000000r	; 1500
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@407f400000000000
CONST	SEGMENT
__real@407f400000000000 DQ 0407f400000000000r	; 500
CONST	ENDS
;	COMDAT __real@406f400000000000
CONST	SEGMENT
__real@406f400000000000 DQ 0406f400000000000r	; 250
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@400e6666
CONST	SEGMENT
__real@400e6666 DD 0400e6666r			; 2.225
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff6b851eb851eb8
CONST	SEGMENT
__real@3ff6b851eb851eb8 DQ 03ff6b851eb851eb8r	; 1.42
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3e8bc6a8
CONST	SEGMENT
__real@3e8bc6a8 DD 03e8bc6a8r			; 0.273
CONST	ENDS
;	COMDAT __real@3d0f5c29
CONST	SEGMENT
__real@3d0f5c29 DD 03d0f5c29r			; 0.035
CONST	ENDS
;	COMDAT __real@3b449ba6
CONST	SEGMENT
__real@3b449ba6 DD 03b449ba6r			; 0.003
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@ABV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getloc@ios_base@std@@QBE?AVlocale@2@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?selection@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?selection@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?selection@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?selection@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?selection@@YAXXZ DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?selection@@YAXXZ$3
__catchsym$?selection@@YAXXZ$3 DD 00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe0H
	DD	FLAT:__catch$?selection@@YAXXZ$0
	DD	00H
	DD	FLAT:??_R0H@8
	DD	0ffffffdcH
	DD	FLAT:__catch$?selection@@YAXXZ$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$9
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	07H
	DD	FLAT:___std_terminate
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$9
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	07H
	DD	FLAT:___std_terminate
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$9
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	07H
	DD	FLAT:___std_terminate
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z DD 08H
	DD	08H
	DD	09H
	DD	01H
	DD	FLAT:__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$14
__unwindtable$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$2
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$9
	DD	04H
	DD	FLAT:__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$7
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__catchsym$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1
	DD	03H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$5
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2
	DD	03H
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2
__catchsym$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
;	COMDAT _ldexpf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_ldexpf	PROC						; COMDAT

; 707  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 64					; 00000040H
	movss	xmm0, DWORD PTR __X$[ebp]

; 708  :         return (float)ldexp(_X, _Y);

	push	DWORD PTR __Y$[ebp]
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	fstp	DWORD PTR tv73[esp+76]
	fld	DWORD PTR tv73[esp+76]
	add	esp, 12					; 0000000cH

; 709  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_ldexpf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv72 = -4						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 744  :         {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	movss	xmm1, DWORD PTR __Y$[ebp]
	movss	xmm0, DWORD PTR __X$[ebp]

; 745  :             return (float)pow(_X, _Y);

	cvtps2pd xmm0, xmm0
	cvtps2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv72[esp+8], xmm0
	fld	DWORD PTR tv72[esp+8]

; 746  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_powf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
tv68 = -8						; size = 8
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 842  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 843  :         return fabs((double)_X);

	movsd	xmm0, QWORD PTR __X$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR tv68[ebp], xmm0
	fld	QWORD PTR tv68[ebp]

; 844  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 863  :     {

	push	ebp
	mov	ebp, esp

; 864  :         return frexp((double)_X, _Y);

	push	DWORD PTR __Y$[ebp]
	movsd	xmm0, QWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_frexp
	add	esp, 12					; 0000000cH

; 865  :     }

	pop	ebp
	ret	0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
;	COMDAT _ldexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_ldexpl	PROC						; COMDAT

; 880  :     {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H

; 881  :         return ldexp((double)_X, _Y);

	push	DWORD PTR __Y$[ebp]
	movsd	xmm0, QWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	add	esp, 12					; 0000000cH

; 882  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_ldexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\cmath
;	COMDAT ?pow@@YANNH@Z
_TEXT	SEGMENT
?pow@@YANNH@Z PROC					; pow, COMDAT
; __Yx$dead$ = ecx
; __Xx$dead$ = xmm1l

; 17   : 	{

	push	ebp
	mov	ebp, esp
	movsd	xmm0, QWORD PTR ?powcheck@@3NA
	sub	esp, 8

; 18   : 	if (_Yx == 2)
; 19   : 		return (_Xx * _Xx);

	mulsd	xmm0, xmm0

; 20   : 
; 21   : 	return (_CSTD pow(_Xx, static_cast<double>(_Yx)));
; 22   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?pow@@YANNH@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 55   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[ebp+4], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	___std_exception_copy
	add	esp, 8

; 58   :     }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 62   :     {

	push	ebp
	mov	ebp, esp

; 63   :         _Data._What = _Message;

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [ecx+4], xmm0
	mov	DWORD PTR [ecx+4], eax

; 64   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 68   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8

; 70   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx

; 87   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 92   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 684  : 		return (INT_MAX);

	mov	eax, 2147483647				; 7fffffffH

; 685  : 		}

	ret	0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 180  :     {

	push	ebp
	mov	ebp, esp

; 181  :         (void)_Size;
; 182  :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 183  :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 443  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 444  : #if _HAS_CONSTEXPR_CHAR_TRAITS
; 445  : 		return (__builtin_strlen(_First));
; 446  : #else /* _HAS_CONSTEXPR_CHAR_TRAITS */
; 447  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 448  : #endif /* _HAS_CONSTEXPR_CHAR_TRAITS */
; 449  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 453  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 455  : 		}

	pop	ebp

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 477  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 479  : 		}

	pop	ebp

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADQADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 483  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	DWORD PTR __Count$[ebp]
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 485  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADQADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 488  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 490  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 503  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 504  : 		return (static_cast<char>(_Meta));

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 505  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT

; 508  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 509  : 		return (static_cast<unsigned char>(_Ch));

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 510  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 513  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp

; 514  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 515  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 524  : 		return (EOF);

	or	eax, -1

; 525  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 82   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   : 	{	// gets the size of _Count copies of a type with size 1

	push	ebp
	mov	ebp, esp

; 38   : 	return (_Count);

	mov	eax, DWORD PTR __Count$[ebp]

; 39   : 	}

	pop	ebp
	ret	0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   : 		{

	push	ebp
	mov	ebp, esp

; 53   : 		}

	pop	ebp

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPAXI@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 116  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

	push	ebp
	mov	ebp, esp

; 117  : 	_Bytes += _Non_user_size;

	mov	eax, DWORD PTR __Bytes$[ebp]

; 118  : 
; 119  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	DWORD PTR [eax], 35			; 00000023H
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax-4]

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN3@Adjust_man

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	DWORD PTR [ecx], edx

; 145  : 	}

	pop	ebp
	ret	0
$LN3@Adjust_man:

; 140  : 		{
; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	jmp	__invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1247 : 	{	// convert size_t to size_t, unchanged

	push	ebp
	mov	ebp, esp

; 1248 : 	return (_Len);

	mov	eax, DWORD PTR __Len$[ebp]

; 1249 : 	}

	pop	ebp
	ret	0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__InitData$4 = -8					; size = 8
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 165  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	edx, DWORD PTR __Message$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 165  : 		{	// construct from message string

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edx+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 165  : 		{	// construct from message string

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN10@runtime_er
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN10@runtime_er:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 54   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 55   :     {

	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$4[ebp], edx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR __InitData$4[ebp]
	push	eax
	mov	BYTE PTR __InitData$4[ebp+4], 1
	call	___std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 165  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 166  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@PBD@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 170  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 170  : 		{	// construct from message string

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$1[ebp+4], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$1[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	___std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 170  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@

; 171  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@PBD@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_typeinfo.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 131  :     {

	xorps	xmm0, xmm0

; 132  :     }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 61   :         : _Data()

	movq	QWORD PTR [ecx+4], xmm0

; 62   :     {
; 63   :         _Data._What = _Message;

	mov	DWORD PTR [ecx+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast?$AA@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_typeinfo.h

; 131  :     {

	mov	DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@

; 132  :     }

	ret	0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 76   : 		{	// construct from NTBS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Locinfo@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 73   : 		: _Lock(_LOCK_LOCALE)

	push	0
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4139 : 		: _Myptr(0), _Nul(0)

	mov	DWORD PTR [esi+4], 0
	mov	BYTE PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	mov	BYTE PTR [esi+16], 0
	xor	eax, eax
	mov	DWORD PTR [esi+20], 0
	mov	WORD PTR [esi+24], ax
	mov	DWORD PTR [esi+28], eax
	mov	WORD PTR [esi+32], ax
	mov	DWORD PTR [esi+36], eax
	mov	BYTE PTR [esi+40], al
	mov	DWORD PTR [esi+44], eax
	mov	BYTE PTR [esi+48], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 77   : 		if (_Pch == 0)

	mov	eax, DWORD PTR __Pch$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	eax, eax
	je	SHORT $LN26@Locinfo

; 79   : 		_Locinfo_ctor(this, _Pch);

	push	eax
	push	esi
	call	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
	add	esp, 8

; 80   : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN26@Locinfo:

; 78   : 			_THROW(runtime_error("bad locale name"));

	push	OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0runtime_error@std@@QAE@PBD@Z		; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN24@Locinfo:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$_Yarn@_W@std@@QAE@XZ		; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$_Yarn@D@std@@QAE@XZ		; std::_Yarn<char>::~_Yarn<char>
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Locinfo@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 95   : 		_Locinfo_dtor(this);

	push	esi
	call	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+44]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 95   : 		_Locinfo_dtor(this);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4217 : 		if (_Myptr != 0)

	test	eax, eax
	je	SHORT $LN6@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Locinfo:

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+44], 0

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN11@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN11@Locinfo:

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+36], 0

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN16@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN16@Locinfo:

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+28], 0

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN21@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN21@Locinfo:

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+20], 0

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN26@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN26@Locinfo:

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+12], 0

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN31@Locinfo

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN31@Locinfo:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 96   : 		}

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4226 : 		_Myptr = 0;

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 96   : 		}

	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 16
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 116  : 		{	// return ctype stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getctype
	add	esp, 4
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movups	XMMWORD PTR [eax], xmm0

; 118  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 44
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 121  : 		{	// return codecvt stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__Getcvt
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 4
	movups	xmm0, XMMWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+40]
	movups	XMMWORD PTR [edx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [edx+16], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	mov	eax, edx
	movq	QWORD PTR [edx+32], xmm0
	mov	DWORD PTR [edx+40], ecx

; 123  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 127  : 		return (localeconv());

	jmp	_localeconv
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 167  : 		return ("false");

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@

; 168  : 		}

	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 172  : 		return ("true");

	mov	eax, OFFSET ??_C@_04LOAJBDKD@true?$AA@

; 173  : 		}

	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 67   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@

; 27   : 		}

	ret	0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN6@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 111  : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp

; 110  : 			: _Id(_Val)

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 112  : 			}

	mov	eax, ecx
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 115  : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 116  : 			if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN6@operator

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	0
	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN3@operator

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR [esi], eax
$LN3@operator:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$1[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$LN6@operator:

; 122  : 				}
; 123  : 			return (_Id);
; 124  : 			}

	mov	eax, DWORD PTR [esi]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 151  : 			_MT_INCR(_Myrefs);

	lock	 inc	 DWORD PTR [ecx+4]

; 152  : 			}

	ret	0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 156  : 			if (_MT_DECR(_Myrefs) == 0)

	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx+4], eax
	mov	eax, 0
	cmove	eax, ecx

; 157  : 				return (this);
; 158  : 			else
; 159  : 				return (0);
; 160  : 			}

	ret	0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 168  : 			{	// construct with initial reference count

	push	ebp
	mov	ebp, esp

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 169  : 			}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7facet@locale@std@@6B@
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 173  : 			}

	ret	0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 299  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0locale@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 298  : 		: _Ptr(_Right._Ptr)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 301  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 404  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1locale@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN4@locale

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN4@locale
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN4@locale:

; 407  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1locale@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1locale@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?c_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@locale@std@@QBEPBDXZ PROC			; std::locale::c_str, COMDAT
; _this$ = ecx

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@c_str
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@

; 428  : 		}

	ret	0
$LN3@c_str:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN7@c_str
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, ecx

; 428  : 		}

	ret	0
$LN7@c_str:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	add	eax, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 428  : 		}

	ret	0
?c_str@locale@std@@QBEPBDXZ ENDP			; std::locale::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 431  : 		{	// look up a facet in locale object

	push	ebp
	mov	ebp, esp

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR __Id$[ebp]
	cmp	esi, DWORD PTR [ecx+12]
	jae	SHORT $LN6@Getfacet
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+esi*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	eax, eax
	jne	SHORT $LN3@Getfacet
	jmp	SHORT $LN10@Getfacet
$LN6@Getfacet:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	eax, eax
$LN10@Getfacet:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN3@Getfacet

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN8@Getfacet
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 440  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 441  : 				: 0);	// no entry in current locale
; 442  : 			}
; 443  : 		}

	pop	ebp
	ret	4
$LN8@Getfacet:

; 439  : 			return (_Id < _Ptr0->_Facetcount

	xor	eax, eax
$LN3@Getfacet:
	pop	esi

; 440  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 441  : 				: 0);	// no entry in current locale
; 442  : 			}
; 443  : 		}

	pop	ebp
	ret	4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN9@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
	mov	eax, ecx
	ret	0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2072 : 		{	// default constructor

	push	ebp
	mov	ebp, esp

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2073 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
	pop	ebp
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2077 : 		}

	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN12@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2337 : 		{	// test if element fits any mask classifications

	push	ebp
	mov	ebp, esp

; 2338 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	movzx	edx, BYTE PTR __Ch$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ax, WORD PTR __Maskval$[ebp]
	test	WORD PTR [ecx+edx*2], ax
	setne	al

; 2339 : 		}

	pop	ebp
	ret	8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2395 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [ecx]

; 2397 : 		}

	pop	ebp

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	jmp	DWORD PTR [eax+28]
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2436 : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Refs$[ebp]

; 2436 : 		{	// construct from current locale

	sub	esp, 20					; 00000014H
	push	esi
	mov	esi, ecx

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2436 : 		{	// construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2470 : 		_Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]

; 2437 : 		_Init(_Lobj);
; 2438 : 		}

	mov	eax, esi

; 2470 : 		_Ctype = _Lobj._Getctype();

	movups	XMMWORD PTR [esi+8], xmm0

; 2437 : 		_Init(_Lobj);
; 2438 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T3 = -92						; size = 52
$T4 = -40						; size = 16
$T2 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2442 : 		{	// return locale category mask and construct standard facet

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2443 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[ebx]
	test	esi, esi
	je	SHORT $LN30@Getcat
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN30@Getcat

; 2444 : 			*_Ppf = new ctype<_Elem>(

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebx]

; 2444 : 			*_Ppf = new ctype<_Elem>(

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN12@Getcat
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [edx+24]
	test	ecx, ecx
	jne	SHORT $LN17@Getcat
	lea	ecx, DWORD PTR [edx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2444 : 			*_Ppf = new ctype<_Elem>(

	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [edi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2436 : 		{	// construct from current locale

	mov	DWORD PTR [edi], OFFSET ??_7?$ctype@D@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2444 : 			*_Ppf = new ctype<_Elem>(

	lea	ecx, DWORD PTR $T3[ebp]

; 2470 : 		_Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+8], xmm0

; 2444 : 			*_Ppf = new ctype<_Elem>(

	mov	DWORD PTR [esi], edi
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN30@Getcat:

; 2445 : 				_Locinfo(_Ploc->c_str()));
; 2446 : 		return (_X_CTYPE);
; 2447 : 		}

	mov	eax, 2
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	push	24					; 00000018H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2464 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 2475 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]

; 2464 : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2475 : 		if (0 < _Ctype._Delfl)

	test	eax, eax
	jle	SHORT $LN16@ctype

; 2476 : 			_CSTD free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN17@ctype
$LN16@ctype:

; 2477 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN6@ctype

; 2478 : 			delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN17@ctype:

; 2479 : 
; 2480 : 		_CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN6@ctype:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2466 : 		}

	ret	0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2469 : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2469 : 		{	// initialize from _Lobj

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2469 : 		{	// initialize from _Lobj

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2470 : 		_Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2471 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2474 : 		{	// free any allocated storage

	push	esi
	mov	esi, ecx

; 2475 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	jle	SHORT $LN6@Tidy

; 2476 : 			_CSTD free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free

; 2479 : 
; 2480 : 		_CSTD free(_Ctype._LocaleName);

	add	esp, 4
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2481 : 		}

	ret	0
$LN6@Tidy:

; 2477 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN4@Tidy

; 2478 : 			delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]

; 2479 : 
; 2480 : 		_CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN4@Tidy:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
	pop	esi

; 2481 : 		}

	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2484 : 		{	// convert element to lower case

	push	ebp
	mov	ebp, esp

; 2485 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	call	__Tolower
	add	esp, 8

; 2486 : 		}

	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv136 = 12						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2490 : 		{	// convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	push	ebx

; 2491 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2492 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[ebp]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN10@do_tolower
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv136[ebp], eax
$LL4@do_tolower:

; 2493 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	push	eax
	movzx	eax, BYTE PTR [esi]
	push	eax
	call	__Tolower
	mov	BYTE PTR [esi], al
	inc	edi
	mov	eax, DWORD PTR tv136[ebp]
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_tolower
$LN10@do_tolower:
	pop	edi

; 2494 : 		return ((const _Elem *)_First);
; 2495 : 		}

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2498 : 		{	// convert element to upper case

	push	ebp
	mov	ebp, esp

; 2499 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	lea	eax, DWORD PTR [ecx+8]
	push	eax
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	call	__Toupper
	add	esp, 8

; 2500 : 		}

	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv136 = 12						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2504 : 		{	// convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	push	ebx

; 2505 : 		_DEBUG_RANGE((const _Elem *)_First, _Last);
; 2506 : 		for (; _First != _Last; ++_First)

	mov	ebx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	sub	ebx, esi
	push	edi
	xor	edi, edi
	cmp	esi, DWORD PTR __Last$[ebp]
	cmova	ebx, edx
	test	ebx, ebx
	je	SHORT $LN10@do_toupper
	lea	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR tv136[ebp], eax
$LL4@do_toupper:

; 2507 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	push	eax
	movzx	eax, BYTE PTR [esi]
	push	eax
	call	__Toupper
	mov	BYTE PTR [esi], al
	inc	edi
	mov	eax, DWORD PTR tv136[ebp]
	add	esp, 8
	inc	esi
	cmp	edi, ebx
	jne	SHORT $LL4@do_toupper
$LN10@do_toupper:
	pop	edi

; 2508 : 		return ((const _Elem *)_First);
; 2509 : 		}

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2512 : 		{	// widen char

	push	ebp
	mov	ebp, esp

; 2513 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 2514 : 		}

	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2518 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2519 : 		_DEBUG_RANGE(_First, _Last);
; 2520 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[ebp]
	call	_memcpy

; 2521 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 12					; 0000000cH

; 2522 : 		}

	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2525 : 		{	// narrow char

	push	ebp
	mov	ebp, esp

; 2526 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 2527 : 		}

	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2531 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp

; 2532 : 		_DEBUG_RANGE(_First, _Last);
; 2533 : 		_CSTD memcpy(_Dest, _First, _Last - _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, edx
	push	ecx
	push	edx
	push	DWORD PTR __Dest$[ebp]
	call	_memcpy

; 2534 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	add	esp, 12					; 0000000cH

; 2535 : 		}

	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2464 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 2475 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR [esi+16]

; 2464 : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@

; 2475 : 		if (0 < _Ctype._Delfl)

	test	eax, eax
	jle	SHORT $LN21@scalar

; 2476 : 			_CSTD free((void *)_Ctype._Table);

	push	DWORD PTR [esi+12]
	call	_free
	jmp	SHORT $LN22@scalar
$LN21@scalar:

; 2477 : 		else if (_Ctype._Delfl < 0)

	jns	SHORT $LN10@scalar

; 2478 : 			delete[] _Ctype._Table;

	push	DWORD PTR [esi+12]
	call	??_V@YAXPAX@Z				; operator delete[]
$LN22@scalar:

; 2479 : 
; 2480 : 		_CSTD free(_Ctype._LocaleName);

	add	esp, 4
$LN10@scalar:
	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN20@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN20@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 75   : 		{	// default constructor
; 76   : 		_Addr = reinterpret_cast<uintptr_t>(this);

	mov	DWORD PTR [ecx+4], ecx

; 77   : 		}

	mov	eax, ecx
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 81   : 		}

	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 94   : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp

; 95   : 		return (_Addr == _Right._Addr);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 96   : 		}

	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 136  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp

; 134  : 		: _Myval(_Val),

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 135  : 		_Mycat(&_Cat)

	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 137  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 170  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 171  : 		}

	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 175  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 176  : 		}

	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 181  : 		{	// get name of error code

	push	ebp
	mov	ebp, esp

; 175  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 182  : 		return (category().message(value()));

	push	DWORD PTR [ecx]
	mov	ecx, eax
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 183  : 		}

	pop	ebp
	ret	4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 208  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp

; 206  : 		: _Myval(_Val),

	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [ecx], eax

; 207  : 		_Mycat(&_Cat)

	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 209  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 242  : 		return (_Myval);

	mov	eax, DWORD PTR [ecx]

; 243  : 		}

	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 247  : 		return (*_Mycat);

	mov	eax, DWORD PTR [ecx+4]

; 248  : 		}

	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 285  : 	{	// test errors for equality

	push	ebp
	mov	ebp, esp

; 95   : 		return (_Addr == _Right._Addr);

	mov	edx, DWORD PTR __Left$[ebp]

; 285  : 	{	// test errors for equality

	push	esi

; 95   : 		return (_Addr == _Right._Addr);

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [ecx+4]

; 286  : 	return (_Left.category() == _Right.category()

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN3@operator
	mov	al, 1
	pop	esi

; 287  : 		&& _Left.value() == _Right.value());
; 288  : 	}

	pop	ebp
	ret	0
$LN3@operator:

; 286  : 	return (_Left.category() == _Right.category()

	xor	al, al
	pop	esi

; 287  : 		&& _Left.value() == _Right.value());
; 288  : 	}

	pop	ebp
	ret	0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 328  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp

; 206  : 		: _Myval(_Val),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Errval$[ebp]
	mov	DWORD PTR [eax], edx

; 207  : 		_Mycat(&_Cat)

	mov	DWORD PTR [eax+4], ecx

; 329  : 	return (error_condition(_Errval, *this));
; 330  : 	}

	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 333  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp

; 334  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR $T1[ebp]
	sub	esp, 8
	push	esi
	push	DWORD PTR __Errval$[ebp]
	push	edx
	call	DWORD PTR [eax+12]

; 95   : 		return (_Addr == _Right._Addr);

	mov	esi, DWORD PTR __Cond$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+4]

; 286  : 	return (_Left.category() == _Right.category()

	jne	SHORT $LN5@equivalent
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN5@equivalent
	mov	al, 1
	pop	esi

; 335  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN5@equivalent:

; 286  : 	return (_Left.category() == _Right.category()

	xor	al, al
	pop	esi

; 335  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 338  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp

; 95   : 		return (_Addr == _Right._Addr);

	mov	eax, DWORD PTR [ecx+4]

; 338  : 	{	// test if conditions same for this category

	push	esi

; 95   : 		return (_Addr == _Right._Addr);

	mov	esi, DWORD PTR __Code$[ebp]
	mov	edx, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [edx+4]

; 339  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	jne	SHORT $LN3@equivalent
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	al, 1
	pop	esi

; 340  : 	}

	pop	ebp
	ret	8
$LN3@equivalent:

; 339  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	xor	al, al
	pop	esi

; 340  : 	}

	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 355  : 	{	// make an error_code

	push	ebp
	mov	ebp, esp

; 612  : 	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 134  : 		: _Myval(_Val),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR [eax], ecx

; 135  : 		_Mycat(&_Cat)

	mov	DWORD PTR [eax+4], OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 356  : 	return (error_code((int)_Errno, iostream_category()));
; 357  : 	}

	pop	ebp
	ret	0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
__Count$1$ = -48					; size = 4
$T19 = -48						; size = 1
$T10 = -48						; size = 1
$T13 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 401  : 		{	// compose error message

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR ___$ReturnUdt$[ebx]
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 402  : 		if (!_Message.empty())

	mov	ecx, DWORD PTR __Message$[ebx+16]
	test	ecx, ecx
	je	SHORT $LN22@Makestr
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR __Message$[ebx+20]
	mov	eax, edx
	sub	eax, ecx

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	push	2
	push	OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	cmp	eax, 2
	jb	SHORT $LN23@Makestr

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Message$[ebx]

; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+2]

; 1787 : 		if (_Large_string_engaged())

	cmovae	esi, DWORD PTR __Message$[ebx]

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	esi, ecx
	mov	DWORD PTR __Message$[ebx+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+2], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2560 : 			return (*this);

	jmp	SHORT $LN22@Makestr
$LN23@Makestr:

; 2561 : 			}
; 2562 : 
; 2563 : 		return (_Reallocate_grow_by(_Count,

	mov	BYTE PTR $T10[ebp], 0
	lea	ecx, DWORD PTR __Message$[ebx]
	push	DWORD PTR $T10[ebp]
	push	2
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN22@Makestr:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 182  : 		return (category().message(value()));

	mov	ecx, DWORD PTR __Errcode$[ebx+4]
	lea	edx, DWORD PTR $T13[ebp]
	push	DWORD PTR __Errcode$[ebx]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]

; 403  : 			{
; 404  : 			_Message.append(": ");
; 405  : 			}
; 406  : 
; 407  : 		_Message.append(_Errcode.message());

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	edx, DWORD PTR $T13[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR $T13[ebp+20], 16		; 00000010H

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	ecx, DWORD PTR $T13[ebp+16]

; 1798 : 		if (_Large_string_engaged())

	cmovae	edx, DWORD PTR $T13[ebp]

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __Message$[ebx+20]
	mov	esi, DWORD PTR __Message$[ebx+16]
	sub	eax, esi

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	DWORD PTR __Count$1$[ebp], ecx

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	push	ecx
	push	edx
	cmp	ecx, eax
	ja	SHORT $LN62@Makestr

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Message$[ebx+20], 16	; 00000010H

; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR __Message$[ebx+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Message$[ebx]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Message$[ebx]

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	call	_memmove

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR __Count$1$[ebp]

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2560 : 			return (*this);

	jmp	SHORT $LN61@Makestr
$LN62@Makestr:

; 2561 : 			}
; 2562 : 
; 2563 : 		return (_Reallocate_grow_by(_Count,

	mov	BYTE PTR $T19[ebp], 0
	push	DWORD PTR $T19[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Message$[ebx]
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN61@Makestr:

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T13[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN116@Makestr
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T13[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN115@Makestr

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN234@Makestr
$LN115@Makestr:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN116@Makestr:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR __Message$[ebx]

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 408  : 		return (_Message);

	mov	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1768 : 		_Myres(0)

	mov	DWORD PTR [edi+20], 0

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR [edi], xmm0
	movq	xmm0, QWORD PTR __Message$[ebx+16]
	movq	QWORD PTR [edi+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 409  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN234@Makestr:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN232@Makestr:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
	mov	ebx, DWORD PTR [ebp-16]
	lea	ecx, DWORD PTR __Message$[ebx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Right_size$1$ = -40					; size = 4
__InitData$41 = -40					; size = 8
_this$ = -40						; size = 4
_this$1$ = -32						; size = 4
$T30 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 415  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+44], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Message$[ebp]
	sub	esp, 24					; 00000018H
	mov	esi, ecx
	mov	ecx, esp
	mov	DWORD PTR _this$[esp+80], esi
	mov	DWORD PTR _this$1$[esp+80], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2382 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR __Right_size$1$[esp+80], eax

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN36@System_err
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN36@System_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2384 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN25@System_err
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	movups	xmm0, XMMWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2388 : 			_My_data._Myres = this->_BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	movups	XMMWORD PTR [ecx], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2389 : 			return;

	jmp	SHORT $LN24@System_err
$LN25@System_err:

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, 2147483647				; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	or	ebx, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ebx, eax
	cmova	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2394 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN69@System_err

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN149@System_err

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN68@System_err
$LN69@System_err:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN70@System_err

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, eax
	jmp	SHORT $LN68@System_err
$LN70@System_err:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ecx, ecx
$LN68@System_err:

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR _this$1$[esp+80]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2396 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$1$[esp+80]
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	edi
	push	ecx
	call	_memcpy
	mov	ecx, DWORD PTR _this$1$[esp+92]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR __Right_size$1$[esp+80]
$LN24@System_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 413  : 		: runtime_error(_Makestr(_Errcode, _Message)),

	mov	DWORD PTR [ecx+16], eax
	lea	eax, DWORD PTR $T30[esp+80]
	mov	DWORD PTR [ecx+20], ebx
	push	DWORD PTR __Errcode$[ebp+4]
	push	DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
	mov	ecx, eax
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN106@System_err
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN106@System_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 54   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 55   :     {

	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	xorps	xmm0, xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$41[esp+56], ecx

; 57   :         __std_exception_copy(&_InitData, &_Data);

	push	eax
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR __InitData$41[esp+60]
	push	eax
	mov	BYTE PTR __InitData$41[esp+68], 1
	call	___std_exception_copy
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T30[esp+84]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h

; 57   :         __std_exception_copy(&_InitData, &_Data);

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\stdexcept

; 165  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN151@System_err
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T30[esp+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN150@System_err

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN149@System_err
$LN150@System_err:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN151@System_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 414  : 		_Mycode(_Errcode)

	mov	ecx, DWORD PTR __Errcode$[ebp]

; 416  : 		}

	mov	eax, esi
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR __Errcode$[ebp+4]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+56]
	pop	edi
	mov	DWORD PTR [esi], OFFSET ??_7_System_error@std@@6B@
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN149@System_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN168@System_err:
	int	3
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 440  : 		{	// construct from error code and message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	eax, DWORD PTR __Message$[ebp]
	lea	ecx, DWORD PTR $T1[ebp]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	push	DWORD PTR __Errcode$[ebp+4]
	mov	ecx, esi
	push	DWORD PTR __Errcode$[ebp]
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T1[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN42@system_err
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN41@system_err

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN63@system_err
$LN41@system_err:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN42@system_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 440  : 		{	// construct from error code and message string

	mov	DWORD PTR [esi], OFFSET ??_7system_error@std@@6B@

; 441  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN63@system_err:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN61@system_err:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN15@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN15@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 484  : 	_Generic_error_category() _NOEXCEPT

	mov	DWORD PTR [ecx], OFFSET ??_7_Generic_error_category@std@@6B@

; 485  : 		{	// default constructor
; 486  : 		_Addr = _Generic_addr;
; 487  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 3
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 491  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 492  : 		}

	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 495  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp

; 496  : 		return (_Syserror_map(_Errcode));

	push	DWORD PTR __Errcode$[ebp]
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	add	esp, 4
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : 		}

	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN9@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 505  : 	_Iostream_error_category() _NOEXCEPT

	mov	DWORD PTR [ecx], OFFSET ??_7_Iostream_error_category@std@@6B@

; 506  : 		{	// default constructor
; 507  : 		_Addr = _Iostream_addr;
; 508  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 5
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 512  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 513  : 		}

	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 516  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp

; 517  : 		if (_Errcode == (int)io_errc::stream)

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	esi
	cmp	eax, 1
	jne	SHORT $LN2@message

; 518  : 			{
; 519  : 			return ("iostream stream error");
; 520  : 			}
; 521  : 		else
; 522  : 			{
; 523  : 			return (_Generic_error_category::message(_Errcode));
; 524  : 			}
; 525  : 		}

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebp
	ret	8
$LN2@message:

; 496  : 		return (_Syserror_map(_Errcode));

	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map

; 518  : 			{
; 519  : 			return ("iostream stream error");
; 520  : 			}
; 521  : 		else
; 522  : 			{
; 523  : 			return (_Generic_error_category::message(_Errcode));
; 524  : 			}
; 525  : 		}

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]

; 496  : 		return (_Syserror_map(_Errcode));

	add	esp, 4
	push	eax

; 518  : 			{
; 519  : 			return ("iostream stream error");
; 520  : 			}
; 521  : 		else
; 522  : 			{
; 523  : 			return (_Generic_error_category::message(_Errcode));
; 524  : 			}
; 525  : 		}

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx
	je	SHORT $LN12@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 612  : 	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 628  : 	return (_Immortalize<_Iostream_error_category>());
; 629  : 	}

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	ret	0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 238  : 			{	// construct with message

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx
	mov	eax, DWORD PTR __Errcode$[ebp]
	mov	ecx, DWORD PTR __Message$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 439  : 		: _Mybase(_Errcode, _Message)

	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 237  : 			: system_error(_Errcode, _Message)

	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error

; 439  : 		: _Mybase(_Errcode, _Message)

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	push	esi
	push	edi
	mov	ecx, ebx
	call	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T1[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN45@failure
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN44@failure

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN67@failure
$LN44@failure:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN45@failure:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 238  : 			{	// construct with message

	mov	DWORD PTR [ebx], OFFSET ??_7failure@ios_base@std@@6B@

; 239  : 			}

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN67@failure:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN65@failure:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T6 = -20						; size = 20
$T4 = -20						; size = 20
$T2 = -20						; size = 20
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 287  : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 288  : 		_Mystate = (iostate)(_State & _Statmask);

	mov	eax, DWORD PTR __State$[ebp]
	sub	esp, 32					; 00000020H
	and	eax, 23					; 00000017H
	mov	DWORD PTR [ecx+12], eax

; 289  : 		if ((_Mystate & _Except) == 0)

	mov	ecx, DWORD PTR [ecx+16]
	and	ecx, eax
	je	SHORT $LN9@clear

; 290  : 			;
; 291  : 		else if (_Reraise)

	cmp	BYTE PTR __Reraise$[ebp], 0
	jne	SHORT $LN13@clear

; 293  : 		else if (_Mystate & _Except & badbit)

	lea	eax, DWORD PTR $T1[esp+32]
	push	1
	push	eax
	test	cl, 4
	jne	SHORT $LN14@clear

; 295  : 		else if (_Mystate & _Except & failbit)

	test	cl, 2
	je	SHORT $LN8@clear
	jmp	SHORT $LN15@clear
$LN9@clear:

; 299  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN13@clear:

; 292  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN14@clear:

; 294  : 			_THROW(failure("ios_base::badbit set"));

	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	lea	ecx, DWORD PTR $T2[esp+32]
	push	eax
	push	OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set?$AA@
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T2[esp+36]
	push	eax
	call	__CxxThrowException@8
$LN15@clear:

; 296  : 			_THROW(failure("ios_base::failbit set"));

	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	lea	ecx, DWORD PTR $T4[esp+32]
	push	eax
	push	OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set?$AA@
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T4[esp+36]
	push	eax
	call	__CxxThrowException@8
$LN8@clear:

; 297  : 		else
; 298  : 			_THROW(failure("ios_base::eofbit set"));

	call	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
	add	esp, 8
	lea	ecx, DWORD PTR $T6[esp+32]
	push	eax
	push	OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set?$AA@
	call	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
	push	OFFSET __TI5?AVfailure@ios_base@std@@
	lea	eax, DWORD PTR $T6[esp+36]
	push	eax
	call	__CxxThrowException@8
$LN11@clear:
	int	3
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+12]

; 316  : 		}

	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+12], 0
	sete	al

; 340  : 		}

	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
?fail@ios_base@std@@QBE_NXZ PROC			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 349  : 		return (((int)rdstate()

	test	BYTE PTR [ecx+12], 6
	setne	al

; 350  : 			& ((int)badbit | (int)failbit)) != 0);
; 351  : 		}

	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+20]

; 379  : 		}

	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 411  : 		return (_Prec);

	mov	eax, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR [ecx+28]

; 412  : 		}

	ret	0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]

; 424  : 		}

	ret	0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 427  : 		{	// set width to argument

	push	ebp
	mov	ebp, esp

; 428  : 		streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx+36]
	push	esi

; 429  : 		_Wide = _Newwidth;

	mov	esi, DWORD PTR __Newwidth$[ebp]
	mov	DWORD PTR [ecx+32], esi
	mov	esi, DWORD PTR __Newwidth$[ebp+4]
	mov	DWORD PTR [ecx+36], esi

; 430  : 		return (_Oldwidth);
; 431  : 		}

	pop	esi
	pop	ebp
	ret	8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 434  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, esi

; 436  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?getloc@ios_base@std@@QBE?AVlocale@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getloc@ios_base@std@@QBE?AVlocale@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 85   :     {

	push	esi
	mov	esi, ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN18@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx

; 86   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	___std_exception_destroy
	pop	ecx
	ret	0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[ebp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7failure@ios_base@std@@6B@
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[ebp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	mov	DWORD PTR [edi], OFFSET ??_7system_error@std@@6B@
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	esi, DWORD PTR ___that$[ebp]
	xorps	xmm0, xmm0

; 68   :     {

	push	edi
	mov	edi, ecx

; 67   :         : _Data()

	lea	eax, DWORD PTR [edi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	___std_exception_copy
	mov	DWORD PTR [edi], OFFSET ??_7_System_error@std@@6B@
	add	esp, 8
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Stodx_v2@std@@YANPBDPAPADHPAH@Z
_TEXT	SEGMENT
__Val$ = -8						; size = 8
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Pten$ = 16						; size = 4
__Perr$ = 20						; size = 4
?_Stodx_v2@std@@YANPBDPAPADHPAH@Z PROC			; std::_Stodx_v2, COMDAT

; 55   : 	{	// convert string to double

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	push	edi

; 56   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno

; 57   : 	const int _Orig = _Errno_ref;
; 58   : 
; 59   : 	_Errno_ref = 0;
; 60   : 	double _Val = _CSTD strtod(_Str, _Endptr);

	push	DWORD PTR __Endptr$[ebp]
	mov	edi, eax
	push	DWORD PTR __Str$[ebp]
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], 0
	call	_strtod

; 61   : 	*_Perr = _Errno_ref;

	mov	eax, DWORD PTR __Perr$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [edi]
	fst	QWORD PTR __Val$[esp+16]
	mov	DWORD PTR [eax], ecx

; 62   : 	_Errno_ref = _Orig;
; 63   : 
; 64   : 	if (_Pten != 0)

	mov	eax, DWORD PTR __Pten$[ebp]
	mov	DWORD PTR [edi], esi
	test	eax, eax
	je	SHORT $LN2@Stodx_v2

; 65   : 		_Val *= _CSTD pow(10.0, static_cast<double>(_Pten));

	movsd	xmm0, QWORD PTR __real@4024000000000000
	fstp	ST(0)
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __Val$[esp+16]
	movsd	QWORD PTR __Val$[esp+16], xmm0

; 66   : 
; 67   : 	return (_Val);

	fld	QWORD PTR __Val$[esp+16]
$LN2@Stodx_v2:

; 68   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Stodx_v2@std@@YANPBDPAPADHPAH@Z ENDP			; std::_Stodx_v2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z
_TEXT	SEGMENT
__Val$ = -4						; size = 4
__Str$ = 8						; size = 4
__Endptr$ = 12						; size = 4
__Pten$ = 16						; size = 4
__Perr$ = 20						; size = 4
?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z PROC			; std::_Stofx_v2, COMDAT

; 72   : 	{	// convert string to float

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	push	edi

; 73   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno

; 74   : 	const int _Orig = _Errno_ref;
; 75   : 
; 76   : 	_Errno_ref = 0;
; 77   : 	float _Val = _CSTD strtof(_Str, _Endptr);

	push	DWORD PTR __Endptr$[ebp]
	mov	edi, eax
	push	DWORD PTR __Str$[ebp]
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], 0
	call	_strtof

; 78   : 	*_Perr = _Errno_ref;

	mov	eax, DWORD PTR __Perr$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [edi]
	fstp	DWORD PTR __Val$[esp+16]
	mov	DWORD PTR [eax], ecx

; 79   : 	_Errno_ref = _Orig;
; 80   : 
; 81   : 	if (_Pten != 0)

	mov	eax, DWORD PTR __Pten$[ebp]
	mov	DWORD PTR [edi], esi
	test	eax, eax
	je	SHORT $LN6@Stofx_v2
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 745  :             return (float)pow(_X, _Y);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 82   : 		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	cvtdq2ps xmm1, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 745  :             return (float)pow(_X, _Y);

	cvtps2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 82   : 		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	mulss	xmm0, DWORD PTR __Val$[esp+16]
	movss	DWORD PTR __Val$[esp+16], xmm0
$LN6@Stofx_v2:

; 83   : 
; 84   : 	return (_Val);
; 85   : 	}

	fld	DWORD PTR __Val$[esp+16]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?_Stofx_v2@std@@YAMPBDPAPADHPAH@Z ENDP			; std::_Stofx_v2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
;	COMDAT ?selection@@YAXXZ
_TEXT	SEGMENT
_msg$5 = -32						; size = 4
$T3 = -28						; size = 4
_choose$ = -24						; size = 4
$T2 = -20						; size = 4
__$EHRec$ = -16						; size = 16
?selection@@YAXXZ PROC					; selection, COMDAT

; 18   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?selection@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	npad	5
$base$27:

; 19   : 	int choose;
; 20   : 	base:cout << "Type 1 to start benchmarking." << '\n';

	mov	edx, OFFSET ??_C@_0BO@DAJFEOKA@Type?51?5to?5start?5benchmarking?4?$AA@
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 21   : 	try
; 22   : 	{
; 23   : 		cin >> (int) choose;

	lea	eax, DWORD PTR _choose$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	eax
	mov	ecx, OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
	call	??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ; std::basic_istream<char,std::char_traits<char> >::operator>>
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
	mov	eax, DWORD PTR [eax+4]

; 349  : 		return (((int)rdstate()

	test	BYTE PTR ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A[eax+12], 6
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp

; 24   : 		if (cin.fail())

	jne	SHORT $LN25@selection

; 26   : 		if (choose != 1)

	cmp	DWORD PTR _choose$[ebp], 1
	jne	SHORT $LN26@selection
	jmp	SHORT $LN9@selection
__catch$?selection@@YAXXZ$0:

; 29   : 		}
; 30   : 	}
; 31   : 	catch (char* msg)
; 32   : 	{
; 33   : 		cout << msg << '\n';

	mov	edx, DWORD PTR _msg$5[ebp]
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 34   : 		goto base;

	mov	eax, $LN10@selection
	ret	0
$LN10@selection:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp

; 34   : 		goto base;

	jmp	SHORT $base$27
$LN9@selection:

; 41   : 	}
; 42   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@selection:

; 25   : 			throw 2;

	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T2[ebp], 2
	push	eax
	call	__CxxThrowException@8
$LN26@selection:

; 27   : 		{
; 28   : 			throw "Invalid number, try again \n";

	push	OFFSET __TI2PAD
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T3[ebp], OFFSET ??_C@_0BM@BHCOCDDO@Invalid?5number?0?5try?5again?5?6?$AA@
	push	eax
	call	__CxxThrowException@8
__catch$?selection@@YAXXZ$1:

; 35   : 	}
; 36   : 	catch (int x)
; 37   : 	{
; 38   : 		cout << "Invalid entry. Program will close now. \n";

	mov	edx, OFFSET ??_C@_0CJ@BBLAGGGH@Invalid?5entry?4?5Program?5will?5clos@
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 39   : 		_getch();

	call	__getch

; 40   : 		exit(1);

	push	1
	call	_exit
$LN23@selection:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?selection@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?selection@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?selection@@YAXXZ ENDP					; selection
; Function compile flags: /Ogtp
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\cmath
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
;	COMDAT ?mainbase@@YAXXZ
_TEXT	SEGMENT
tv560 = -80						; size = 8
$T2 = -80						; size = 8
?a@@3NA$1 = -72						; size = 8
_elapsed_secs$1$ = -72					; size = 8
$T3 = -72						; size = 8
?b@@3NA$1 = -64						; size = 8
tv475 = -60						; size = 4
_r$4 = -52						; size = 4
__$ArrayPad$ = -4					; size = 4
?mainbase@@YAXXZ PROC					; mainbase, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 45   : 	long count;
; 46   : 	double timetake[5];
; 47   : 	// check is meant to find out if we should also include an explaination as to why a triplet is indeed a Pythagorean one.
; 48   : 	// D will represent C for greatest pythagorean triplet purposes.
; 49   : 	// k is the number which the user will enter. This value limits the value of a and b through which the program can search.
; 50   : 	for (int q = 1; q <= 5; q++)

	mov	ebx, 5
	npad	8
$LL4@mainbase:

; 51   : 	{
; 52   : 		for (int p = 1; p <= 5; p++)

	mov	esi, 1
$LL7@mainbase:

; 53   : 		{
; 54   : 			clock_t begin = clock();

	call	_clock

; 55   : 			a = 1;

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	mov	edi, eax

; 56   : 			b = 1;

	movsd	QWORD PTR ?b@@3NA$1[ebp], xmm1
	movaps	xmm0, xmm1
	movsd	QWORD PTR ?a@@3NA$1[ebp], xmm0
	movsd	QWORD PTR ?a@@3NA, xmm0
	movsd	QWORD PTR ?b@@3NA, xmm0

; 57   : 			c = 1;

	movsd	QWORD PTR ?c@@3NA, xmm1

; 58   : 			d = 1;

	movsd	QWORD PTR ?d@@3NA, xmm1

; 59   : 			count = 0;// a and b are the base/height.
; 60   : 			if (p == 1)

	cmp	esi, 1
	jne	SHORT $LN14@mainbase

; 61   : 				k = 100;

	movsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR ?k@@3NA, xmm0
	jmp	SHORT $LN54@mainbase
$LN14@mainbase:

; 62   : 			else if (p == 2)

	cmp	esi, 2
	jne	SHORT $LN16@mainbase

; 63   : 				k = 250;

	movsd	xmm0, QWORD PTR __real@406f400000000000
	movsd	QWORD PTR ?k@@3NA, xmm0
	jmp	SHORT $LN54@mainbase
$LN16@mainbase:

; 64   : 			else if (p == 3)

	cmp	esi, 3
	jne	SHORT $LN18@mainbase

; 65   : 				k = 500;

	movsd	xmm0, QWORD PTR __real@407f400000000000
	movsd	QWORD PTR ?k@@3NA, xmm0
	jmp	SHORT $LN54@mainbase
$LN18@mainbase:

; 66   : 			else if (p == 4)

	cmp	esi, 4
	jne	SHORT $LN20@mainbase

; 67   : 				k = 1000;

	movsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR ?k@@3NA, xmm0
	jmp	SHORT $LN54@mainbase
$LN20@mainbase:

; 68   : 			else if (p == 5)

	cmp	esi, 5
	jne	SHORT $LN37@mainbase

; 69   : 				k = 1500;

	movsd	xmm0, QWORD PTR __real@4097700000000000
	movsd	QWORD PTR ?k@@3NA, xmm0

; 70   : 			while (b <= k)

	jmp	SHORT $LN54@mainbase
$LN37@mainbase:
	movsd	xmm0, QWORD PTR ?k@@3NA
	comisd	xmm0, xmm1
	jb	$LN9@mainbase
$LN54@mainbase:
	mulsd	xmm0, QWORD PTR __real@3ff6b851eb851eb8
	sub	esp, 8

; 78   : 					while (powcheck <= ceil(1.42*k)) // Max value of c with relation to a and b is c = root2 of a , b

	movsd	QWORD PTR tv560[ebp], xmm0
	fld	QWORD PTR tv560[ebp]
	fstp	QWORD PTR [esp]
	call	_ceil
	movsd	xmm5, QWORD PTR __real@3ff0000000000000
	add	esp, 8
	movsd	xmm3, QWORD PTR ?d@@3NA
	movaps	xmm1, xmm5
	movsd	xmm4, QWORD PTR ?k@@3NA
	movsd	xmm6, QWORD PTR ?a@@3NA$1[ebp]
	fstp	QWORD PTR $T2[ebp]
	movsd	xmm7, QWORD PTR $T2[ebp]
	npad	4
$LL8@mainbase:

; 73   : 				{
; 74   : 					x = a*a;
; 75   : 					y = b*b;

	mulsd	xmm1, xmm1
	movaps	xmm0, xmm5
	movsd	QWORD PTR $T3[ebp], xmm1
	movsd	QWORD PTR ?y@@3NA, xmm1
$LL10@mainbase:
	mulsd	xmm0, xmm0
	movaps	xmm2, xmm1
	addsd	xmm2, xmm0
	movsd	QWORD PTR ?x@@3NA, xmm0

; 76   : 					c = x + y;
; 77   : 					powcheck = b;	// b as starting point. Meant to speed up execution

	movsd	xmm0, QWORD PTR ?b@@3NA$1[ebp]

; 78   : 					while (powcheck <= ceil(1.42*k)) // Max value of c with relation to a and b is c = root2 of a , b

	comisd	xmm7, xmm0
	movaps	xmm1, xmm0
	movsd	QWORD PTR ?c@@3NA, xmm2
	movsd	QWORD PTR ?powcheck@@3NA, xmm1
	jb	SHORT $LN13@mainbase
$LL12@mainbase:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\cmath

; 19   : 		return (_Xx * _Xx);

	movaps	xmm0, xmm1
	mulsd	xmm0, xmm1
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp

; 80   : 						if (c == pow(powcheck, 2))

	ucomisd	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@mainbase

; 81   : 						{
; 82   : 							if (c >= d)

	comisd	xmm2, xmm3
	jb	SHORT $LN25@mainbase

; 83   : 								d = c;

	movsd	QWORD PTR ?d@@3NA, xmm2
	movaps	xmm3, xmm2
$LN25@mainbase:

; 84   : 							++count;
; 85   : 							powcheck = 2 * k + 1;

	movaps	xmm1, xmm4
	mulsd	xmm1, QWORD PTR __real@4000000000000000
$LN23@mainbase:

; 78   : 					while (powcheck <= ceil(1.42*k)) // Max value of c with relation to a and b is c = root2 of a , b

	addsd	xmm1, xmm5
	comisd	xmm7, xmm1
	jae	SHORT $LL12@mainbase
	movsd	QWORD PTR ?powcheck@@3NA, xmm1
$LN13@mainbase:

; 71   : 			{
; 72   : 				while (a <= k)

	movsd	xmm1, QWORD PTR $T3[ebp]

; 86   : 						}
; 87   : 						else
; 88   : 						++powcheck;
; 89   : 					}
; 90   : 					++a;

	addsd	xmm6, xmm5
	comisd	xmm4, xmm6
	movaps	xmm0, xmm6
	jae	$LL10@mainbase

; 93   : 				++b;

	movsd	xmm0, QWORD PTR ?b@@3NA$1[ebp]
	movaps	xmm6, xmm5
	addsd	xmm0, xmm5
	comisd	xmm4, xmm0
	movsd	QWORD PTR ?b@@3NA$1[ebp], xmm0
	movaps	xmm1, xmm0
	movsd	QWORD PTR ?b@@3NA, xmm0
	jae	$LL8@mainbase

; 91   : 				}
; 92   : 				a = 1;

	movsd	QWORD PTR ?a@@3NA, xmm6
$LN9@mainbase:

; 94   : 			}
; 95   : 			clock_t end = clock();

	call	_clock

; 96   : 			double elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;

	sub	eax, edi
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	divsd	xmm2, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _elapsed_secs$1$[ebp], xmm2

; 97   : 			timetake[p - 1] = elapsed_secs;
; 98   : 			float r;
; 99   : 			if (p == 1)

	cmp	esi, 1
	jne	SHORT $LN26@mainbase

; 100  : 				r = 0.003;

	movss	xmm0, DWORD PTR __real@3b449ba6
	movss	DWORD PTR _r$4[ebp], xmm0

; 101  : 			if (p == 2)

	jmp	SHORT $LN30@mainbase
$LN26@mainbase:
	cmp	esi, 2
	jne	SHORT $LN27@mainbase

; 102  : 				r = 0.035;

	movss	xmm0, DWORD PTR __real@3d0f5c29
	movss	DWORD PTR _r$4[ebp], xmm0

; 103  : 			if (p == 3)

	jmp	SHORT $LN30@mainbase
$LN27@mainbase:
	cmp	esi, 3
	jne	SHORT $LN28@mainbase

; 104  : 				r = 0.273;

	movss	xmm0, DWORD PTR __real@3e8bc6a8
	movss	DWORD PTR _r$4[ebp], xmm0

; 105  : 			if (p == 4)

	jmp	SHORT $LN30@mainbase
$LN28@mainbase:
	cmp	esi, 4
	jne	SHORT $LN29@mainbase

; 106  : 				r = 2.225;

	movss	xmm0, DWORD PTR __real@400e6666
	movss	DWORD PTR _r$4[ebp], xmm0

; 107  : 			if (p == 5)

	jmp	SHORT $LN30@mainbase
$LN29@mainbase:
	cmp	esi, 5
	jne	SHORT $LN55@mainbase

; 108  : 				r = 7.536;

	movss	xmm0, DWORD PTR __real@40f126e9
	movss	DWORD PTR _r$4[ebp], xmm0
	jmp	SHORT $LN30@mainbase
$LN55@mainbase:

; 107  : 			if (p == 5)

	movss	xmm0, DWORD PTR _r$4[ebp]
$LN30@mainbase:

; 109  : 			score[p - 1] = 200 * (r / timetake[p - 1]);

	cvtps2pd xmm0, xmm0

; 110  : 			totalscore = totalscore + (0.2*(score[p - 1]));
; 111  : 			stagetime[p - 1] = stagetime[p - 1] + 0.2*elapsed_secs;
; 112  : 			cout << p * 4 + (q - 1) * 20 << " % complete!" << '\n';

	lea	eax, DWORD PTR [ebx+esi]
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	lea	eax, DWORD PTR [eax*4-20]
	push	eax
	divsd	xmm0, xmm2
	mulsd	xmm0, QWORD PTR __real@4069000000000000
	cvtpd2ps xmm0, xmm0
	cvtps2pd xmm1, xmm0
	movss	DWORD PTR ?score@@3PAMA[esi*4-4], xmm0
	movss	xmm0, DWORD PTR ?totalscore@@3MA
	mulsd	xmm1, QWORD PTR __real@3fc999999999999a
	cvtps2pd xmm0, xmm0
	addsd	xmm1, xmm0
	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR ?totalscore@@3MA, xmm0
	movaps	xmm0, xmm2
	mulsd	xmm0, QWORD PTR __real@3fc999999999999a
	addsd	xmm0, QWORD PTR ?stagetime@@3PANA[esi*8-8]
	movsd	QWORD PTR ?stagetime@@3PANA[esi*8-8], xmm0
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, OFFSET ??_C@_0N@FDENFJAP@?5?$CF?5complete?$CB?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 113  : 			cout << "Time taken for that stage:- " << timetake[p - 1] << '\n';

	mov	edx, OFFSET ??_C@_0BN@KEIIGMGP@Time?5taken?5for?5that?5stage?3?9?5?$AA@
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	movsd	xmm1, QWORD PTR _elapsed_secs$1$[ebp]
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 114  : 			cout << "Score obtained for that stage:- " << score[p - 1] * 5 << '\n';

	movss	xmm0, DWORD PTR ?score@@3PAMA[esi*4-4]
	mov	edx, OFFSET ??_C@_0CB@GCCJPACJ@Score?5obtained?5for?5that?5stage?3?9?5@
	mulss	xmm0, DWORD PTR __real@40a00000
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	movss	DWORD PTR tv475[ebp], xmm0
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	movss	xmm1, DWORD PTR tv475[ebp]
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	inc	esi
	cmp	esi, 5
	jle	$LL7@mainbase

; 45   : 	long count;
; 46   : 	double timetake[5];
; 47   : 	// check is meant to find out if we should also include an explaination as to why a triplet is indeed a Pythagorean one.
; 48   : 	// D will represent C for greatest pythagorean triplet purposes.
; 49   : 	// k is the number which the user will enter. This value limits the value of a and b through which the program can search.
; 50   : 	for (int q = 1; q <= 5; q++)

	add	ebx, 5
	cmp	ebx, 25					; 00000019H
	jle	$LL4@mainbase

; 115  : 		}
; 116  : 	} 
; 117  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?mainbase@@YAXXZ ENDP					; mainbase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\dm282\source\repos\benchmarker\benchmarker\benchmarker.cpp
;	COMDAT _main
_TEXT	SEGMENT
_main	PROC						; COMDAT

; 119  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi
	push	edi

; 120  : 	selection();

	call	?selection@@YAXXZ			; selection

; 121  : 	mainbase();

	call	?mainbase@@YAXXZ			; mainbase
	xor	edi, edi
$LL4@main:

; 122  : 	for (int i = 0; i < 5; i++)
; 123  : 	{
; 124  : 		cout << "Average time taken for stage " << (i + 1) << " is " << stagetime[i] << " seconds \n";

	lea	esi, DWORD PTR [edi+1]
	mov	edx, OFFSET ??_C@_0BO@NKJLBHOG@Average?5time?5taken?5for?5stage?5?$AA@
	push	esi
	push	ecx
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 4
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, OFFSET ??_C@_04HNABGNME@?5is?5?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	movsd	xmm1, QWORD PTR ?stagetime@@3PANA[edi*8]
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, OFFSET ??_C@_0L@NPJALOFP@?5seconds?5?6?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edi, esi
	cmp	edi, 5
	jl	SHORT $LL4@main

; 125  : 	}
; 126  : 	cout << "Your system has scored a total of " << totalscore << " points!" << '\n';

	mov	edx, OFFSET ??_C@_0CD@BOJLJHDN@Your?5system?5has?5scored?5a?5total?5o@
	mov	ecx, OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	movss	xmm1, DWORD PTR ?totalscore@@3MA
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	mov	edx, OFFSET ??_C@_08HNCFKHPB@?5points?$CB?$AA@
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >

; 127  : 	system("pause");

	push	OFFSET ??_C@_05PDJBBECF@pause?$AA@
	call	_system
	add	esp, 4

; 128  : }

	xor	eax, eax
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 4190 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 4191 : 		_Tidy();
; 4192 : 		}

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 4139 : 		: _Myptr(0), _Nul(0)

	xor	eax, eax
	mov	DWORD PTR [ecx], 0
	mov	WORD PTR [ecx+4], ax

; 4141 : 		}

	mov	eax, ecx
	ret	0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN4@c_str
	lea	eax, DWORD PTR [ecx+4]
$LN4@c_str:

; 4202 : 		}

	ret	0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 4190 : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Yarn

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN6@Yarn:

; 4191 : 		_Tidy();
; 4192 : 		}

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 4139 : 		: _Myptr(0), _Nul(0)

	mov	DWORD PTR [ecx], 0

; 4141 : 		}

	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	ret	0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3344 : 		return (size() == 0);

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 3345 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
$T7 = 8							; size = 1
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 3291 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp

; 3292 : 		const size_type _Old_size = size();
; 3293 : 		if (_Newsize <= _Old_size)

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	esi

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	esi, DWORD PTR [ecx+16]

; 3292 : 		const size_type _Old_size = size();
; 3293 : 		if (_Newsize <= _Old_size)

	cmp	edx, esi
	ja	SHORT $LN2@resize

; 3944 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], edx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN18@resize
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN18@resize:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3301 : 		}

	pop	ebp
	ret	8
$LN2@resize:
	push	ebx

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	ebx, DWORD PTR [ecx+20]
	mov	eax, ebx
	push	edi

; 3294 : 			{
; 3295 : 			_Eos(_Newsize);
; 3296 : 			}
; 3297 : 		else
; 3298 : 			{
; 3299 : 			append(_Newsize - _Old_size, _Ch);

	mov	edi, edx

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	sub	eax, esi

; 3294 : 			{
; 3295 : 			_Eos(_Newsize);
; 3296 : 			}
; 3297 : 		else
; 3298 : 			{
; 3299 : 			append(_Newsize - _Old_size, _Ch);

	sub	edi, esi

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	edi, eax
	ja	SHORT $LN27@resize

; 2582 : 			{
; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR [ecx+16], edx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ebx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN34@resize
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN34@resize:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2585 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	add	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	ebx
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3301 : 		}

	pop	ebp
	ret	8
$LN27@resize:

; 2590 : 		return (_Reallocate_grow_by(_Count,

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T7[ebp], 0
	push	edi
	push	DWORD PTR $T7[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
	pop	edi
	pop	ebx
	pop	esi

; 3301 : 		}

	pop	ebp
	ret	8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN14@c_str

; 3253 : 		return (this->_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 3254 : 		}

	ret	0
$LN14@c_str:

; 3253 : 		return (this->_Get_data()._Myptr());

	mov	eax, ecx

; 3254 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3180 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1787 : 		if (_Large_string_engaged())

	mov	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3184 : 		}

	add	eax, ecx
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2573 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2573 : 		{	// append [_Ptr, <null>)

	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2573 : 		{	// append [_Ptr, <null>)

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR [edi+1]
$LL25@append:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL25@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	esi, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	sub	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR [ebx+16]

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	eax, esi
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $LN8@append

; 2555 : 			{
; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+edi]
	mov	DWORD PTR [ebx+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, ebx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN15@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [ebx]
$LN15@append:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	edx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2574 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	eax, ebx
	pop	edi

; 2575 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN8@append:

; 2563 : 		return (_Reallocate_grow_by(_Count,

	push	edi
	push	edx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, ebx
	push	DWORD PTR $T5[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2575 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2519 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	eax, DWORD PTR __Right$[ebp]

; 2519 : 		{	// append _Right

	push	ebx
	push	esi
	push	edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2519 : 		{	// append _Right

	mov	edi, ecx

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	ecx, eax

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [eax]
$LN8@append:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	ebx, DWORD PTR [eax+16]

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	esi, DWORD PTR [edi+20]
	mov	eax, esi
	mov	edx, DWORD PTR [edi+16]
	sub	eax, edx
	cmp	ebx, eax
	ja	SHORT $LN15@append

; 2555 : 			{
; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ebx]
	mov	DWORD PTR [edi+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN22@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
$LN22@append:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	eax, edi
	pop	edi

; 2522 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN15@append:

; 2563 : 		return (_Reallocate_grow_by(_Count,

	push	ebx
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T5[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2522 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2441 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN37@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN36@basic_stri

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN35@basic_stri

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN36@basic_stri:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN37@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2443 : 		}

	ret	0
$LN35@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN54@basic_stri:
	int	3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2251 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2253 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
$T41 = 8						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2184 : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2664 : 		if (_Count <= _My_data._Myres)

	mov	edi, DWORD PTR __Count$[ebp]

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2664 : 		if (_Count <= _My_data._Myres)

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	edi, ecx
	ja	SHORT $LN20@basic_stri

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ebx, esi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN27@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
$LN27@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2667 : 			_My_data._Mysize = _Count;

	mov	DWORD PTR [esi+16], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2187 : 		}

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN20@basic_stri:

; 3863 : 		if (_New_size > max_size())

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN141@basic_stri

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN61@basic_stri

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN60@basic_stri
$LN61@basic_stri:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN62@basic_stri

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN60@basic_stri
$LN62@basic_stri:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN60@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@basic_stri

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN124@basic_stri

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN139@basic_stri
$LN93@basic_stri:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN94@basic_stri

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, eax
	jmp	SHORT $LN139@basic_stri
$LN94@basic_stri:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ecx, ecx
$LN139@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR $T41[ebp], ecx
	mov	DWORD PTR [esi+16], edi

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [esi+20], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	call	_memset

; 489  : 		_Left = _Right;

	mov	ebx, DWORD PTR $T41[ebp]

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	eax, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN39@basic_stri

; 3878 : 			{
; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN125@basic_stri

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN124@basic_stri

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN125@basic_stri:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN39@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2187 : 		}

	pop	edi
	mov	DWORD PTR [esi], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN124@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN141@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN138@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__New_capacity$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2166 : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2166 : 		{	// construct from [_Ptr, <null>)

	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
$LL145@basic_stri:

; 447  : 		return (_CSTD strlen(_First));

	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL145@basic_stri
	sub	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2641 : 		if (_Count <= _My_data._Myres)

	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	esi, ecx
	ja	SHORT $LN26@basic_stri

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ebx, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN33@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ebx, DWORD PTR [edi]
$LN33@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	push	edx
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2644 : 			_My_data._Mysize = _Count;

	mov	DWORD PTR [edi+16], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2169 : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN26@basic_stri:

; 3863 : 		if (_New_size > max_size())

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN149@basic_stri

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	ebx, esi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN67@basic_stri

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN147@basic_stri
$LN67@basic_stri:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN68@basic_stri

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN147@basic_stri
$LN68@basic_stri:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN147@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	mov	DWORD PTR __New_capacity$1$[ebp], ebx
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ebx, 4096				; 00001000H
	jb	SHORT $LN99@basic_stri

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ebx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	ecx, -1
	cmp	eax, ebx
	cmovbe	eax, ecx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN130@basic_stri

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN98@basic_stri
$LN99@basic_stri:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ebx, ebx
	je	SHORT $LN100@basic_stri

; 52   : 		return (::operator new(_Bytes));

	push	ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ebx, eax
	jmp	SHORT $LN98@basic_stri
$LN100@basic_stri:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ebx, ebx
$LN98@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __New_capacity$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	esi
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [edi+20], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	eax, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN45@basic_stri

; 3878 : 			{
; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN131@basic_stri

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN130@basic_stri

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN131@basic_stri:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN45@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2169 : 		}

	mov	DWORD PTR [edi], ebx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN130@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN149@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN146@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 2127 : 		}

	mov	eax, ecx

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2127 : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right_size$1$ = 8					; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2113 : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2382 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	edi, DWORD PTR __Right$[ebp]

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 1768 : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2382 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR __Right_size$1$[ebp], ecx

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN31@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN31@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2384 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN20@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	movups	xmm0, XMMWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2388 : 			_My_data._Myres = this->_BUF_SIZE - 1;

	mov	ebx, 15					; 0000000fH

; 2115 : 		}

	mov	eax, esi
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	movups	XMMWORD PTR [esi], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2115 : 		}

	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN20@basic_stri:

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, 2147483647				; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	or	ebx, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ebx, eax
	cmova	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2394 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN64@basic_stri

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN93@basic_stri

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN63@basic_stri
$LN64@basic_stri:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN65@basic_stri

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, eax
	jmp	SHORT $LN63@basic_stri
$LN65@basic_stri:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ecx, ecx
$LN63@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2396 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	mov	eax, DWORD PTR __Right_size$1$[ebp]
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [esi], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	edi
	push	ecx
	call	_memcpy
	mov	ecx, DWORD PTR __Right_size$1$[ebp]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2115 : 		}

	mov	DWORD PTR [esi+16], ecx
	mov	eax, esi
	mov	DWORD PTR [esi+20], ebx
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN93@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN91@basic_stri:
	int	3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
_TEXT	SEGMENT
$T15 = -64						; size = 8
$T13 = -64						; size = 8
__Val$1$ = -56						; size = 8
__Ok$ = -44						; size = 8
__State$ = -36						; size = 4
$T9 = -32						; size = 8
$T14 = -28						; size = 1
__Nput_fac$1$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx
; __Val$ = xmm1l

; 441  : 		{	// insert a double

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	movsd	QWORD PTR __Val$1$[ebp], xmm1
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR [esi]

; 442  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN17@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN17@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, edx
	mov	ecx, DWORD PTR [edx+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [ecx+esi+60]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN13@operator
	cmp	ecx, esi
	je	SHORT $LN13@operator

; 123  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+12]

; 339  : 		return (rdstate() == goodbit);

	test	eax, eax
	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 443  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 444  : 
; 445  : 		if (_Ok)

	jne	$LN10@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ebx, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, ebx
	mov	DWORD PTR $T9[ebp+4], ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 447  : 			const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR __Nput_fac$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	test	ebx, ebx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN47@operator

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN47@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN47@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	xmm0, QWORD PTR __Val$1$[ebp]
	sub	esp, 8
	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 449  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	QWORD PTR [esp], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 634  : 		: _Failed(false), _Strbuf(_Sb)

	mov	BYTE PTR $T13[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+64]
	mov	BYTE PTR $T14[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	push	DWORD PTR $T14[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	DWORD PTR [ecx+56]
	lea	ecx, DWORD PTR $T15[ebp]
	push	DWORD PTR $T13[ebp]
	push	ecx
	mov	ecx, edx
	call	DWORD PTR [eax+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 451  : 				_Myios::fill(), _Val).failed())

	cmp	BYTE PTR $T15[ebp], 0
	mov	eax, 4
	cmovne	edi, eax
	jmp	SHORT $LN112@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$0:

; 453  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 453  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN67@operator
	or	eax, 4
$LN67@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 453  : 			_CATCH_IO_END

	mov	eax, $LN11@operator
	ret	0
$LN11@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN112@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 454  : 			}
; 455  : 
; 456  : 		_Myios::setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN10@operator:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	edi, edi
	je	SHORT $LN80@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN80@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 7

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN99@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN99@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 8

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN110@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN110@operator:

; 457  : 		return (*this);
; 458  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
_TEXT	SEGMENT
$T15 = -56						; size = 8
$T13 = -56						; size = 8
__Ok$ = -48						; size = 8
__State$ = -40						; size = 4
$T9 = -36						; size = 8
$T14 = -32						; size = 1
__Val$1$ = -28						; size = 4
__Nput_fac$1$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx
; __Val$ = xmm1s

; 421  : 		{	// insert a float

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	movss	DWORD PTR __Val$1$[ebp], xmm1
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR [esi]

; 422  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN17@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN17@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, edx
	mov	ecx, DWORD PTR [edx+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [ecx+esi+60]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN13@operator
	cmp	ecx, esi
	je	SHORT $LN13@operator

; 123  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+12]

; 339  : 		return (rdstate() == goodbit);

	test	eax, eax
	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 423  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 424  : 
; 425  : 		if (_Ok)

	jne	$LN10@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ebx, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, ebx
	mov	DWORD PTR $T9[ebp+4], ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 427  : 			const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR __Nput_fac$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	test	ebx, ebx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN47@operator

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN47@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN47@operator:
	movss	xmm0, DWORD PTR __Val$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	sub	esp, 8
	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 429  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 431  : 				_Myios::fill(), (double)_Val).failed())

	cvtps2pd xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 634  : 		: _Failed(false), _Strbuf(_Sb)

	mov	BYTE PTR $T13[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	QWORD PTR [esp], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+64]
	mov	BYTE PTR $T14[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	push	DWORD PTR $T14[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	DWORD PTR [ecx+56]
	lea	ecx, DWORD PTR $T15[ebp]
	push	DWORD PTR $T13[ebp]
	push	ecx
	mov	ecx, edx
	call	DWORD PTR [eax+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 431  : 				_Myios::fill(), (double)_Val).failed())

	cmp	BYTE PTR $T15[ebp], 0
	mov	eax, 4
	cmovne	edi, eax
	jmp	SHORT $LN112@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$0:

; 433  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 433  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN67@operator
	or	eax, 4
$LN67@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 433  : 			_CATCH_IO_END

	mov	eax, $LN11@operator
	ret	0
$LN11@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN112@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 434  : 			}
; 435  : 
; 436  : 		_Myios::setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN10@operator:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	edi, edi
	je	SHORT $LN80@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN80@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 7

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN99@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN99@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 8

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN110@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN110@operator:

; 437  : 		return (*this);
; 438  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@M@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
$T16 = -52						; size = 8
$T14 = -52						; size = 8
__Ok$ = -44						; size = 8
__State$ = -36						; size = 4
_this$ = -32						; size = 4
$T9 = -28						; size = 8
__Nput_fac$1$ = -24					; size = 4
$T15 = -24						; size = 1
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 296  : 		{	// insert an int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR [esi]

; 297  : 		ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
	mov	DWORD PTR __State$[ebp], edi

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN19@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN19@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, edx
	mov	ecx, DWORD PTR [edx+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN15@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [ecx+esi+60]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN15@operator
	cmp	ecx, esi
	je	SHORT $LN15@operator

; 123  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN15@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+esi+12]

; 339  : 		return (rdstate() == goodbit);

	test	eax, eax
	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 298  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 299  : 
; 300  : 		if (_Ok)

	jne	$LN12@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ecx+esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ebx, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, ebx
	mov	DWORD PTR $T9[ebp+4], ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 302  : 			const _Nput& _Nput_fac = _STD use_facet<_Nput>(this->getloc());

	lea	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	push	eax
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR __Nput_fac$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+12], 4
	test	ebx, ebx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN49@operator

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN115@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN115@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	edx, DWORD PTR __Nput_fac$1$[ebp]
$LN49@operator:
	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1294 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 309  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	lea	ecx, DWORD PTR [eax+esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 634  : 		: _Failed(false), _Strbuf(_Sb)

	mov	BYTE PTR $T14[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+64]
	mov	BYTE PTR $T15[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1294 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	push	DWORD PTR $T15[ebp]
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	DWORD PTR [ecx+56]
	lea	ecx, DWORD PTR $T16[ebp]
	push	DWORD PTR $T14[ebp]
	push	ecx
	mov	ecx, edx
	call	DWORD PTR [eax+36]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 311  : 				_Myios::fill(), _Tmp).failed())

	cmp	BYTE PTR $T16[ebp], 0
	mov	eax, 4
	cmovne	edi, eax
	jmp	SHORT $LN117@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0:

; 313  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 313  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN71@operator
	or	eax, 4
$LN71@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 313  : 			_CATCH_IO_END

	mov	eax, $LN13@operator
	ret	0
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN117@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 314  : 			}
; 315  : 
; 316  : 		_Myios::setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN12@operator:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	edi, edi
	je	SHORT $LN84@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN84@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 7

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN103@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN103@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 8

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN114@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN114@operator:

; 317  : 		return (*this);
; 318  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
$T8 = -124						; size = 52
$T32 = -72						; size = 8
$T5 = -72						; size = 8
__Ok$ = -64						; size = 8
__Lock$39 = -56						; size = 4
$T29 = -52						; size = 8
__Psave$1$ = -48					; size = 4
$T7 = -48						; size = 4
__Psave_guard$40 = -48					; size = 4
tv179 = -44						; size = 4
__Tmp$41 = -40						; size = 4
_this$ = -36						; size = 4
$T31 = -32						; size = 8
__Id$1$ = -28						; size = 4
__Lock$42 = -28						; size = 4
__State$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z PROC ; std::basic_istream<char,std::char_traits<char> >::operator>>, COMDAT
; _this$ = ecx

; 283  : 		{	// extract an int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 284  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
	mov	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 283  : 		{	// extract an int

	mov	DWORD PTR tv179[ebp], esi

; 92   : 			: _Myistr(_Istr)

	mov	DWORD PTR __Ok$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN18@operator

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN18@operator:

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	ecx
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR __Ok$[ebp+4], al

; 285  : 		const sentry _Ok(*this);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 286  : 
; 287  : 		if (_Ok)

	test	al, al
	je	$LN190@operator

; 290  : 			const _Nget& _Nget_fac = _STD use_facet<_Nget>(this->getloc());

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$41[ebp], 0
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [eax+edi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	esi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T5[ebp+4], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$39[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 290  : 			const _Nget& _Nget_fac = _STD use_facet<_Nget>(this->getloc());

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	BYTE PTR __$EHRec$[ebp+12], 4

; 116  : 			if (_Id == 0)

	mov	ecx, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id

; 504  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$1$[ebp], eax

; 116  : 			if (_Id == 0)

	mov	DWORD PTR __Id$1$[ebp], ecx
	test	ecx, ecx
	jne	SHORT $LN42@operator

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	ecx
	lea	ecx, DWORD PTR __Lock$42[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, 0 ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN43@operator

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN43@operator:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$42[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	ecx, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	mov	DWORD PTR __Id$1$[ebp], ecx
$LN42@operator:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	cmp	ecx, DWORD PTR [esi+12]
	jae	SHORT $LN51@operator
	mov	eax, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	ebx, ebx
	jne	$LN121@operator
	jmp	SHORT $LN187@operator
$LN51@operator:

; 407  : 		}
; 408  : 
; 409  : 	locale& operator=(const locale& _Right) _NOEXCEPT
; 410  : 		{	// assign a locale
; 411  : 		if (_Ptr != _Right._Ptr)
; 412  : 			{	// different implementation, point at new one
; 413  : 			delete _Ptr->_Decref();
; 414  : 			_Ptr = _Right._Ptr;
; 415  : 			_Ptr->_Incref();
; 416  : 			}
; 417  : 		return (*this);
; 418  : 		}
; 419  : 
; 420  : 	string name() const
; 421  : 		{	// return locale name
; 422  : 		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
; 423  : 		}
; 424  : 
; 425  : 	_Ret_z_ const char *c_str() const
; 426  : 		{	// return locale name as NTBS
; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
; 428  : 		}
; 429  : 
; 430  : 	const facet *_Getfacet(size_t _Id) const
; 431  : 		{	// look up a facet in locale object
; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	ebx, ebx
$LN187@operator:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [esi+20], 0
	je	SHORT $LN48@operator

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	mov	ebx, DWORD PTR __Id$1$[ebp]
	cmp	ebx, DWORD PTR [eax+12]
	jae	SHORT $LN188@operator
	mov	eax, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+ebx*4]
$LN48@operator:

; 509  : 		if (_Pf != 0)

	test	ebx, ebx
	jne	SHORT $LN121@operator
$LN188@operator:

; 510  : 			;	// got facet from locale
; 511  : 		else if (_Psave != 0)

	mov	eax, DWORD PTR __Psave$1$[ebp]
	test	eax, eax
	je	SHORT $LN34@operator

; 512  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	ebx, eax

; 513  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	jmp	SHORT $LN121@operator
$LN34@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	jne	SHORT $LN71@operator
	lea	eax, DWORD PTR [esi+28]
$LN71@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	lea	ecx, DWORD PTR $T8[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [ebx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 348  : 		{	// construct from specified locale

	mov	DWORD PTR [ebx], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$40[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 529  : 			_Facet_Register(_Pfmod);

	push	ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 6
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 530  :  #endif /* defined(_M_CEE) */
; 531  : 
; 532  : 			_Pfmod->_Incref();

	mov	eax, DWORD PTR [ebx]
	add	esp, 4
	mov	ecx, ebx
	call	DWORD PTR [eax+4]

; 533  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, ebx ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN121@operator:

; 534  : 			_Pf = _Psave;
; 535  : 
; 536  : 			(void) _Psave_guard.release();
; 537  : 			}
; 538  : 
; 539  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$39[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+12], 7

; 405  : 		if (_Ptr != 0)
; 406  : 			delete _Ptr->_Decref();

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	test	eax, eax
	je	SHORT $LN127@operator
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN127@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 292  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	lea	ecx, DWORD PTR __Tmp$41[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	mov	edx, DWORD PTR [ebx]
	push	ecx
	lea	ecx, DWORD PTR __State$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 501  : 		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()

	mov	WORD PTR $T29[ebp+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 501  : 		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()

	mov	BYTE PTR $T31[ebp+5], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	eax
	push	DWORD PTR $T29[ebp+4]
	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	esi, DWORD PTR [eax+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 501  : 		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()

	test	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 501  : 		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()

	sete	BYTE PTR $T31[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	lea	eax, DWORD PTR $T32[ebp]
	push	DWORD PTR $T31[ebp+4]
	push	esi
	push	eax
	call	DWORD PTR [edx+40]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
	jmp	SHORT $LN193@operator
__catch$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$0:

; 295  : 			_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 295  : 			_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN145@operator
	or	eax, 4
$LN145@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 295  : 			_CATCH_IO_END

	mov	eax, $LN13@operator
	ret	0
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	edi, DWORD PTR _this$[ebp]
$LN193@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 296  : 
; 297  : 			if (_State & ios_base::failbit
; 298  : 				|| _Tmp < INT_MIN || INT_MAX < _Tmp)

	mov	esi, DWORD PTR tv179[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	ebx, DWORD PTR __State$[ebp]
	test	bl, 2
	jne	SHORT $LN6@operator

; 300  : 			else
; 301  : 				_Val = _Tmp;

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Tmp$41[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN5@operator
$LN6@operator:

; 299  : 				_State |= ios_base::failbit;

	or	ebx, 2
	mov	DWORD PTR __State$[ebp], ebx
	jmp	SHORT $LN5@operator
$LN190@operator:

; 286  : 
; 287  : 		if (_Ok)

	mov	ebx, DWORD PTR __State$[ebp]
$LN5@operator:

; 302  : 			}
; 303  : 
; 304  : 		_Myios::setstate(_State);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	ebx, ebx
	je	SHORT $LN158@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
	mov	eax, DWORD PTR [esi]
$LN158@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 99   : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN189@operator

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN189@operator:

; 305  : 		return (*this);
; 306  : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$4:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$3:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$6:
	lea	ecx, DWORD PTR __Lock$39[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$9:
	push	8
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z$7:
	lea	ecx, DWORD PTR __Psave_guard$40[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::operator>>
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 99   : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN4@sentry:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 121  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 122  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$dead$ = 12					; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 115  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 92   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:

; 96   : 			}
; 97   : 
; 98   : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 99   : 			{	// destroy after unlocking
; 100  : 			if (_Myistr.rdbuf() != 0)
; 101  : 				_Myistr.rdbuf()->_Unlock();
; 102  : 			}
; 103  : 
; 104  : 		basic_istream& _Myistr;	// the input stream, for _Unlock call at destruction
; 105  : 
; 106  : 		_Sentry_base& operator=(const _Sentry_base&) = delete;
; 107  : 		};
; 108  : 
; 109  : 	class sentry
; 110  : 		: public _Sentry_base
; 111  : 		{	// stores thread lock and result of _Ipfx call
; 112  : 	public:
; 113  : 		explicit __CLR_OR_THIS_CALL sentry(basic_istream& _Istr, bool _Noskip = false)
; 114  : 			: _Sentry_base(_Istr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
	mov	BYTE PTR [esi+4], al

; 117  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 100  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 102  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
_TEXT	SEGMENT
__Ans$ = -76						; size = 8
__Val$GSCopy$1$ = -68					; size = 4
__Ep$ = -64						; size = 4
$T1 = -60						; size = 8
__Ans$1$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 678  : 		{	// get void pointer from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR __Iosbase$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 681  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [eax+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 683  : 		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	push	2048					; 00000800H
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	esi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN18@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN18@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 686  : 			(sizeof (void *) == sizeof (unsigned long))

	lea	eax, DWORD PTR __Errno$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 686  : 			(sizeof (void *) == sizeof (unsigned long))

	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 686  : 			(sizeof (void *) == sizeof (unsigned long))

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 686  : 			(sizeof (void *) == sizeof (unsigned long))

	mov	DWORD PTR __Ans$1$[ebp], eax
	mov	DWORD PTR __Ans$[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN24@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN34@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN39@do_get
$LN38@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN39@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN34@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN33@do_get
$LN34@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN33@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN24@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN56@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN57@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN61@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN61@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN62@do_get
$LN61@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN62@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN56@do_get
$LN57@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN56@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN78@do_get
	test	edx, edx
	je	SHORT $LN79@do_get
	jmp	SHORT $LN77@do_get
$LN78@do_get:
	test	edx, edx
	je	SHORT $LN77@do_get
$LN79@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 691  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [edi], 1
$LN77@do_get:

; 692  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 694  : 		else
; 695  : 			_Val = (void *)((char *)0 + _Ans);	// deliver value

	mov	edx, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	eax, DWORD PTR __Ans$1$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 693  : 			_State |= ios_base::failbit;

	or	DWORD PTR [edi], 2
$LN4@do_get:

; 696  : 		return (_First);

	mov	DWORD PTR [ebx], ecx
	mov	eax, ebx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [ebx+4], ecx

; 697  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAPAX@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z
_TEXT	SEGMENT
__Hexexp$ = -836					; size = 4
__Ans$1$ = -832						; size = 8
__Pten$1$ = -832					; size = 4
__Val$11 = -824						; size = 8
__Ans$ = -824						; size = 8
__Ep$ = -816						; size = 4
__Errno$1$ = -812					; size = 4
__Val$GSCopy$1$ = -808					; size = 4
___$ReturnUdt$GSCopy$1$ = -804				; size = 4
__Ac$ = -800						; size = 792
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 652  : 		{	// get long double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 884				; 00000374H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+884], eax
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __State$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[esp+896], edx

; 653  : 		_DEBUG_RANGE(_First, _Last);
; 654  : 		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
; 655  : 		int _Errno = 0;
; 656  : 		int _Hexexp = _ENABLE_V2_BEHAVIOR;
; 657  : 		long double _Ans = _Stodx_v2(_Ac, &_Ep,

	lea	edx, DWORD PTR __Hexexp$[esp+896]
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[esp+904], 1000000000 ; 3b9aca00H
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+912]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	mov	DWORD PTR __Pten$1$[esp+920], eax

; 56   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno
	mov	edi, eax

; 57   : 	const int _Orig = _Errno_ref;
; 58   : 
; 59   : 	_Errno_ref = 0;
; 60   : 	double _Val = _CSTD strtod(_Str, _Endptr);

	lea	eax, DWORD PTR __Ep$[esp+920]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+924]
	push	eax
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], 0
	call	_strtod

; 61   : 	*_Perr = _Errno_ref;

	mov	eax, DWORD PTR [edi]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Errno$1$[esp+896], eax

; 62   : 	_Errno_ref = _Orig;
; 63   : 
; 64   : 	if (_Pten != 0)

	mov	eax, DWORD PTR __Pten$1$[esp+896]
	mov	DWORD PTR [edi], esi
	fstp	QWORD PTR __Val$11[esp+896]
	test	eax, eax
	je	SHORT $LN72@do_get

; 65   : 		_Val *= _CSTD pow(10.0, static_cast<double>(_Pten));

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __Val$11[esp+896]
	jmp	SHORT $LN75@do_get
$LN72@do_get:

; 62   : 	_Errno_ref = _Orig;
; 63   : 
; 64   : 	if (_Pten != 0)

	movsd	xmm0, QWORD PTR __Val$11[esp+896]
$LN75@do_get:

; 658  : 			_Getffld(_Ac, _First, _Last,
; 659  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert, "widen" double to long double
; 660  : 
; 661  : 		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[esp+896]
	movsd	QWORD PTR __Ans$1$[esp+896], xmm0
	cmp	eax, 1000000000				; 3b9aca00H
	je	SHORT $LN2@do_get
	test	eax, eax
	je	SHORT $LN2@do_get

; 662  : 			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

	shl	eax, 2
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 881  :         return ldexp((double)_X, _Y);

	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 662  : 			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

	fstp	QWORD PTR __Ans$[esp+908]
	movsd	xmm0, QWORD PTR __Ans$[esp+908]
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 881  :         return ldexp((double)_X, _Y);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 662  : 			_Ans = _CSTD ldexpl(_Ans, 4 * _Hexexp);

	movsd	QWORD PTR __Ans$1$[esp+896], xmm0
$LN2@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN16@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN26@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN30@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN30@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN31@do_get
$LN30@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN31@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN26@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN25@do_get
$LN26@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN25@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN16@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN48@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN49@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN53@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN53@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN54@do_get
$LN53@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN54@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN48@do_get
$LN49@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN48@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN70@do_get
	test	edx, edx
	je	SHORT $LN71@do_get
	jmp	SHORT $LN69@do_get
$LN70@do_get:
	test	edx, edx
	je	SHORT $LN69@do_get
$LN71@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 665  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN69@do_get:

; 666  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+896]
	cmp	DWORD PTR __Ep$[esp+896], eax
	je	SHORT $LN6@do_get
	cmp	DWORD PTR __Errno$1$[esp+896], 0
	jne	SHORT $LN6@do_get

; 668  : 		else
; 669  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[esp+896]
	movsd	xmm0, QWORD PTR __Ans$1$[esp+896]
	movsd	QWORD PTR [eax], xmm0
	jmp	SHORT $LN5@do_get
$LN6@do_get:

; 667  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN5@do_get:

; 670  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896]

; 671  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+884]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAO@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z
_TEXT	SEGMENT
__Hexexp$ = -836					; size = 4
__Ans$1$ = -832						; size = 8
__Pten$1$ = -832					; size = 4
__Val$11 = -824						; size = 8
__Ans$ = -824						; size = 8
__Ep$ = -816						; size = 4
__Errno$1$ = -812					; size = 4
__Val$GSCopy$1$ = -808					; size = 4
___$ReturnUdt$GSCopy$1$ = -804				; size = 4
__Ac$ = -800						; size = 792
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 628  : 		{	// get double from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 884				; 00000374H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+884], eax
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __State$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[esp+896], edx

; 629  : 		_DEBUG_RANGE(_First, _Last);
; 630  : 		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
; 631  : 		int _Errno = 0;
; 632  : 		int _Hexexp = _ENABLE_V2_BEHAVIOR;
; 633  : 		double _Ans = _Stodx_v2(_Ac, &_Ep,

	lea	edx, DWORD PTR __Hexexp$[esp+896]
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[esp+904], 1000000000 ; 3b9aca00H
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+912]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	mov	DWORD PTR __Pten$1$[esp+920], eax

; 56   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno
	mov	edi, eax

; 57   : 	const int _Orig = _Errno_ref;
; 58   : 
; 59   : 	_Errno_ref = 0;
; 60   : 	double _Val = _CSTD strtod(_Str, _Endptr);

	lea	eax, DWORD PTR __Ep$[esp+920]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+924]
	push	eax
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], 0
	call	_strtod

; 61   : 	*_Perr = _Errno_ref;

	mov	eax, DWORD PTR [edi]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Errno$1$[esp+896], eax

; 62   : 	_Errno_ref = _Orig;
; 63   : 
; 64   : 	if (_Pten != 0)

	mov	eax, DWORD PTR __Pten$1$[esp+896]
	mov	DWORD PTR [edi], esi
	fstp	QWORD PTR __Val$11[esp+896]
	test	eax, eax
	je	SHORT $LN70@do_get

; 65   : 		_Val *= _CSTD pow(10.0, static_cast<double>(_Pten));

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	mulsd	xmm0, QWORD PTR __Val$11[esp+896]
	jmp	SHORT $LN73@do_get
$LN70@do_get:

; 62   : 	_Errno_ref = _Orig;
; 63   : 
; 64   : 	if (_Pten != 0)

	movsd	xmm0, QWORD PTR __Val$11[esp+896]
$LN73@do_get:

; 634  : 			_Getffld(_Ac, _First, _Last,
; 635  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert
; 636  : 
; 637  : 		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[esp+896]
	movsd	QWORD PTR __Ans$1$[esp+896], xmm0
	cmp	eax, 1000000000				; 3b9aca00H
	je	SHORT $LN2@do_get
	test	eax, eax
	je	SHORT $LN2@do_get

; 638  : 			_Ans = _CSTD ldexp(_Ans, 4 * _Hexexp);

	shl	eax, 2
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
	fstp	QWORD PTR __Ans$[esp+908]
	movsd	xmm0, QWORD PTR __Ans$[esp+908]
	add	esp, 12					; 0000000cH
	movsd	QWORD PTR __Ans$1$[esp+896], xmm0
$LN2@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN14@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN24@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN28@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN28@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN29@do_get
$LN28@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN29@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN24@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN23@do_get
$LN24@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN23@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN14@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN46@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN47@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN51@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN51@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN52@do_get
$LN51@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN52@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN46@do_get
$LN47@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN46@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN68@do_get
	test	edx, edx
	je	SHORT $LN69@do_get
	jmp	SHORT $LN67@do_get
$LN68@do_get:
	test	edx, edx
	je	SHORT $LN67@do_get
$LN69@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 641  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN67@do_get:

; 642  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+896]
	cmp	DWORD PTR __Ep$[esp+896], eax
	je	SHORT $LN6@do_get
	cmp	DWORD PTR __Errno$1$[esp+896], 0
	jne	SHORT $LN6@do_get

; 644  : 		else
; 645  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[esp+896]
	movsd	xmm0, QWORD PTR __Ans$1$[esp+896]
	movsd	QWORD PTR [eax], xmm0
	jmp	SHORT $LN5@do_get
$LN6@do_get:

; 643  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN5@do_get:

; 646  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896]

; 647  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+884]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAN@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z
_TEXT	SEGMENT
__Ans$1$ = -828						; size = 4
__Val$11 = -828						; size = 4
__Pten$1$ = -824					; size = 4
__Ans$ = -824						; size = 4
__Hexexp$ = -820					; size = 4
__Ep$ = -816						; size = 4
__Errno$1$ = -812					; size = 4
__Val$GSCopy$1$ = -808					; size = 4
___$ReturnUdt$GSCopy$1$ = -804				; size = 4
__Ac$ = -800						; size = 792
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 604  : 		{	// get float from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 884				; 00000374H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+884], eax
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __State$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896], eax
	mov	eax, DWORD PTR __Iosbase$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[esp+896], edx

; 605  : 		_DEBUG_RANGE(_First, _Last);
; 606  : 		char _Ac[_FLOATING_BUFFER_SIZE], *_Ep;
; 607  : 		int _Errno = 0;
; 608  : 		int _Hexexp = _ENABLE_V2_BEHAVIOR;
; 609  : 		float _Ans = _Stofx_v2(_Ac, &_Ep,

	lea	edx, DWORD PTR __Hexexp$[esp+896]
	push	edx
	push	eax
	lea	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Hexexp$[esp+904], 1000000000 ; 3b9aca00H
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+912]
	push	eax
	push	ecx
	call	?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
	mov	DWORD PTR __Pten$1$[esp+920], eax

; 73   : 	int& _Errno_ref = errno;	// Nonzero cost, pay it once

	call	__errno
	mov	edi, eax

; 74   : 	const int _Orig = _Errno_ref;
; 75   : 
; 76   : 	_Errno_ref = 0;
; 77   : 	float _Val = _CSTD strtof(_Str, _Endptr);

	lea	eax, DWORD PTR __Ep$[esp+920]
	push	eax
	lea	eax, DWORD PTR __Ac$[esp+924]
	push	eax
	mov	esi, DWORD PTR [edi]
	mov	DWORD PTR [edi], 0
	call	_strtof

; 78   : 	*_Perr = _Errno_ref;

	mov	eax, DWORD PTR [edi]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Errno$1$[esp+896], eax

; 79   : 	_Errno_ref = _Orig;
; 80   : 
; 81   : 	if (_Pten != 0)

	mov	eax, DWORD PTR __Pten$1$[esp+896]
	mov	DWORD PTR [edi], esi
	fstp	DWORD PTR __Val$11[esp+896]
	test	eax, eax
	je	SHORT $LN74@do_get
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 745  :             return (float)pow(_X, _Y);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 82   : 		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	cvtdq2ps xmm1, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 745  :             return (float)pow(_X, _Y);

	cvtps2pd xmm1, xmm1
	call	__libm_sse2_pow_precise
	cvtsd2ss xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 82   : 		_Val *= _CSTD powf(10.0f, static_cast<float>(_Pten));

	mulss	xmm0, DWORD PTR __Val$11[esp+896]
	jmp	SHORT $LN77@do_get
$LN74@do_get:

; 79   : 	_Errno_ref = _Orig;
; 80   : 
; 81   : 	if (_Pten != 0)

	movss	xmm0, DWORD PTR __Val$11[esp+896]
$LN77@do_get:

; 610  : 			_Getffld(_Ac, _First, _Last,
; 611  : 				_Iosbase, &_Hexexp), &_Errno);	// gather field, convert
; 612  : 
; 613  : 		if (_Hexexp != _ENABLE_V2_BEHAVIOR && _Hexexp != 0)

	mov	eax, DWORD PTR __Hexexp$[esp+896]
	movss	DWORD PTR __Ans$1$[esp+896], xmm0
	cmp	eax, 1000000000				; 3b9aca00H
	je	SHORT $LN2@do_get
	test	eax, eax
	je	SHORT $LN2@do_get

; 614  : 			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

	shl	eax, 2
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 708  :         return (float)ldexp(_X, _Y);

	push	eax
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_ldexp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 614  : 			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

	fstp	DWORD PTR __Ans$[esp+908]
	movss	xmm0, DWORD PTR __Ans$[esp+908]
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 708  :         return (float)ldexp(_X, _Y);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 614  : 			_Ans = _CSTD ldexpf(_Ans, 4 * _Hexexp);

	movss	DWORD PTR __Ans$1$[esp+896], xmm0
$LN2@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN18@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN28@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN32@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN32@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN33@do_get
$LN32@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN33@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN28@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN27@do_get
$LN28@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN27@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN18@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN50@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN51@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN55@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN55@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN56@do_get
$LN55@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN56@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN50@do_get
$LN51@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN50@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN72@do_get
	test	edx, edx
	je	SHORT $LN73@do_get
	jmp	SHORT $LN71@do_get
$LN72@do_get:
	test	edx, edx
	je	SHORT $LN71@do_get
$LN73@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 617  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN71@do_get:

; 618  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[esp+896]
	cmp	DWORD PTR __Ep$[esp+896], eax
	je	SHORT $LN6@do_get
	cmp	DWORD PTR __Errno$1$[esp+896], 0
	jne	SHORT $LN6@do_get

; 620  : 		else
; 621  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[esp+896]
	movss	xmm0, DWORD PTR __Ans$1$[esp+896]
	movss	DWORD PTR [eax], xmm0
	jmp	SHORT $LN5@do_get
$LN6@do_get:

; 619  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN5@do_get:

; 622  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[esp+896]

; 623  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+884]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAM@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
_TEXT	SEGMENT
$T1 = -76						; size = 8
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Ans$1$ = -64						; size = 4
__Val$GSCopy$1$ = -60					; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 578  : 		{	// get unsigned long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 581  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 582  : 		const unsigned long long _Ans = _CSTD _Stoullx(_Ac, &_Ep,

	lea	eax, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoullx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ans$1$[ebp], edx
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN18@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN18@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN24@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN34@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN39@do_get
$LN38@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN39@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN34@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN33@do_get
$LN34@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN33@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN24@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN56@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN57@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN61@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN61@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN62@do_get
$LN61@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN62@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN56@do_get
$LN57@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN56@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN78@do_get
	test	edx, edx
	je	SHORT $LN79@do_get
	jmp	SHORT $LN77@do_get
$LN78@do_get:
	test	edx, edx
	je	SHORT $LN77@do_get
$LN79@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 587  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN77@do_get:

; 588  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 590  : 		else
; 591  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	edx, DWORD PTR __Ans$1$[ebp]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 589  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 592  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 593  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_K@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
_TEXT	SEGMENT
$T1 = -76						; size = 8
___$ReturnUdt$GSCopy$1$ = -68				; size = 4
__Ans$1$ = -64						; size = 4
__Val$GSCopy$1$ = -60					; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 558  : 		{	// get long long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 561  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 562  : 		const long long _Ans = _CSTD _Stollx(_Ac, &_Ep,

	lea	eax, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stollx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Ans$1$[ebp], edx
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN18@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN18@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN24@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN34@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN39@do_get
$LN38@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN39@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN34@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN33@do_get
$LN34@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN33@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN24@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN56@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN57@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN61@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN61@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN62@do_get
$LN61@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN62@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN56@do_get
$LN57@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN56@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN78@do_get
	test	edx, edx
	je	SHORT $LN79@do_get
	jmp	SHORT $LN77@do_get
$LN78@do_get:
	test	edx, edx
	je	SHORT $LN77@do_get
$LN79@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 567  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN77@do_get:

; 568  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 570  : 		else
; 571  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	edx, DWORD PTR __Ans$1$[ebp]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 569  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 572  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 573  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_J@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
_TEXT	SEGMENT
$T1 = -72						; size = 8
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
__Val$GSCopy$1$ = -60					; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 538  : 		{	// get unsigned long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 541  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 542  : 		const unsigned long _Ans = _CSTD _Stoulx(_Ac, &_Ep,

	lea	eax, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN18@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN18@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN24@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN34@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN39@do_get
$LN38@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN39@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN34@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN33@do_get
$LN34@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN33@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN24@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN56@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN57@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN61@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN61@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN62@do_get
$LN61@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN62@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN56@do_get
$LN57@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN56@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN78@do_get
	test	edx, edx
	je	SHORT $LN79@do_get
	jmp	SHORT $LN77@do_get
$LN78@do_get:
	test	edx, edx
	je	SHORT $LN77@do_get
$LN79@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 547  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN77@do_get:

; 548  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 550  : 		else
; 551  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 549  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 552  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 553  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAK@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
$T1 = -72						; size = 8
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
__Val$GSCopy$1$ = -60					; size = 4
__Ep$ = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 518  : 		{	// get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 521  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 522  : 		const long _Ans = _CSTD _Stolx(_Ac, &_Ep,

	lea	eax, DWORD PTR __Errno$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	call	__Stolx
	add	esp, 16					; 00000010H
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN18@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN18@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN18@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	jne	SHORT $LN24@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN34@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN38@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN38@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN39@do_get
$LN38@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN39@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN34@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN33@do_get
$LN34@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN33@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN24@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN56@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN57@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN61@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN61@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN62@do_get
$LN61@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN62@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN56@do_get
$LN57@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN56@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN78@do_get
	test	edx, edx
	je	SHORT $LN79@do_get
	jmp	SHORT $LN77@do_get
$LN78@do_get:
	test	edx, edx
	je	SHORT $LN77@do_get
$LN79@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 527  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN77@do_get:

; 528  : 		if (_Ep == _Ac || _Errno != 0)

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	DWORD PTR __Ep$[ebp], eax
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 530  : 		else
; 531  : 			_Val = _Ans;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 529  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 532  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 533  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -72				; size = 4
__Val$GSCopy$1$ = -68					; size = 4
__Ep$ = -64						; size = 4
$T1 = -60						; size = 8
tv543 = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 496  : 		{	// get unsigned int from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 499  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 500  : 		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN22@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN22@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 502  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	lea	edi, DWORD PTR __Ac$[ebp+1]
	cmovne	edi, eax

; 504  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	lea	eax, DWORD PTR __Errno$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	push	edi
	call	__Stoulx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 504  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 504  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN28@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN38@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN42@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN42@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN43@do_get
$LN42@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN43@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN38@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN37@do_get
$LN38@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN37@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN28@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN60@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN61@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv543[ebp], eax
	test	eax, eax
	je	SHORT $LN65@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN65@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	mov	eax, DWORD PTR tv543[ebp]
	movzx	eax, BYTE PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN66@do_get
$LN65@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN66@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN60@do_get
$LN61@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN60@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN82@do_get
	test	edx, edx
	je	SHORT $LN83@do_get
	jmp	SHORT $LN81@do_get
$LN82@do_get:
	test	edx, edx
	je	SHORT $LN81@do_get
$LN83@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 507  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN81@do_get:

; 508  : 		if (_Ep == _Ptr || _Errno != 0 || UINT_MAX < _Ans)

	cmp	DWORD PTR __Ep$[ebp], edi
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get

; 510  : 		else
; 511  : 			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	// deliver value

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	jne	SHORT $LN9@do_get
	neg	esi
$LN9@do_get:
	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 509  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 512  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 513  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -72				; size = 4
__Val$GSCopy$1$ = -68					; size = 4
__Ep$ = -64						; size = 4
$T1 = -60						; size = 8
tv547 = -56						; size = 4
__Errno$ = -52						; size = 4
__Ac$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 473  : 		{	// get unsigned short from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esi, DWORD PTR __Iosbase$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 476  : 		int _Errno = 0;

	mov	DWORD PTR __Errno$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 477  : 		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),

	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	push	DWORD PTR [esi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$[ebp]
	push	eax
	push	edi
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T1[ebp+4]
	test	ecx, ecx
	je	SHORT $LN22@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN22@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@do_get:

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 479  : 		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	// point past any sign

	lea	eax, DWORD PTR __Ac$[ebp]
	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	lea	edi, DWORD PTR __Ac$[ebp+1]
	cmovne	edi, eax

; 481  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	lea	eax, DWORD PTR __Errno$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR __Ep$[ebp]
	push	eax
	push	edi
	call	__Stoulx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 481  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 481  : 			_CSTD _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	// convert

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN28@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN38@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN42@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN42@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN43@do_get
$LN42@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __First$[ebp]
$LN43@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN38@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN37@do_get
$LN38@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
	mov	DWORD PTR __First$[ebp], ecx
$LN37@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN28@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN60@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN61@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv547[ebp], eax
	test	eax, eax
	je	SHORT $LN65@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN65@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	mov	eax, DWORD PTR tv547[ebp]
	movzx	eax, BYTE PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN66@do_get
$LN65@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
$LN66@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN60@do_get
$LN61@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
$LN60@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	ecx, ecx
	jne	SHORT $LN82@do_get
	test	edx, edx
	je	SHORT $LN83@do_get
	jmp	SHORT $LN81@do_get
$LN82@do_get:
	test	edx, edx
	je	SHORT $LN81@do_get
$LN83@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 484  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN81@do_get:

; 485  : 		if (_Ep == _Ptr || _Errno != 0 || USHRT_MAX < _Ans)

	cmp	DWORD PTR __Ep$[ebp], edi
	je	SHORT $LN5@do_get
	cmp	DWORD PTR __Errno$[ebp], 0
	jne	SHORT $LN5@do_get
	cmp	esi, 65535				; 0000ffffH
	ja	SHORT $LN5@do_get

; 487  : 		else
; 488  : 			_Val = (unsigned short)(_Ac[0] == '-'

	cmp	BYTE PTR __Ac$[ebp], 45			; 0000002dH
	jne	SHORT $LN9@do_get
	neg	esi
$LN9@do_get:
	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	mov	WORD PTR [eax], si
	jmp	SHORT $LN4@do_get
$LN5@do_get:

; 486  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2
$LN4@do_get:

; 489  : 				? 0 -_Ans : _Ans);	// deliver value
; 490  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 491  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAG@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -124				; size = 4
__Val$GSCopy$1$ = -120					; size = 4
__Ep$56 = -116						; size = 4
_this$GSCopy$1$ = -112					; size = 4
$T41 = -108						; size = 8
$T3 = -108						; size = 8
__Punct_fac$1$ = -100					; size = 4
$T25 = -100						; size = 1
$T12 = -100						; size = 1
__Errno$57 = -100					; size = 4
$T19 = -96						; size = 24
$T6 = -96						; size = 24
__Str$58 = -72						; size = 24
__Ac$59 = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Iosbase$ = 28						; size = 4
__State$ = 32						; size = 4
__Val$ = 36						; size = 4
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get, COMDAT
; _this$ = ecx

; 436  : 		{	// get bool from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	edi, DWORD PTR __Iosbase$[ebp]

; 437  : 		_DEBUG_RANGE(_First, _Last);
; 438  : 		int _Ans = -1;	// negative answer indicates failure

	or	esi, -1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ebx, DWORD PTR __State$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax

; 439  : 
; 440  : 		if (_Iosbase.flags() & ios_base::boolalpha)

	test	DWORD PTR [edi+20], 16384		; 00004000H
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edi+48]
	mov	DWORD PTR __Val$GSCopy$1$[ebp], eax
	je	$LN2@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	esi, DWORD PTR [ecx+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T3[ebp+4], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 443  : 			const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	esi, esi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN24@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN24@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN24@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 444  : 			_Mystr _Str((_Mystrsize)1, (char_type)0);

	push	0
	push	1
	lea	ecx, DWORD PTR __Str$58[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 444  : 			_Mystr _Str((_Mystrsize)1, (char_type)0);

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 139  : 		return (do_falsename());

	lea	ecx, DWORD PTR $T6[ebp]
	mov	esi, DWORD PTR __Punct_fac$1$[ebp]
	push	ecx
	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+24]

; 445  : 			_Str += _Punct_fac.falsename();

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ecx, DWORD PTR $T6[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR $T6[ebp+20], 16		; 00000010H

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, DWORD PTR __Str$58[ebp+20]

; 1798 : 		if (_Large_string_engaged())

	cmovae	ecx, DWORD PTR $T6[ebp]

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	edi, DWORD PTR $T6[ebp+16]

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR __Str$58[ebp+16]
	sub	eax, edx

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	push	edi
	push	ecx
	cmp	edi, eax
	ja	SHORT $LN47@do_get

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$58[ebp+20], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Str$58[ebp]

; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+edi]

; 1787 : 		if (_Large_string_engaged())

	cmovae	esi, DWORD PTR __Str$58[ebp]

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	esi, edx
	mov	DWORD PTR __Str$58[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	call	_memmove

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2560 : 			return (*this);

	mov	esi, DWORD PTR __Punct_fac$1$[ebp]
	jmp	SHORT $LN46@do_get
$LN47@do_get:

; 2561 : 			}
; 2562 : 
; 2563 : 		return (_Reallocate_grow_by(_Count,

	mov	BYTE PTR $T12[ebp], 0
	lea	ecx, DWORD PTR __Str$58[ebp]
	push	DWORD PTR $T12[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN46@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 445  : 			_Str += _Punct_fac.falsename();

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T6[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN101@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN100@do_get

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN357@do_get
$LN100@do_get:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN101@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2514 : 		push_back(_Ch);

	push	0
	lea	ecx, DWORD PTR __Str$58[ebp]
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 144  : 		return (do_truename());

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR $T19[ebp]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+28]

; 447  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ecx, DWORD PTR $T19[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR $T19[ebp+20], 16		; 00000010H

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	esi, DWORD PTR __Str$58[ebp+20]
	mov	eax, esi

; 1798 : 		if (_Large_string_engaged())

	cmovae	ecx, DWORD PTR $T19[ebp]

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	edi, DWORD PTR $T19[ebp+16]

; 2553 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR __Str$58[ebp+16]
	sub	eax, edx

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	push	edi
	push	ecx
	cmp	edi, eax
	ja	SHORT $LN141@do_get

; 2555 : 			{
; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+edi]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Str$58[ebp+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$58[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$58[ebp]

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2560 : 			return (*this);

	jmp	SHORT $LN140@do_get
$LN141@do_get:

; 2561 : 			}
; 2562 : 
; 2563 : 		return (_Reallocate_grow_by(_Count,

	mov	BYTE PTR $T25[ebp], 0
	lea	ecx, DWORD PTR __Str$58[ebp]
	push	DWORD PTR $T25[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN140@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 447  : 			_Str += _Punct_fac.truename();	// construct "\0false\0true"

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR $T19[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN195@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR $T19[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN194@do_get

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN358@do_get
$LN194@do_get:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN195@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$58[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$58[ebp]

; 1798 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Str$58[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 448  : 			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());

	push	eax
	push	2
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >

; 449  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Str$58[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 448  : 			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	$LN4@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Str$58[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN261@do_get

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN359@do_get
$LN261@do_get:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 450  : 		else

	jmp	$LN4@do_get
$LN2@do_get:

; 451  : 			{	// get zero or nonzero integer
; 452  : 			char _Ac[_MAX_INT_DIG], *_Ep;
; 453  : 			int _Errno = 0;

	mov	DWORD PTR __Errno$57[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T41[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 454  : 			const unsigned long _Ulo = _CSTD _Stoulx(_Ac, &_Ep,

	lea	eax, DWORD PTR __Errno$57[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	push	eax
	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	push	DWORD PTR [edi+20]
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$59[ebp]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR __Ep$56[ebp]
	push	eax
	lea	eax, DWORD PTR __Ac$59[ebp]
	push	eax
	call	__Stoulx
	add	esp, 16					; 00000010H
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 8

; 405  : 		if (_Ptr != 0)

	mov	ecx, DWORD PTR $T41[ebp+4]
	test	ecx, ecx
	je	SHORT $LN289@do_get

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN289@do_get
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN289@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 457  : 			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)

	lea	eax, DWORD PTR __Ac$59[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 457  : 			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)

	cmp	DWORD PTR __Ep$56[ebp], eax
	je	SHORT $LN4@do_get
	cmp	DWORD PTR __Errno$57[ebp], 0
	jne	SHORT $LN4@do_get
	cmp	edi, 1
	cmovbe	esi, edi
$LN4@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR __First$[ebp+4], 0
	mov	edx, DWORD PTR __First$[ebp]
	jne	SHORT $LN295@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN305@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN309@do_get
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN309@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN310@do_get
$LN309@do_get:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, DWORD PTR __First$[ebp]
$LN310@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN305@do_get

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR __First$[ebp+5], al
	jmp	SHORT $LN304@do_get
$LN305@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	edx, edx
	mov	DWORD PTR __First$[ebp], edx
$LN304@do_get:

; 582  : 		_Got = true;

	mov	BYTE PTR __First$[ebp+4], 1
$LN295@do_get:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR __Last$[ebp+4], 0
	mov	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN327@do_get

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN328@do_get

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN332@do_get
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN332@do_get
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN333@do_get
$LN332@do_get:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
$LN333@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	jne	SHORT $LN327@do_get
$LN328@do_get:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	xor	ecx, ecx
$LN327@do_get:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	edx, edx
	jne	SHORT $LN349@do_get
	test	ecx, ecx
	je	SHORT $LN350@do_get
	jmp	SHORT $LN348@do_get
$LN349@do_get:
	test	ecx, ecx
	je	SHORT $LN348@do_get
$LN350@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 462  : 			_State |= ios_base::eofbit;

	or	DWORD PTR [ebx], 1
$LN348@do_get:

; 463  : 		if (_Ans < 0)

	test	esi, esi
	jns	SHORT $LN355@do_get

; 464  : 			_State |= ios_base::failbit;

	or	DWORD PTR [ebx], 2

; 465  : 		else

	jmp	SHORT $LN7@do_get
$LN355@do_get:

; 466  : 			_Val = _Ans != 0;	// deliver value

	mov	eax, DWORD PTR __Val$GSCopy$1$[ebp]
	setne	cl
	mov	BYTE PTR [eax], cl
$LN7@do_get:

; 467  : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 468  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN357@do_get:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN358@do_get:
	call	__invalid_parameter_noinfo_noreturn
$LN359@do_get:
	call	__invalid_parameter_noinfo_noreturn
$LN354@do_get:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$1:
	lea	ecx, DWORD PTR __Str$58[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$3:
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z$4:
	lea	ecx, DWORD PTR $T41[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAA_N@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::do_get
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iosbase$ = 12						; size = 4
__State$ = 16						; size = 4
__Val$ = 20						; size = 4
__First$ = 24						; size = 8
__Last$ = 32						; size = 8
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get, COMDAT
; _this$ = ecx

; 379  : 		{	// get long from [_First, _Last) into _Val

	push	ebp
	mov	ebp, esp

; 380  : 		return (do_get(_First, _Last, _Iosbase, _State, _Val));

	push	DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __State$[ebp]
	push	DWORD PTR __Iosbase$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+40]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 381  : 		}

	pop	ebp
	ret	32					; 00000020H
?get@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@V32@0AAVios_base@2@AAHAAJ@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 331  : 		}

	ret	0
??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 502  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp

; 501  : 		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()

	mov	eax, DWORD PTR __Sb$[ebp]
	test	eax, eax
	mov	DWORD PTR [ecx], eax
	sete	al
	mov	BYTE PTR [ecx+5], 0
	mov	BYTE PTR [ecx+4], al

; 503  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::istreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 153  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 154  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 135  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN2@sentry

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 105  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 140  : 				}
; 141  :  #else /* _HAS_EXCEPTIONS */
; 142  : 			this->_Myostr._Osfx();
; 143  :  #endif /* _HAS_EXCEPTIONS */
; 144  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 121  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	esi, DWORD PTR __Ostr$[ebp]

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR [edi], esi

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi]
$LN6@sentry:

; 102  : 			}
; 103  : 
; 104  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 105  : 			{	// destroy after unlocking
; 106  : 			if (_Myostr.rdbuf() != 0)
; 107  : 				_Myostr.rdbuf()->_Unlock();
; 108  : 			}
; 109  : 
; 110  : 		basic_ostream& _Myostr;	// the output stream, for _Unlock call at destruction
; 111  : 
; 112  : 		_Sentry_base& operator=(const _Sentry_base&) = delete;
; 113  : 		};
; 114  : 
; 115  : 	class sentry
; 116  : 		: public _Sentry_base
; 117  : 		{	// stores thread lock and state of stream
; 118  : 	public:
; 119  : 		explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)
; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, edx

; 315  : 		return (_Mystate);

	mov	ecx, DWORD PTR [edx+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [ecx+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 123  : 				_Ostr.tie()->flush();

	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [esi]
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 124  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 125  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1453 : 		{	// put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi

; 1454 : 		char _Buf[2 * _MAX_INT_DIG];
; 1455 : 
; 1456 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	push	eax
	push	OFFSET ??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	eax, DWORD PTR __Buf$[esp+96]
	mov	edi, ecx
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1457 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
; 1458 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+136]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -72				; size = 4
__Precision$ = -68					; size = 8
$T12 = -64						; size = 1
__Ptwo$30 = -64						; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1429 : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1429 : 		{	// put formatted long double to _Dest

	mov	ecx, DWORD PTR __Iosbase$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	esi, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1429 : 		{	// put formatted long double to _Dest

	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[ebp+16], edx

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR __Buf$[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1430 : 		string _Buf;

	mov	DWORD PTR __$EHRec$[ebp+8], edx

; 1431 : 		char _Fmt[8];
; 1432 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1433 : 			== ios_base::fixed;

	mov	eax, DWORD PTR [ecx+20]

; 1434 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

	mov	edi, DWORD PTR [ecx+24]
	and	eax, 12288				; 00003000H
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR __Precision$1$[ebp], edi
	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN168@do_put
	test	edi, edi
	jne	SHORT $LN4@do_put
$LN168@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	edi, 6
	xor	ecx, ecx
	mov	DWORD PTR __Precision$1$[ebp], edi
$LN4@do_put:
	mov	DWORD PTR __Precision$[ebp+4], ecx

; 1437 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 843  :         return fabs((double)_X);

	movsd	xmm1, QWORD PTR __Val$[ebp]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1437 : 		if (_Isfixed && 1e10 < _CSTD fabsl(_Val))

	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	lea	eax, DWORD PTR __Ptwo$30[ebp]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1441 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$30[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1441 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	cdq
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_math.h

; 864  :         return frexp((double)_X, _Y);

	fstp	ST(0)
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1441 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	xor	eax, edx
	mov	esi, DWORD PTR __Buf$[ebp+20]
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR __Buf$[ebp+16]
	add	edi, eax
$LN2@do_put:

; 1442 : 			}
; 1443 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

	lea	ecx, DWORD PTR [edi+50]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3293 : 		if (_Newsize <= _Old_size)

	cmp	ecx, edx
	ja	SHORT $LN37@do_put

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 3944 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Buf$[ebp+16], ecx

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Buf$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3297 : 		else

	jmp	SHORT $LN61@do_put
$LN37@do_put:

; 3298 : 			{
; 3299 : 			append(_Newsize - _Old_size, _Ch);

	mov	edi, ecx

; 2580 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, esi

; 3299 : 			append(_Newsize - _Old_size, _Ch);

	sub	edi, edx

; 2580 : 		const size_type _Old_size = _My_data._Mysize;

	sub	eax, edx

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	edi, eax
	ja	SHORT $LN62@do_put

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Buf$[ebp+16], ecx

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Buf$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	edi
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2585 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	esi, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2587 : 			return (*this);

	jmp	SHORT $LN61@do_put
$LN62@do_put:

; 2588 : 			}
; 2589 : 
; 2590 : 		return (_Reallocate_grow_by(_Count,

	push	0
	push	edi
	mov	BYTE PTR $T12[ebp], 0
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	DWORD PTR $T12[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN61@do_put:

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Buf$[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	edi, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1445 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	movsd	xmm0, QWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	edi, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1445 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	sub	esp, 8
	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	esi, DWORD PTR __Buf$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1445 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR __Precision$1$[ebp]
	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR __Fmt$[ebp]
	push	76					; 0000004cH
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	push	esi
	push	edi
	call	_sprintf_s
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Buf$[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1448 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1448 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$GSCopy$1$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Buf$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1448 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	add	esp, 56					; 00000038H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN150@do_put
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN149@do_put

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN172@do_put
$LN149@do_put:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN150@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1448 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	eax, esi

; 1449 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN172@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN170@do_put:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -72				; size = 4
__Precision$ = -68					; size = 8
$T12 = -64						; size = 1
__Ptwo$30 = -64						; size = 4
_this$GSCopy$1$ = -60					; size = 4
__Iosbase$GSCopy$1$ = -56				; size = 4
__Precision$1$ = -52					; size = 4
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1405 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1405 : 		{	// put formatted double to _Dest

	mov	ecx, DWORD PTR __Iosbase$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	esi, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1405 : 		{	// put formatted double to _Dest

	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Buf$[ebp+16], edx

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Buf$[ebp+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR __Buf$[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1406 : 		string _Buf;

	mov	DWORD PTR __$EHRec$[ebp+8], edx

; 1407 : 		char _Fmt[8];
; 1408 : 		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
; 1409 : 			== ios_base::fixed;

	mov	eax, DWORD PTR [ecx+20]

; 1410 : 		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed

	mov	edi, DWORD PTR [ecx+24]
	and	eax, 12288				; 00003000H
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR __Precision$1$[ebp], edi
	test	ecx, ecx
	jg	SHORT $LN4@do_put
	jl	SHORT $LN164@do_put
	test	edi, edi
	jne	SHORT $LN4@do_put
$LN164@do_put:
	cmp	eax, 8192				; 00002000H
	je	SHORT $LN4@do_put
	mov	edi, 6
	xor	ecx, ecx
	mov	DWORD PTR __Precision$1$[ebp], edi
$LN4@do_put:
	mov	DWORD PTR __Precision$[ebp+4], ecx

; 1411 : 			? 6 : _Iosbase.precision();	// desired precision
; 1412 : 		size_t _Bufsize = (size_t)_Precision;
; 1413 : 		if (_Isfixed && 1e10 < _CSTD fabs(_Val))

	cmp	eax, 8192				; 00002000H
	jne	SHORT $LN2@do_put
	movsd	xmm1, QWORD PTR __Val$[ebp]
	movaps	xmm0, xmm1
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	comisd	xmm0, QWORD PTR __real@4202a05f20000000
	jbe	SHORT $LN2@do_put

; 1414 : 			{	// f or F format
; 1415 : 			int _Ptwo;
; 1416 : 			(void)_CSTD frexp(_Val, &_Ptwo);

	lea	eax, DWORD PTR __Ptwo$30[ebp]
	push	eax
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	call	_frexp

; 1417 : 			_Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

	mov	eax, DWORD PTR __Ptwo$30[ebp]
	add	esp, 12					; 0000000cH
	cdq
	fstp	ST(0)
	xor	eax, edx
	mov	esi, DWORD PTR __Buf$[ebp+20]
	sub	eax, edx
	imul	ecx, eax, 30103
	mov	eax, 351843721				; 14f8b589H
	imul	ecx
	sar	edx, 13					; 0000000dH
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR __Buf$[ebp+16]
	add	edi, eax
$LN2@do_put:

; 1418 : 			}
; 1419 : 		_Buf.resize(_Bufsize + 50);	// add fudge factor

	lea	ecx, DWORD PTR [edi+50]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3293 : 		if (_Newsize <= _Old_size)

	cmp	ecx, edx
	ja	SHORT $LN33@do_put

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 3944 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Buf$[ebp+16], ecx

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Buf$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3297 : 		else

	jmp	SHORT $LN57@do_put
$LN33@do_put:

; 3298 : 			{
; 3299 : 			append(_Newsize - _Old_size, _Ch);

	mov	edi, ecx

; 2580 : 		const size_type _Old_size = _My_data._Mysize;

	mov	eax, esi

; 3299 : 			append(_Newsize - _Old_size, _Ch);

	sub	edi, edx

; 2580 : 		const size_type _Old_size = _My_data._Mysize;

	sub	eax, edx

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	edi, eax
	ja	SHORT $LN58@do_put

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Buf$[ebp+16], ecx

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Buf$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	edi
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2585 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	esi, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2587 : 			return (*this);

	jmp	SHORT $LN57@do_put
$LN58@do_put:

; 2588 : 			}
; 2589 : 
; 2590 : 		return (_Reallocate_grow_by(_Count,

	push	0
	push	edi
	mov	BYTE PTR $T12[ebp], 0
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	DWORD PTR $T12[ebp]
	push	edi
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN57@do_put:

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Buf$[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	edi, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1421 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	movsd	xmm0, QWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	edi, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1421 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	sub	esp, 8
	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	esi, DWORD PTR __Buf$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1421 : 		int _Ngen = _CSTD sprintf_s((char *)_Buf.c_str(), _Buf.size(),

	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR __Precision$1$[ebp]
	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR __Fmt$[ebp]
	push	0
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	push	esi
	push	edi
	call	_sprintf_s
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Buf$[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1424 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1424 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	push	eax
	push	ecx
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$GSCopy$1$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	esi
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Buf$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1424 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	add	esp, 56					; 00000038H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN146@do_put
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Buf$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN145@do_put

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN168@do_put
$LN145@do_put:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN146@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1424 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));

	mov	eax, esi

; 1425 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN168@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN166@do_put:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
	lea	ecx, DWORD PTR __Buf$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1395 : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1396 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1397 : 
; 1398 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+88]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02CLHGNPPK@Lu?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1399 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
; 1400 : 				_Iosbase.flags()), _Val)));
; 1401 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	add	esp, 32					; 00000020H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 8
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1385 : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1386 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 1387 : 
; 1388 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+88]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02HIKPPMOK@Ld?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+108]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	add	esp, 20					; 00000014H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+100]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1389 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
; 1390 : 				_Iosbase.flags()), _Val)));
; 1391 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+128]
	add	esp, 32					; 00000020H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 6
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1375 : 		{	// put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1376 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1377 : 
; 1378 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+88]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02BDDLJJBK@lu?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+104]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+116]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1379 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
; 1380 : 				_Iosbase.flags()), _Val)));
; 1381 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -80						; size = 6
__Buf$ = -72						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1365 : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+84], eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 1366 : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 1367 : 
; 1368 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,

	lea	eax, DWORD PTR __Fmt$[esp+88]
	push	esi
	mov	esi, DWORD PTR __Iosbase$[ebp]
	push	edi
	push	DWORD PTR __Val$[ebp]
	mov	edi, ecx
	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_02EAOCLKAK@ld?$AA@
	push	eax
	push	edi
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+104]
	push	64					; 00000040H
	push	eax
	call	_sprintf_s
	push	eax
	lea	eax, DWORD PTR __Buf$[esp+116]
	push	eax
	push	DWORD PTR __Fill$[ebp]
	push	esi
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	ebx
	push	edi
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput

; 1369 : 			_CSTD sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
; 1370 : 				_Iosbase.flags()), _Val)));
; 1371 : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	add	esp, 48					; 00000030H
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T39 = -92						; size = 8
$T32 = -84						; size = 8
$T3 = -84						; size = 8
___$ReturnUdt$GSCopy$1$ = -76				; size = 4
_this$GSCopy$1$ = -72					; size = 4
__Fill$GSCopy$ = -68					; size = 1
$T8 = -64						; size = 24
__Str$47 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1336 : 		{	// put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	al, BYTE PTR __Fill$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], esi

; 1337 : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	test	DWORD PTR [ebx+20], 16384		; 00004000H
	mov	BYTE PTR __Fill$GSCopy$[ebp], al
	jne	SHORT $LN2@do_put

; 1338 : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

	movzx	eax, BYTE PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	DWORD PTR __Fill$GSCopy$[ebp]
	push	ebx
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	esi
	call	DWORD PTR [edx+36]
	jmp	$LN241@do_put
$LN2@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	esi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T3[ebp+4], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1341 : 			const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	esi, esi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN24@do_put

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN24@do_put
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN24@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Str$47[ebp+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$47[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR __Str$47[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1343 : 			if (_Val)

	cmp	BYTE PTR __Val$[ebp], 0
	lea	ecx, DWORD PTR $T8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR [edi]
	push	ecx
	mov	ecx, edi
	je	SHORT $LN4@do_put

; 144  : 		return (do_truename());

	call	DWORD PTR [eax+28]
$LN262@do_put:

; 1361 : 		}

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$47[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	edx, DWORD PTR $T8[ebp+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN146@do_put
	mov	ecx, DWORD PTR $T8[ebp]
	inc	edx
	mov	eax, ecx
	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN145@do_put
	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx
	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN263@do_put
	jmp	SHORT $LN145@do_put
$LN4@do_put:

; 139  : 		return (do_falsename());

	call	DWORD PTR [eax+24]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	jmp	SHORT $LN262@do_put
$LN145@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1349 : 				|| (size_t)_Iosbase.width() <= _Str.size()

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN146@do_put:
	cmp	DWORD PTR [ebx+36], 0
	mov	esi, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR __Str$47[ebp+16]
	jl	SHORT $LN8@do_put
	jg	SHORT $LN258@do_put
	test	esi, esi
	je	SHORT $LN8@do_put
$LN258@do_put:
	cmp	esi, eax
	jbe	SHORT $LN8@do_put
	sub	esi, eax
	jmp	SHORT $LN9@do_put
$LN8@do_put:
	xor	esi, esi
$LN9@do_put:

; 1350 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1351 : 
; 1352 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	eax, DWORD PTR [ebx+20]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN259@do_put

; 1353 : 				{	// put leading fill
; 1354 : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	esi
	push	DWORD PTR __Fill$GSCopy$[ebp]
	lea	eax, DWORD PTR $T32[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H

; 1355 : 				_Fillcount = 0;

	xor	esi, esi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp+4], edx
	jmp	SHORT $LN6@do_put
$LN259@do_put:

; 1350 : 					? 0 : (size_t)_Iosbase.width() - _Str.size();
; 1351 : 
; 1352 : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
$LN6@do_put:

; 1357 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	push	DWORD PTR __Str$47[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$47[ebp+20], 16		; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$47[ebp]

; 1798 : 		if (_Large_string_engaged())

	mov	edi, DWORD PTR __Str$47[ebp]
	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1357 : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T39[ebp]
	push	eax
	push	DWORD PTR _this$GSCopy$1$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put

; 1359 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	push	esi
	push	DWORD PTR __Fill$GSCopy$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [ebx+32], 0
	mov	DWORD PTR [ebx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1359 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str$47[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1359 : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	eax, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN241@do_put

; 3962 : 			{
; 3963 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3964 : 			auto& _Al = this->_Getal();
; 3965 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, edi

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN240@do_put

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edi, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H
	sub	eax, edi

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN263@do_put
$LN240@do_put:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN241@do_put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1361 : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN263@do_put:
	call	__invalid_parameter_noinfo_noreturn
$LN261@do_put:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
	lea	ecx, DWORD PTR __Str$47[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iosbase$ = 12						; size = 4
__Fill$ = 16						; size = 1
__Dest$ = 20						; size = 8
__Val$ = 28						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1317 : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp

; 1318 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	movsd	xmm0, QWORD PTR __Val$[ebp]
	sub	esp, 8
	mov	eax, DWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1319 : 		}

	pop	ebp
	ret	28					; 0000001cH
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iosbase$ = 12						; size = 4
__Fill$ = 16						; size = 1
__Val$ = 20						; size = 4
__Dest$ = 24						; size = 8
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1293 : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp

; 1294 : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	push	DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Fill$[ebp]
	push	DWORD PTR __Iosbase$[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [eax+36]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1295 : 		}

	pop	ebp
	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [ecx], OFFSET ??_7_Facet_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1261 : 		}

	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 669  : 		return (_Failed);

	mov	al, BYTE PTR [ecx]

; 670  : 		}

	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 635  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp

; 634  : 		: _Failed(false), _Strbuf(_Sb)

	mov	eax, DWORD PTR __Sb$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 636  : 		}

	mov	eax, ecx
	mov	BYTE PTR [ecx], 0
	pop	ebp
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 4216 : 		{	// discard any string

	push	esi
	mov	esi, ecx

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 4224 :  #endif /* _DEBUG */
; 4225 : 
; 4226 : 		_Myptr = 0;
; 4227 : 		}

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 4216 : 		{	// discard any string

	push	esi
	mov	esi, ecx

; 4217 : 		if (_Myptr != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 4218 : 
; 4219 :  #ifdef _DEBUG
; 4220 : 			_free_dbg(_Myptr, _CRT_BLOCK);
; 4221 : 
; 4222 :  #else /* _DEBUG */
; 4223 : 			_CSTD free(_Myptr);

	push	eax
	call	_free
	add	esp, 4
$LN4@Tidy:

; 4224 :  #endif /* _DEBUG */
; 4225 : 
; 4226 : 		_Myptr = 0;
; 4227 : 		}

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1845 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1809 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1797 : 		const value_type * _Result = _Bx._Buf;
; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1799 : 			{
; 1800 : 			_Result = _Unfancy(_Bx._Ptr);
; 1801 : 			}
; 1802 : 
; 1803 : 		return (_Result);

	mov	eax, DWORD PTR [ecx]

; 1804 : 		}

	ret	0
$LN8@Myptr:

; 1799 : 			{
; 1800 : 			_Result = _Unfancy(_Bx._Ptr);
; 1801 : 			}
; 1802 : 
; 1803 : 		return (_Result);

	mov	eax, ecx

; 1804 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;
; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN8@Myptr

; 1788 : 			{
; 1789 : 			_Result = _Unfancy(_Bx._Ptr);
; 1790 : 			}
; 1791 : 
; 1792 : 		return (_Result);

	mov	eax, DWORD PTR [ecx]

; 1793 : 		}

	ret	0
$LN8@Myptr:

; 1788 : 			{
; 1789 : 			_Result = _Unfancy(_Bx._Ptr);
; 1790 : 			}
; 1791 : 
; 1792 : 		return (_Result);

	mov	eax, ecx

; 1793 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 935  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 936  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 937  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2031 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2032 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2026 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2027 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2021 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2022 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2016 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2017 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 2006 : 		_Get_data()._Orphan_all();
; 2007 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1894 : 		}

	mov	eax, ecx

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1894 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3958 : 		{	// initialize buffer, deallocating any storage

	push	esi
	mov	esi, ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3959 : 		this->_Orphan_all();
; 3960 : 		auto& _My_data = this->_Get_data();
; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN35@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN34@Tidy_deall

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN33@Tidy_deall

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN34@Tidy_deall:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN35@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3974 : 		}

	ret	0
$LN33@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN40@Tidy_deall:
	int	3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3949 : 		auto& _My_data = this->_Get_data();
; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3955 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3942 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3943 : 		auto& _My_data = this->_Get_data();
; 3944 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN16@Eos
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3945 : 		}

	pop	ebp
	ret	4
$LN16@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3945 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3280 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3281 : 		const size_type _Storage_max = // can always store small string
; 3282 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3283 : 		return (_Min_value(

	mov	eax, 2147483647				; 7fffffffH

; 3284 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3285 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3286 : 			));
; 3287 : 
; 3288 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   : 	{	// return larger of _Left and _Right

	push	ebp
	mov	ebp, esp

; 33   : 	return (_Left < _Right ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovb	eax, ecx

; 34   : 	}

	pop	ebp
	ret	0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	eax, DWORD PTR [ecx+16]

; 3276 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
$T39 = 8						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2662 : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2663 : 		auto& _My_data = this->_Get_data();
; 2664 : 		if (_Count <= _My_data._Myres)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	edi, ecx
	ja	SHORT $LN2@assign

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ebx, esi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@assign
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2667 : 			_My_data._Mysize = _Count;

	mov	DWORD PTR [esi+16], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2677 : 		}

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:

; 3863 : 		if (_New_size > max_size())

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN123@assign

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN43@assign

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN44@assign

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN75@assign

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN106@assign

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN121@assign
$LN75@assign:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN76@assign

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, eax
	jmp	SHORT $LN121@assign
$LN76@assign:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ecx, ecx
$LN121@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edi
	push	eax
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR $T39[ebp], ecx
	mov	DWORD PTR [esi+16], edi

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [esi+20], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	call	_memset

; 489  : 		_Left = _Right;

	mov	ebx, DWORD PTR $T39[ebp]

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	eax, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN21@assign

; 3878 : 			{
; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN107@assign

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN106@assign

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN107@assign:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2673 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	mov	DWORD PTR [esi], ebx

; 2677 : 		}

	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN106@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN123@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN119@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z PROC ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator(), COMDAT
; _this$dead$ = ecx

; 2673 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2673 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2673 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	edi, DWORD PTR __Count$[ebp]
	push	edi
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2676 : 			}, _Ch));

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_c6753c90be971fc9cc00b4f35f237a75>@@QBE@QADID@Z ENDP ; <lambda_c6753c90be971fc9cc00b4f35f237a75>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
$T41 = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2657 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2657 : 		{	// assign [_Ptr, <null>)

	sub	esp, 8
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2657 : 		{	// assign [_Ptr, <null>)

	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR [esi+1]
$LL126@assign:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL126@assign
	sub	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2641 : 		if (_Count <= _My_data._Myres)

	mov	ecx, DWORD PTR [edi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	esi, ecx
	ja	SHORT $LN8@assign

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ebx, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN15@assign
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ebx, DWORD PTR [edi]
$LN15@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	push	edx
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2644 : 			_My_data._Mysize = _Count;

	mov	DWORD PTR [edi+16], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2658 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2659 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@assign:

; 3863 : 		if (_New_size > max_size())

	cmp	esi, 2147483647				; 7fffffffH
	ja	$LN130@assign

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	ebx, esi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN49@assign

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN48@assign
$LN49@assign:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN50@assign

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN48@assign
$LN50@assign:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN48@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN81@assign

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 102  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN112@assign

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN128@assign
$LN81@assign:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN82@assign

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	jmp	SHORT $LN128@assign
$LN82@assign:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	eax, eax
$LN128@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	esi
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR $T41[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [edi+16], esi

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [edi+20], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	call	_memcpy

; 489  : 		_Left = _Right;

	mov	ebx, DWORD PTR $T41[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	eax, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN27@assign

; 3878 : 			{
; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [edi]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN113@assign

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN112@assign

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN113@assign:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN27@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2658 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

	mov	DWORD PTR [edi], ebx
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2659 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN112@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN130@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN127@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T3 = 8							; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2578 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 2579 : 		auto& _My_data = this->_Get_data();
; 2580 : 		const size_type _Old_size = _My_data._Mysize;
; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2582 : 			{
; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edi+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
$LN9@append:
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2585 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	esi, DWORD PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2587 : 			return (*this);

	mov	eax, edi
	pop	esi
	pop	edi

; 2591 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2592 : 				const size_type _Count, const _Elem _Ch) {
; 2593 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2594 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2595 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2596 : 			}, _Count, _Ch));
; 2597 : 		}

	pop	ebx
	pop	ebp
	ret	8
$LN2@append:

; 2588 : 			}
; 2589 : 
; 2590 : 		return (_Reallocate_grow_by(_Count,

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, edi
	push	ebx
	push	DWORD PTR $T3[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
	pop	edi

; 2591 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2592 : 				const size_type _Count, const _Elem _Ch) {
; 2593 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2594 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2595 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2596 : 			}, _Count, _Ch));
; 2597 : 		}

	pop	ebx
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$dead$ = ecx

; 2592 : 				const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2592 : 				const size_type _Count, const _Elem _Ch) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2594 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	esi, DWORD PTR __Count$[ebp]
	push	esi
	push	eax
	push	edi
	call	_memset
	add	esp, 24					; 00000018H

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2596 : 			}, _Count, _Ch));

	pop	ebp
	ret	20					; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
$T3 = 12						; size = 1
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2551 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2552 : 		auto& _My_data = this->_Get_data();
; 2553 : 		const size_type _Old_size = _My_data._Mysize;
; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [edi+20]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN2@append

; 2555 : 			{
; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edi+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@append
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
$LN9@append:
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ebx
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2560 : 			return (*this);

	mov	eax, edi
	pop	esi
	pop	edi

; 2564 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2565 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2566 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2567 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2568 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2569 : 			}, _Ptr, _Count));
; 2570 : 		}

	pop	ebx
	pop	ebp
	ret	8
$LN2@append:

; 2561 : 			}
; 2562 : 
; 2563 : 		return (_Reallocate_grow_by(_Count,

	push	ebx
	push	DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR $T3[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T3[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2564 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2565 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2566 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2567 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2568 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2569 : 			}, _Ptr, _Count));
; 2570 : 		}

	pop	ebx
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$dead$ = ecx

; 2565 : 				const _Elem * const _Ptr, const size_type _Count) {

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2565 : 				const _Elem * const _Ptr, const size_type _Count) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2567 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __Count$[ebp]
	push	esi
	push	DWORD PTR __Ptr$[ebp]
	push	edi
	call	_memcpy
	add	esp, 24					; 00000018H

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2569 : 			}, _Ptr, _Count));

	pop	ebp
	ret	20					; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__New_capacity$1$ = 8					; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2377 : 		{	// assign by copying data stored in _Right

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2378 : 			// pre: this != &_Right
; 2379 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2380 : 		auto& _My_data = this->_Get_data();
; 2381 : 		auto& _Right_data = _Right._Get_data();
; 2382 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, ecx

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2378 : 			// pre: this != &_Right
; 2379 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2380 : 		auto& _My_data = this->_Get_data();
; 2381 : 		auto& _Right_data = _Right._Get_data();
; 2382 : 		const size_type _Right_size = _Right_data._Mysize;

	mov	ebx, DWORD PTR [esi+16]

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN13@Construct_
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN13@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2384 : 		if (_Right_size < this->_BUF_SIZE)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN2@Construct_
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR [edi], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2399 : 		}

	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], 15			; 0000000fH
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN2@Construct_:

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	ecx, 2147483647				; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2393 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

	or	eax, 15					; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, ecx
	cmova	eax, ecx
	mov	DWORD PTR __New_capacity$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2394 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN46@Construct_

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN75@Construct_

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN45@Construct_
$LN46@Construct_:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN47@Construct_

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, eax
	jmp	SHORT $LN45@Construct_
$LN47@Construct_:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	ecx, ecx
$LN45@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2396 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [edi], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	esi
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2398 : 		_My_data._Myres = _New_capacity;

	mov	eax, DWORD PTR __New_capacity$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2399 : 		}

	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], eax
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN75@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN72@Construct_:
	int	3
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2327 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	push	ebp
	mov	ebp, esp

; 2328 : 			// pre: this != &_Right
; 2329 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2330 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2331 : 		auto& _Right_data = _Right._Get_data();
; 2332 : 
; 2333 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2334 : 		if (_Right_data._Large_string_engaged())
; 2335 : 			{	// take ownership of _Right's iterators along with its buffer
; 2336 : 			this->_Swap_all(_Right);
; 2337 : 			}
; 2338 : 		else
; 2339 : 			{
; 2340 : 			_Right._Orphan_all();
; 2341 : 			}
; 2342 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2343 : 
; 2344 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2345 : 			+ _Memcpy_move_offset;
; 2346 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2347 : 			+ _Memcpy_move_offset;
; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2350 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 1035 : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 102  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN21@allocate

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 1036 : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 1037 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN7@allocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1036 : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 1037 : 		}

	pop	ebp
	ret	4
$LN7@allocate:

; 204  : 	return (nullptr);

	xor	eax, eax

; 1036 : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 1037 : 		}

	pop	ebp
	ret	4
$LN21@allocate:

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	call	__invalid_parameter_noinfo_noreturn
$LN19@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 1029 : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 1030 : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@deallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN8@deallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN9@deallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1032 : 		}

	pop	ebp
	ret	8
$LN8@deallocate:

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN12@deallocate:
	int	3
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 112  : 		return (_Fillch);

	mov	al, BYTE PTR [ecx+64]

; 113  : 		}

	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+56]

; 92   : 		}

	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 57   : 		{	// merge _State into state, possibly reraise exception

	push	ebp
	mov	ebp, esp

; 58   : 		if (_State != goodbit)

	mov	eax, DWORD PTR __State$[ebp]
	test	eax, eax
	je	SHORT $LN2@setstate

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	mov	edx, DWORD PTR [ecx+12]

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	push	DWORD PTR __Reraise$[ebp]

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	edx, eax

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN2@setstate:

; 60   : 		}

	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN12@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1

; 26   : 		{	// ensure that derived classes can be destroyed properly

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	je	SHORT $LN12@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 250  : 		{	// return name for true

	push	ebp
	mov	ebp, esp

; 251  : 		return (string_type(_Truename));

	push	DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 252  : 		}

	pop	ebp
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 245  : 		{	// return name for false

	push	ebp
	mov	ebp, esp

; 246  : 		return (string_type(_Falsename));

	push	DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 247  : 		}

	pop	ebp
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 240  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp

; 241  : 		return (string(_Grouping));

	push	DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 242  : 		}

	pop	ebp
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 236  : 		return (_Kseparator);

	mov	al, BYTE PTR [ecx+13]

; 237  : 		}

	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 231  : 		return (_Dp);

	mov	al, BYTE PTR [ecx+12]

; 232  : 		}

	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 175  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 257  : 		_CSTD free((void *)_Grouping);

	push	DWORD PTR [esi+8]

; 175  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 257  : 		_CSTD free((void *)_Grouping);

	call	_free

; 258  : 		_CSTD free((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 259  : 		_CSTD free((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 177  : 		}

	ret	0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 143  : 		{	// return name for true

	push	ebp
	mov	ebp, esp

; 144  : 		return (do_truename());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [edx+28]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : 		}

	pop	ebp
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 138  : 		{	// return name for false

	push	ebp
	mov	ebp, esp

; 139  : 		return (do_falsename());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [edx+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 140  : 		}

	pop	ebp
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 93   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 92   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]

; 93   : 			{	// lock the stream buffer, if there

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 94   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 96   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
__Pg$1$ = -136						; size = 4
$T6 = -132						; size = 8
$T3 = -132						; size = 8
__Leading$1$ = -128					; size = 4
__Max_sig_dig$1$ = -124					; size = 4
__Ac$GSCopy$1$ = -120					; size = 4
__Punct_fac$1$ = -116					; size = 4
__Phexexp$GSCopy$1$ = -112				; size = 4
__Significant$2$ = -112					; size = 4
tv7791 = -108						; size = 4
__Significant$1$ = -104					; size = 4
__Last$GSCopy$1$ = -100					; size = 4
__Pten$1$ = -96						; size = 4
__Bad$1$ = -90						; size = 1
__Kseparator$1$ = -89					; size = 1
__Ptr$1$ = -88						; size = 4
__Seendigit$1$ = -81					; size = 1
__Grouping$ = -80					; size = 24
__Groups$277 = -56					; size = 24
__Atoms$ = -32						; size = 15
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld, COMDAT

; 818  : 		{	// get floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Iosbase$[ebp]
	mov	edi, DWORD PTR __Ac$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR __Phexexp$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 818  : 		{	// get floating-point field from [_First, _Last) into _Ac

	mov	esi, DWORD PTR __First$[ebp]

; 819  : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)

	and	eax, 12288				; 00003000H
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], edi
	mov	DWORD PTR __Last$GSCopy$1$[ebp], ecx
	mov	DWORD PTR __Phexexp$GSCopy$1$[ebp], edx
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN24@Getffld

; 820  : 			return (_Getffldx(_Ac, _First, _Last,

	push	edx
	push	ebx
	push	ecx
	push	esi
	push	edi
	push	DWORD PTR _this$[ebp]
	call	?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
	add	esp, 24					; 00000018H
	jmp	$LN1@Getffld
$LN24@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, edi
	mov	DWORD PTR $T3[ebp+4], edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 823  : 		const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR __Punct_fac$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edi, edi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN100@Getffld

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN1791@Getffld
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN1791@Getffld:

; 407  : 		}

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN100@Getffld:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 134  : 		return (do_grouping());

	lea	edx, DWORD PTR __Grouping$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+20]

; 824  : 		const string _Grouping = _Punct_fac.grouping();
; 825  : 		char *_Ptr = _Ac;

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 827  : 		bool _Sticky = false;

	xor	al, al
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR tv7791[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 826  : 		bool _Bad = false;

	mov	BYTE PTR __Bad$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, edi
	mov	DWORD PTR $T6[ebp+4], edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 834  : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	edi, edi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN115@Getffld

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN115@Getffld
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN115@Getffld:

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	lea	ecx, DWORD PTR __Atoms$[ebp]

; 407  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [ebx]
	push	ecx
	push	OFFSET ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB+15
	push	OFFSET ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld'::`2'::_Src
	mov	ecx, ebx
	call	DWORD PTR [eax+28]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN123@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN133@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN137@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN137@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN138@Getffld
$LN137@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN138@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN133@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN132@Getffld
$LN133@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN132@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN123@Getffld:

; 551  : 		if (!_Right._Got)

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN124@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN156@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN160@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN160@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN161@Getffld
$LN160@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN161@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN156@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN155@Getffld
$LN156@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN155@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN124@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1669@Getffld
	test	eax, eax
	je	$LN255@Getffld
	jmp	SHORT $LN127@Getffld
$LN1669@Getffld:
	test	eax, eax
	jne	$LN255@Getffld
$LN127@Getffld:

; 512  : 		if (!_Got)

	mov	dl, BYTE PTR [esi+4]
	test	dl, dl
	jne	SHORT $LN177@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN182@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1710@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1710@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN187@Getffld
$LN1710@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN187@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN182@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN181@Getffld
$LN182@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN181@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	dl, 1
$LN177@Getffld:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 839  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	cmp	al, BYTE PTR __Atoms$[ebp+11]
	jne	SHORT $LN27@Getffld

; 841  : 			*_Ptr++ = '+';

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 841  : 			*_Ptr++ = '+';

	mov	DWORD PTR __Ptr$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN207@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN211@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN211@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN212@Getffld
$LN211@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN212@Getffld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN207@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 844  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN255@Getffld
$LN207@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 844  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN255@Getffld
$LN27@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	dl, dl
	jne	SHORT $LN1711@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN231@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN235@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN235@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN236@Getffld
$LN235@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN236@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN1625@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN230@Getffld
$LN1625@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+5]
$LN231@Getffld:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN230@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1711@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 844  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	cmp	al, BYTE PTR __Atoms$[ebp+10]
	jne	SHORT $LN255@Getffld

; 846  : 			*_Ptr++ = '-';

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	BYTE PTR [eax], 45			; 0000002dH
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 846  : 			*_Ptr++ = '-';

	mov	DWORD PTR __Ptr$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN256@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN260@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN260@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN261@Getffld
$LN260@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN261@Getffld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN256@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN255@Getffld
$LN256@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN255@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 850  : 		char *_Leading = _Ptr;	// remember backstop

	mov	eax, DWORD PTR __Ptr$1$[ebp]

; 851  : 		*_Ptr++ = '0';	// backstop carries from sticky bit
; 852  : 
; 853  : 		bool _Seendigit = false;	// seen a digit in input

	xor	bl, bl
	mov	DWORD PTR __Leading$1$[ebp], eax

; 858  : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	ecx, 36					; 00000024H
	mov	BYTE PTR __Seendigit$1$[ebp], bl
	mov	edx, 768				; 00000300H
	xor	ebx, ebx
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR __Pten$1$[ebp], eax
	mov	eax, DWORD PTR __Phexexp$GSCopy$1$[ebp]
	mov	DWORD PTR __Significant$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ebx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 858  : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	cmp	DWORD PTR [eax], 1000000000		; 3b9aca00H
	cmove	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 858  : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	DWORD PTR __Max_sig_dig$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	ebx, DWORD PTR __Grouping$[ebp]
	mov	DWORD PTR __Pg$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 861  : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	je	$LL1752@Getffld
	test	al, al
	jle	$LL1752@Getffld

; 877  : 					}
; 878  : 		else
; 879  : 			{	// grouping specified, gather digits and group sizes
; 880  : 			const _Elem _Kseparator = _Grouping.size() == 0

	cmp	DWORD PTR __Grouping$[ebp+16], 0
	jne	SHORT $LN84@Getffld
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	SHORT $LN85@Getffld
$LN84@Getffld:

; 129  : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 877  : 					}
; 878  : 		else
; 879  : 			{	// grouping specified, gather digits and group sizes
; 880  : 			const _Elem _Kseparator = _Grouping.size() == 0

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN85@Getffld:

; 881  : 				? (_Elem)0 : _Punct_fac.thousands_sep();
; 882  : 			string _Groups((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$277[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]

; 883  : 			size_t _Group = 0;

	xor	edi, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	npad	1
$LL411@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN435@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN445@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN449@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN449@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN450@Getffld
$LN449@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN450@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN445@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN444@Getffld
$LN445@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN444@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN435@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN436@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN468@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN472@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN472@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN473@Getffld
$LN472@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN473@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN468@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN467@Getffld
$LN468@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN467@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN436@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN1668@Getffld
	test	eax, eax
	jne	SHORT $LN439@Getffld
$LN440@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 914  : 			if (_Group == 0)

	mov	ebx, DWORD PTR __Pg$1$[ebp]
	test	edi, edi
	je	SHORT $LL8@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$277[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$277[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 916  : 			else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+edi], 0
	jle	$LN57@Getffld

; 917  : 				++_Group;	// add trailing group to group count

	inc	edi
$LL8@Getffld:

; 918  : 			else
; 919  : 				_Bad = true;	// trailing separator, fail
; 920  : 
; 921  : 			while (!_Bad && 0 < _Group)

	mov	edx, ebx
	test	edi, edi
	je	$LN1579@Getffld

; 922  : 				if (*_Pg == CHAR_MAX)

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 127					; 0000007fH
	je	$LN1579@Getffld

; 925  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	sub	edi, 1
	je	SHORT $LN1627@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$277[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$277[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 925  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax+edi]
	jne	$LN57@Getffld
$LN1627@Getffld:
	test	edi, edi
	jne	SHORT $LN1628@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$277[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$277[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 925  : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax]
	jl	$LN57@Getffld
$LN1628@Getffld:

; 918  : 			else
; 919  : 				_Bad = true;	// trailing separator, fail
; 920  : 
; 921  : 			while (!_Bad && 0 < _Group)

	cmp	BYTE PTR [ebx+1], 0

; 926  : 					_Bad = true;	// bad group size, fail
; 927  : 				else if ('\0' < _Pg[1])

	lea	eax, DWORD PTR [ebx+1]
	mov	ebx, eax
	cmovle	ebx, edx

; 929  : 			}

	jmp	SHORT $LL8@Getffld
$LN1668@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN440@Getffld
$LN439@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN489@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN494@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN498@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN498@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN499@Getffld
$LN498@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN499@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN494@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN493@Getffld
$LN494@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN493@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN489@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN516@Getffld
	npad	1
$LL517@Getffld:
	cmp	al, dl
	je	SHORT $LN516@Getffld
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL517@Getffld
$LN516@Getffld:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 884  : 
; 885  : 			for (; _First != _Last; ++_First)
; 886  : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)

	cmp	ecx, 10					; 0000000aH
	jae	SHORT $LN38@Getffld

; 887  : 					{	// got a digit, add to group size
; 888  : 					_Seendigit = true;
; 889  : 					if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Significant$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], 1
	cmp	DWORD PTR __Max_sig_dig$1$[ebp], edx
	jg	SHORT $LN40@Getffld

; 890  : 						{	// enough digits, scale by 10 and update _Sticky
; 891  : 						++_Pten;

	inc	DWORD PTR __Pten$1$[ebp]

; 892  : 						if (0 < _Idx)

	test	ecx, ecx
	je	SHORT $LN44@Getffld

; 893  : 							_Sticky = true;

	mov	al, 1
	mov	DWORD PTR tv7791[ebp], eax

; 894  : 						}

	jmp	SHORT $LN44@Getffld
$LN40@Getffld:

; 895  : 					else if (_Idx == 0 && _Significant == 0)

	test	ecx, ecx
	jne	SHORT $LN43@Getffld
	test	edx, edx
	je	SHORT $LN44@Getffld
$LN43@Getffld:

; 896  : 						;	// drop leading zeros
; 897  : 					else
; 898  : 						{	// save a significant digit
; 899  : 						*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx

; 900  : 						++_Significant;

	inc	edx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Significant$1$[ebp], edx
$LN44@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groups$277[ebp+20]

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	mov	ecx, DWORD PTR __Groups$277[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 902  : 					if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+edi], 127			; 0000007fH
	je	$LN5@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 903  : 						++_Groups[_Group];

	inc	BYTE PTR [eax+edi]

; 904  : 					}
; 905  : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN5@Getffld
$LN38@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$277[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$277[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$277[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 907  : 					|| *_First != _Kseparator)

	cmp	BYTE PTR [eax+edi], 0
	je	$LN440@Getffld
	cmp	BYTE PTR __Kseparator$1$[ebp], 0
	je	$LN440@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN559@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN564@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN568@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN568@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN569@Getffld
$LN568@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN569@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN564@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN563@Getffld
$LN564@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN563@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN559@Getffld:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 907  : 					|| *_First != _Kseparator)

	cmp	al, BYTE PTR __Kseparator$1$[ebp]
	jne	$LN440@Getffld

; 908  : 					break;	// not a group separator, done
; 909  : 				else
; 910  : 					{	// add a new group to _Groups string
; 911  : 					_Groups.append((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$277[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 912  : 					++_Group;

	inc	edi
$LN5@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1761@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN416@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN416@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN417@Getffld
$LN416@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN417@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1761@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	$LL411@Getffld
$LN1761@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL411@Getffld
$LN57@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 929  : 			}

	mov	BYTE PTR __Bad$1$[ebp], 1
$LN1579@Getffld:
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groups$277[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN1790@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groups$277[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN659@Getffld

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN1799@Getffld
$LN659@Getffld:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN1790@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN320@Getffld:
	cmp	BYTE PTR [esi+4], 0
	jne	$LN683@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN693@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN697@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	$LN697@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LN698@Getffld
$LL1752@Getffld:

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN315@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN325@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN329@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN329@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN330@Getffld
$LN329@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN330@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN325@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN324@Getffld
$LN325@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN324@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN315@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN316@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN348@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN352@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN352@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN353@Getffld
$LN352@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN353@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN348@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN347@Getffld
$LN348@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN347@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN316@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1667@Getffld
	test	eax, eax
	je	$LN320@Getffld
	jmp	SHORT $LN1630@Getffld
$LN1667@Getffld:
	test	eax, eax
	jne	$LN320@Getffld
$LN1630@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN369@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN374@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN378@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN378@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN379@Getffld
$LN378@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN379@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN374@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN373@Getffld
$LN374@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN373@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN369@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN396@Getffld
	npad	6
$LL397@Getffld:
	cmp	al, dl
	je	SHORT $LN396@Getffld
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL397@Getffld
$LN396@Getffld:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 862  : 			for (; _First != _Last
; 863  : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	cmp	ecx, 10					; 0000000aH
	jae	$LN320@Getffld

; 865  : 				if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Significant$1$[ebp]
	cmp	DWORD PTR __Max_sig_dig$1$[ebp], edx
	jg	SHORT $LN33@Getffld

; 866  : 					{	// enough digits, scale by 10 and update _Sticky
; 867  : 					++_Pten;

	inc	DWORD PTR __Pten$1$[ebp]

; 868  : 					if (0 < _Idx)

	test	ecx, ecx
	je	SHORT $LN2@Getffld

; 869  : 						_Sticky = true;

	mov	al, 1
	mov	DWORD PTR tv7791[ebp], eax

; 870  : 					}

	jmp	SHORT $LN2@Getffld
$LN33@Getffld:

; 871  : 				else if (_Idx == 0 && _Significant == 0)

	test	ecx, ecx
	jne	SHORT $LN36@Getffld
	test	edx, edx
	je	SHORT $LN2@Getffld
$LN36@Getffld:

; 872  : 					;	// drop leading zeros
; 873  : 				else
; 874  : 					{	// save a significant digit
; 875  : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx

; 876  : 					++_Significant;

	inc	edx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Significant$1$[ebp], edx
$LN2@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 864  : 					_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1762@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN296@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN296@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN297@Getffld
$LN296@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN297@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1762@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	$LL1752@Getffld
$LN1762@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1752@Getffld
$LN697@Getffld:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN698@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN693@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN692@Getffld
$LN693@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN692@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN683@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN684@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN716@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN720@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN720@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN721@Getffld
$LN720@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN721@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN716@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN715@Getffld
$LN716@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN715@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN684@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1666@Getffld
	test	eax, eax
	je	$LN1763@Getffld
	jmp	SHORT $LN1633@Getffld
$LN1666@Getffld:
	test	eax, eax
	jne	$LN1763@Getffld
$LN1633@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN737@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN742@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1712@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1712@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN747@Getffld
$LN1712@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN747@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN742@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN741@Getffld
$LN742@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN741@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN737@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 124  : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	bl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 124  : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 930  : 
; 931  : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	cmp	bl, al
	jne	SHORT $LN1763@Getffld

; 932  : 			{	// add .
; 933  : 			*_Ptr++ = localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN769@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN773@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN773@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN774@Getffld
$LN773@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN774@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN769@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1763@Getffld
$LN769@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1763@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 937  : 		if (*_Phexexp != _ENABLE_V2_BEHAVIOR && _Significant == 0)

	mov	eax, DWORD PTR __Phexexp$GSCopy$1$[ebp]
	mov	ebx, DWORD PTR __Significant$1$[ebp]
	cmp	DWORD PTR [eax], 1000000000		; 3b9aca00H
	je	$LN1606@Getffld
	test	ebx, ebx
	jne	$LN1606@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+4]
	mov	ebx, DWORD PTR __Pten$1$[ebp]
$LL791@Getffld:

; 549  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN815@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN825@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN829@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN829@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN830@Getffld
$LN829@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN830@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN825@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN824@Getffld
$LN825@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN824@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN815@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN816@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN848@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN852@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN852@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN853@Getffld
$LN852@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN853@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN848@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN847@Getffld
$LN848@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN847@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN816@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1665@Getffld
	test	eax, eax
	jne	SHORT $LN1634@Getffld
$LN1714@Getffld:
	mov	DWORD PTR __Pten$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 942  : 			if (_Pten < 0)

	test	ebx, ebx
	mov	ebx, DWORD PTR __Significant$1$[ebp]
	jns	SHORT $LN1606@Getffld

; 943  : 				{	// put one back
; 944  : 				*_Ptr++ = '0';

	mov	eax, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax

; 945  : 				++_Pten;

	inc	DWORD PTR __Pten$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN1606@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+4]
$LL1597@Getffld:

; 549  : 		if (!_Got)

	test	al, al
	jne	$LN922@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN932@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN936@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	$LN936@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LN937@Getffld
$LN1665@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN1714@Getffld
$LN1634@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN869@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN874@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1713@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1713@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN879@Getffld
$LN1713@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN879@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN874@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN873@Getffld
$LN874@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN873@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN869@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 939  : 			for (; _First != _Last && *_First == _Atoms[0];

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	$LN1714@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 941  : 				--_Pten;	// just count leading fraction zeros

	dec	ebx
	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1764@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN796@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN796@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN797@Getffld
$LN796@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN797@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1764@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	al, al
	jmp	$LL791@Getffld
$LN1764@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL791@Getffld
$LN936@Getffld:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN937@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN932@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN931@Getffld
$LN932@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN931@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN922@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN923@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN955@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN959@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN959@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN960@Getffld
$LN959@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN960@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN955@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN954@Getffld
$LN955@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN954@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN923@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1664@Getffld
	test	eax, eax
	jne	SHORT $LN1639@Getffld
$LN1716@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 960  : 		if (_Sticky)

	cmp	BYTE PTR tv7791[ebp], 0
	je	$LN71@Getffld

; 961  : 			{	// increment ls digit in memory of those lost
; 962  : 			char *_Px = _Ptr;
; 963  : 			while (--_Px != _Leading)

	mov	edi, DWORD PTR __Ptr$1$[ebp]
	mov	ebx, DWORD PTR __Leading$1$[ebp]
	dec	edi
	cmp	edi, ebx
	je	$LN1766@Getffld
	npad	6
$LL16@Getffld:

; 964  : 				{	// add in carry
; 965  : 				if (*_Px == localeconv()->decimal_point[0])

	call	_localeconv
	mov	cl, BYTE PTR [edi]
	mov	eax, DWORD PTR [eax]
	cmp	cl, BYTE PTR [eax]
	je	SHORT $LN1715@Getffld

; 966  : 					;	// skip over decimal point
; 967  : 				else if (*_Px != '9')

	cmp	cl, 57					; 00000039H
	jne	$LN1580@Getffld

; 970  : 					break;
; 971  : 					}
; 972  : 				else
; 973  : 					*_Px = '0';	// propagate carry

	mov	BYTE PTR [edi], 48			; 00000030H
$LN1715@Getffld:

; 961  : 			{	// increment ls digit in memory of those lost
; 962  : 			char *_Px = _Ptr;
; 963  : 			while (--_Px != _Leading)

	dec	edi
	cmp	edi, ebx
	jne	SHORT $LL16@Getffld
	jmp	$LN1766@Getffld
$LN1664@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN1716@Getffld
$LN1639@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN976@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN981@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN985@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN985@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN986@Getffld
$LN985@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN986@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN981@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN980@Getffld
$LN981@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN980@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN976@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN1003@Getffld
	npad	3
$LL1004@Getffld:
	cmp	al, dl
	je	SHORT $LN1003@Getffld
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL1004@Getffld
$LN1003@Getffld:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 946  : 				}
; 947  : 			}
; 948  : 
; 949  : 		for (; _First != _Last
; 950  : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	cmp	ecx, 10					; 0000000aH
	jae	$LN1716@Getffld

; 952  : 			if (_Significant < _Max_sig_dig)

	cmp	ebx, DWORD PTR __Max_sig_dig$1$[ebp]
	jge	SHORT $LN63@Getffld

; 953  : 				{	// save a significant fraction digit
; 954  : 				*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 955  : 				++_Significant;

	inc	ebx
	jmp	SHORT $LN13@Getffld
$LN63@Getffld:

; 956  : 				}
; 957  : 			else if (0 < _Idx)

	mov	eax, DWORD PTR tv7791[ebp]
	test	ecx, ecx
	movzx	eax, al
	mov	ecx, 1
	cmovne	eax, ecx
	mov	DWORD PTR tv7791[ebp], eax
$LN13@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 951  : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1765@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN903@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN903@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN904@Getffld
$LN903@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN904@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1765@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	al, al
	jmp	$LL1597@Getffld
$LN1765@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1597@Getffld
$LN1580@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 969  : 					++*_Px;

	inc	cl
	mov	BYTE PTR [edi], cl

; 974  : 				}
; 975  : 
; 976  : 			if (_Px == _Leading)

	cmp	edi, ebx
	jne	SHORT $LN1789@Getffld
$LN1766@Getffld:

; 977  : 				{	// change "999..." to "1000..." and scale _Pten
; 978  : 				*_Px = '1';
; 979  : 				++_Pten;

	inc	DWORD PTR __Pten$1$[ebp]
	mov	BYTE PTR [edi], 49			; 00000031H
$LN1789@Getffld:

; 984  : 			&& (*_First == _Atoms[_NUMGET_EOFF + 1]

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN71@Getffld:
	mov	bl, BYTE PTR __Seendigit$1$[ebp]
	test	bl, bl
	je	$LN1433@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN1011@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1021@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1025@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1025@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1026@Getffld
$LN1025@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1026@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1021@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1020@Getffld
$LN1021@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1020@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1011@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1012@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1044@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1048@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1048@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1049@Getffld
$LN1048@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1049@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1044@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1043@Getffld
$LN1044@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1043@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1012@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1662@Getffld
	test	eax, eax
	je	$LN1433@Getffld
	jmp	SHORT $LN1641@Getffld
$LN1662@Getffld:
	test	eax, eax
	jne	$LN1433@Getffld
$LN1641@Getffld:

; 512  : 		if (!_Got)

	mov	al, BYTE PTR [esi+4]
	test	al, al
	jne	SHORT $LN1065@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1070@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1717@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1717@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1075@Getffld
$LN1717@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1075@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1070@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1069@Getffld
$LN1070@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1069@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	al, 1
$LN1065@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 984  : 			&& (*_First == _Atoms[_NUMGET_EOFF + 1]

	mov	cl, BYTE PTR [esi+5]
	cmp	cl, BYTE PTR __Atoms$[ebp+13]
	je	SHORT $LN73@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN1091@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	edx, DWORD PTR [esi]
	mov	al, cl
	test	edx, edx
	je	SHORT $LN1096@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN1100@Getffld
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1100@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	edx, BYTE PTR [edi]
	mov	al, cl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1101@Getffld
$LN1100@Getffld:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, eax
	mov	al, BYTE PTR [esi+5]
$LN1101@Getffld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1096@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], cl
	jmp	SHORT $LN1095@Getffld
$LN1096@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	mov	cl, al
$LN1095@Getffld:
	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1091@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 984  : 			&& (*_First == _Atoms[_NUMGET_EOFF + 1]

	cmp	cl, BYTE PTR __Atoms$[ebp+12]
	jne	$LN1433@Getffld
$LN73@Getffld:

; 987  : 			*_Ptr++ = 'e';

	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ebx], 101			; 00000065H
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 987  : 			*_Ptr++ = 'e';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1768@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1125@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1125@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1126@Getffld
$LN1125@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1126@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1768@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
	jmp	SHORT $LN1120@Getffld
$LN1768@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
$LN1120@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 989  : 			_Seendigit = false;

	mov	BYTE PTR [esi+4], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 989  : 			_Seendigit = false;

	mov	BYTE PTR __Seendigit$1$[ebp], 0

; 990  : 			_Significant = 0;

	mov	DWORD PTR __Significant$2$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN1142@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1152@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1156@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1156@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1157@Getffld
$LN1156@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1157@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1152@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1151@Getffld
$LN1152@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1151@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1142@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1143@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1175@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1179@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1179@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1180@Getffld
$LN1179@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1180@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1175@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1174@Getffld
$LN1175@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1174@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1143@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1661@Getffld
	test	eax, eax
	je	$LN1780@Getffld
	jmp	SHORT $LN1644@Getffld
$LN1661@Getffld:
	test	eax, eax
	jne	$LN1780@Getffld
$LN1644@Getffld:

; 512  : 		if (!_Got)

	mov	dl, BYTE PTR [esi+4]
	test	dl, dl
	jne	SHORT $LN1196@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1201@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1205@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1205@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1206@Getffld
$LN1205@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [esi]
$LN1206@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1201@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1200@Getffld
$LN1201@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN1200@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	dl, 1
$LN1196@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 994  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+11]
	jne	SHORT $LN76@Getffld

; 996  : 				*_Ptr++ = '+';

	mov	BYTE PTR [ebx], 43			; 0000002bH
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 996  : 				*_Ptr++ = '+';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1769@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1230@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1230@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1231@Getffld
$LN1230@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1231@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1769@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 999  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN1780@Getffld
$LN1769@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 999  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN1780@Getffld
$LN76@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	dl, dl
	jne	SHORT $LN1245@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1250@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1254@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1254@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1255@Getffld
$LN1254@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1255@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1643@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1249@Getffld
$LN1643@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+5]
$LN1250@Getffld:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1249@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1245@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 999  : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	cmp	al, BYTE PTR __Atoms$[ebp+10]
	jne	SHORT $LN1780@Getffld

; 1001 : 				*_Ptr++ = '-';

	mov	BYTE PTR [ebx], 45			; 0000002dH
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1001 : 				*_Ptr++ = '-';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1770@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1718@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1718@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1280@Getffld
$LN1718@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1280@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1770@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1780@Getffld
$LN1770@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1780@Getffld:
	mov	bh, BYTE PTR __Seendigit$1$[ebp]
	npad	6
$LL1758@Getffld:

; 549  : 		if (!_Got)

	mov	cl, BYTE PTR [esi+4]
	mov	al, cl
	test	cl, cl
	jne	SHORT $LN1321@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1331@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1335@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1335@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1336@Getffld
$LN1335@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1336@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1331@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1330@Getffld
$LN1331@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1330@Getffld:

; 582  : 		_Got = true;

	mov	cl, 1
	mov	BYTE PTR [esi+4], 1
	mov	al, cl
$LN1321@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1322@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1354@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1358@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1358@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1359@Getffld
$LN1358@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1359@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1354@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1353@Getffld
$LN1354@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1353@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
	mov	cl, BYTE PTR [esi+4]
	mov	al, cl
$LN1322@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	edx, DWORD PTR [esi]
	mov	bl, al
	mov	edi, DWORD PTR [edi]
	test	edx, edx
	jne	SHORT $LN1698@Getffld
	test	edi, edi
	je	SHORT $LN1326@Getffld
$LN1646@Getffld:
	xor	ah, ah
	mov	bl, al
$LN1327@Getffld:

; 613  : 	return (!(_Left == _Right));

	test	ah, ah
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1005 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	jne	$LN19@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	mov	cl, bl
	test	bl, bl
	jne	SHORT $LN1375@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN1380@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1719@Getffld
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1719@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1385@Getffld
$LN1698@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	edi, edi
	je	SHORT $LN1646@Getffld
$LN1326@Getffld:
	mov	ah, 1
	jmp	SHORT $LN1327@Getffld
$LN1719@Getffld:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
$LN1385@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1380@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1379@Getffld
$LN1380@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1379@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	cl, 1
$LN1375@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1005 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN19@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1007 : 				_Seendigit = true;

	mov	bh, 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1771@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1302@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1302@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1303@Getffld
$LN1302@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1303@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1771@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	BYTE PTR [esi+4], 0
	jmp	$LL1758@Getffld
$LN1771@Getffld:

; 566  : 			}
; 567  : 		else

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	jmp	$LL1758@Getffld
$LN19@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1010 : 			if (_Seendigit)

	mov	edi, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], bh
	test	bh, bh
	je	SHORT $LN1610@Getffld

; 1011 : 				*_Ptr++ = '0';	// put one back

	mov	BYTE PTR [edi], 48			; 00000030H
	inc	edi
	mov	cl, BYTE PTR [esi+4]
$LN1610@Getffld:
	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
$LL1601@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	test	cl, cl
	jne	SHORT $LN1428@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1438@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1442@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1442@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1443@Getffld
$LN1442@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1443@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1438@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1437@Getffld
$LN1438@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1437@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1428@Getffld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN1429@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN1461@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1465@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1465@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1466@Getffld
$LN1465@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1466@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1461@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN1460@Getffld
$LN1461@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN1460@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN1429@Getffld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN1660@Getffld
	test	eax, eax
	jne	SHORT $LN1432@Getffld
$LN1788@Getffld:
	mov	bl, BYTE PTR __Seendigit$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], edi
$LN1433@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1022 : 		if (_Bad || !_Seendigit)

	cmp	BYTE PTR __Bad$1$[ebp], 0
	jne	SHORT $LN82@Getffld
	test	bl, bl
	jne	$LN1793@Getffld
$LN82@Getffld:

; 1023 : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
	jmp	$LN81@Getffld
$LN1660@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN1788@Getffld
$LN1432@Getffld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN1482@Getffld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1487@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1491@Getffld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1491@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1492@Getffld
$LN1491@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1492@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1487@Getffld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1486@Getffld
$LN1487@Getffld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1486@Getffld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1482@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN1509@Getffld
$LL1510@Getffld:
	cmp	al, dl
	je	SHORT $LN1509@Getffld
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL1510@Getffld
$LN1509@Getffld:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 1012 : 			for (; _First != _Last
; 1013 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;

	cmp	ecx, 10					; 0000000aH
	jae	SHORT $LN1788@Getffld

; 1015 : 				if (_Significant < _MAX_EXP_DIG)

	mov	edx, DWORD PTR __Significant$2$[ebp]
	cmp	edx, 8
	jge	SHORT $LN21@Getffld

; 1016 : 					{	// save a significant exponent digit
; 1017 : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	BYTE PTR [edi], al
	inc	edi

; 1018 : 					++_Significant;

	inc	edx
	mov	DWORD PTR __Significant$2$[ebp], edx
$LN21@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1014 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1772@Getffld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1409@Getffld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1409@Getffld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1410@Getffld
$LN1409@Getffld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1410@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1772@Getffld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	cl, cl
	jmp	$LL1601@Getffld
$LN1772@Getffld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	cl, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1601@Getffld
$LN1793@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1022 : 		if (_Bad || !_Seendigit)

	mov	eax, DWORD PTR __Ptr$1$[ebp]
$LN81@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Grouping$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1024 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN1549@Getffld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN1548@Getffld

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN1800@Getffld
$LN1548@Getffld:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN1549@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1025 : 		return (_Pten);

	mov	eax, DWORD PTR __Pten$1$[ebp]
$LN1@Getffld:

; 1026 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1799@Getffld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN1800@Getffld:
	call	__invalid_parameter_noinfo_noreturn
$LN1796@Getffld:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$277[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffld
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT
__Dlen$1$ = -124					; size = 4
__Ac$GSCopy$1$ = -120					; size = 4
__Ptr$1$ = -116						; size = 4
$T117 = -116						; size = 1
__Last$GSCopy$1$ = -112					; size = 4
__Ptr$1$ = -108						; size = 4
__Base$1$ = -104					; size = 4
__Group$1$ = -100					; size = 4
__Seendigit$ = -100					; size = 1
__Nonzero$1$ = -95					; size = 1
__Kseparator$1$ = -94					; size = 1
__Seendigit$1$ = -93					; size = 1
__Grouping$ = -92					; size = 24
__Groups$ = -68						; size = 24
__Atoms$ = -44						; size = 27
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Basefield$ = 24					; size = 4
__Loc$ = 28						; size = 4
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld, COMDAT

; 703  : 		{	// get integer field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ac$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	ebx, DWORD PTR __Loc$[ebp]
	mov	esi, DWORD PTR __First$[ebp]

; 704  : 		const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Loc);

	push	ebx
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Last$GSCopy$1$[ebp], ecx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	edi, eax
	add	esp, 4

; 134  : 		return (do_grouping());

	lea	eax, DWORD PTR __Grouping$[ebp]
	mov	ecx, edi
	mov	edx, DWORD PTR [edi]
	push	eax
	call	DWORD PTR [edx+20]

; 705  : 		const string _Grouping = _Punct_fac.grouping();

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 706  : 		const _Elem _Kseparator = _Grouping.size() == 0

	cmp	DWORD PTR __Grouping$[ebp+16], 0
	jne	SHORT $LN42@Getifld
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	SHORT $LN43@Getifld
$LN42@Getifld:

; 129  : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 706  : 		const _Elem _Kseparator = _Grouping.size() == 0

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN43@Getifld:

; 707  : 			? (_Elem)0 : _Punct_fac.thousands_sep();
; 708  : 
; 709  : 		enum {
; 710  : 			_NUMGET_SIGNOFF = 22,
; 711  : 			_NUMGET_XOFF = 24};
; 712  : 		static constexpr char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
; 713  : 		_Elem _Atoms[sizeof (_Src)];
; 714  : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Loc);

	push	ebx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB+27
	push	OFFSET ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld'::`2'::_Src
	mov	ecx, eax
	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 717  : 		char *_Ptr = _Ac;

	mov	edi, DWORD PTR __Ac$GSCopy$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN69@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN79@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN83@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN83@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN84@Getifld
$LN83@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN84@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN79@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN78@Getifld
$LN79@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN78@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN69@Getifld:

; 551  : 		if (!_Right._Got)

	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN70@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN102@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN106@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN106@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN107@Getifld
$LN106@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN107@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN102@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN101@Getifld
$LN102@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN101@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN70@Getifld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN841@Getifld
	test	eax, eax
	je	$LN201@Getifld
	jmp	SHORT $LN73@Getifld
$LN841@Getifld:
	test	eax, eax
	jne	$LN201@Getifld
$LN73@Getifld:

; 512  : 		if (!_Got)

	mov	dl, BYTE PTR [esi+4]
	test	dl, dl
	jne	SHORT $LN123@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN128@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN132@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN132@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN133@Getifld
$LN132@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [esi]
$LN133@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN128@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN127@Getifld
$LN128@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN127@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	dl, 1
$LN123@Getifld:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 721  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN10@Getifld

; 723  : 			*_Ptr++ = '+';

	mov	BYTE PTR [edi], 43			; 0000002bH
	lea	eax, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 723  : 			*_Ptr++ = '+';

	mov	DWORD PTR __Ptr$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN153@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN157@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN157@Getifld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN158@Getifld
$LN157@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN158@Getifld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN153@Getifld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 726  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN201@Getifld
$LN153@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 726  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN201@Getifld
$LN10@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	dl, dl
	jne	SHORT $LN172@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN177@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN181@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN181@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN182@Getifld
$LN181@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN182@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN826@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN176@Getifld
$LN826@Getifld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+5]
$LN177@Getifld:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN176@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN172@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 726  : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN201@Getifld

; 728  : 			*_Ptr++ = '-';

	mov	BYTE PTR [edi], 45			; 0000002dH
	lea	eax, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 728  : 			*_Ptr++ = '-';

	mov	DWORD PTR __Ptr$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN202@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN206@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN206@Getifld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN207@Getifld
$LN206@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN207@Getifld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN202@Getifld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN201@Getifld
$LN202@Getifld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN201@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 732  : 		_Basefield &= ios_base::basefield;

	mov	edi, DWORD PTR __Basefield$[ebp]
	and	edi, 3584				; 00000e00H

; 733  : 		int _Base = _Basefield == ios_base::oct ? 8

	cmp	edi, 1024				; 00000400H
	jne	SHORT $LN46@Getifld
	mov	edi, 8
	jmp	SHORT $LN858@Getifld
$LN46@Getifld:
	cmp	edi, 2048				; 00000800H
	jne	SHORT $LN44@Getifld
	mov	edi, 16					; 00000010H
	jmp	SHORT $LN858@Getifld
$LN44@Getifld:
	neg	edi
	sbb	edi, edi
	and	edi, 10					; 0000000aH
$LN858@Getifld:

; 734  : 			: _Basefield == ios_base::hex ? 16
; 735  : 			: _Basefield == ios_base::_Fmtzero ? 0 : 10;
; 736  : 
; 737  : 		bool _Seendigit = false;	// seen a digit in input

	xor	al, al
	mov	DWORD PTR __Base$1$[ebp], edi
	mov	BYTE PTR __Seendigit$1$[ebp], al
	mov	BYTE PTR __Seendigit$[ebp], al

; 738  : 		bool _Nonzero = false;	// seen a nonzero digit in input

	mov	BYTE PTR __Nonzero$1$[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN225@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN235@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN239@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN239@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN240@Getifld
$LN239@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN240@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN235@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN234@Getifld
$LN235@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN234@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN225@Getifld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN226@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN258@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN262@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN262@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN263@Getifld
$LN262@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN263@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN258@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN257@Getifld
$LN258@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN257@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN226@Getifld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN840@Getifld
	test	eax, eax
	jne	SHORT $LN828@Getifld
$LN18@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 758  : 		size_t _Dlen = _Base == 0 || _Base == 10 ? 10

	test	edi, edi
	je	$LN48@Getifld
$LN846@Getifld:
	cmp	edi, 10					; 0000000aH
	je	$LN48@Getifld
$LN847@Getifld:
	mov	ecx, 8
	mov	eax, 22					; 00000016H
	cmp	edi, ecx
	cmove	eax, ecx
	mov	DWORD PTR __Dlen$1$[ebp], eax
	jmp	$LN49@Getifld
$LN840@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN18@Getifld
$LN828@Getifld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN279@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN284@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN849@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN849@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN289@Getifld
$LN849@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN289@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN284@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN283@Getifld
$LN284@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN283@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN279@Getifld:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 740  : 		if (_First != _Last && *_First == _Atoms[0])

	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN18@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 742  : 			_Seendigit = true;

	mov	al, 1
	mov	BYTE PTR __Seendigit$1$[ebp], al
	mov	BYTE PTR __Seendigit$[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN309@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN313@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN313@Getifld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN314@Getifld
$LN313@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN314@Getifld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN309@Getifld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
	jmp	SHORT $LN308@Getifld
$LN309@Getifld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
$LN308@Getifld:

; 549  : 		if (!_Got)

	mov	BYTE PTR [esi+4], al
	test	al, al
	jne	SHORT $LN830@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN342@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN346@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN346@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN347@Getifld
$LN346@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN347@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN342@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN341@Getifld
$LN342@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN341@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN830@Getifld:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN333@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN365@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN369@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN369@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN370@Getifld
$LN369@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN370@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN365@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN364@Getifld
$LN365@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN364@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN333@Getifld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN839@Getifld
	test	eax, eax
	jne	SHORT $LN336@Getifld
$LN14@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 752  : 			else if (_Base == 0)

	test	edi, edi
	jne	$LN846@Getifld

; 753  : 				{
; 754  : 				_Base = 8;

	mov	edi, 8
	mov	DWORD PTR __Base$1$[ebp], edi

; 758  : 		size_t _Dlen = _Base == 0 || _Base == 10 ? 10

	jmp	$LN847@Getifld
$LN839@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN14@Getifld
$LN336@Getifld:

; 512  : 		if (!_Got)

	mov	al, BYTE PTR [esi+4]
	test	al, al
	jne	SHORT $LN386@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN391@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN395@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN395@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN396@Getifld
$LN395@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [esi]
$LN396@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN391@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN390@Getifld
$LN391@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN390@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	al, 1
$LN386@Getifld:

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 746  : 				&& (_Base == 0 || _Base == 16))

	cmp	dl, BYTE PTR __Atoms$[ebp+25]
	je	SHORT $LN16@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN412@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN417@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN421@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN421@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN422@Getifld
$LN421@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	dl, BYTE PTR [esi+5]
	mov	ecx, DWORD PTR [esi]
$LN422@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN417@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	dl, al
	mov	BYTE PTR [esi+5], dl
	jmp	SHORT $LN416@Getifld
$LN417@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN416@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN412@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 746  : 				&& (_Base == 0 || _Base == 16))

	mov	edi, DWORD PTR __Base$1$[ebp]
	cmp	dl, BYTE PTR __Atoms$[ebp+24]
	jne	$LN14@Getifld
$LN16@Getifld:
	test	edi, edi
	je	SHORT $LN17@Getifld
	cmp	edi, 16					; 00000010H
	jne	$LN14@Getifld
$LN17@Getifld:

; 747  : 				{
; 748  : 				_Base = 16;
; 749  : 				_Seendigit = false;

	xor	al, al
	mov	edi, 16					; 00000010H
	mov	DWORD PTR __Base$1$[ebp], edi
	mov	BYTE PTR __Seendigit$1$[ebp], al
	mov	BYTE PTR __Seendigit$[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN442@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN446@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN446@Getifld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN447@Getifld
$LN446@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN447@Getifld:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN442@Getifld

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al

; 536  : 		}

	mov	BYTE PTR [esi+4], al
	jmp	$LN847@Getifld
$LN442@Getifld:

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0

; 536  : 		}

	mov	BYTE PTR [esi+4], al
	jmp	$LN847@Getifld
$LN48@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 758  : 		size_t _Dlen = _Base == 0 || _Base == 10 ? 10

	mov	DWORD PTR __Dlen$1$[ebp], 10		; 0000000aH
$LN49@Getifld:

; 759  : 			: _Base == 8 ? 8 : 16 + 6;
; 760  : 		string _Groups((size_t)1, (char)_Seendigit);

	push	DWORD PTR __Seendigit$[ebp]
	lea	ecx, DWORD PTR __Groups$[ebp]
	push	1
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 761  : 		size_t _Group = 0;

	xor	ebx, ebx

; 762  : 
; 763  : 		for (char *const _Pe = &_Ac[_MAX_INT_DIG - 1];

	mov	edi, DWORD PTR __Groups$[ebp]
$LL464@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN488@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN498@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN502@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN502@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN503@Getifld
$LN502@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN503@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN498@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN497@Getifld
$LN498@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN497@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN488@Getifld:

; 551  : 		if (!_Right._Got)

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [eax+4], 0
	jne	SHORT $LN489@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN521@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN525@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN525@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN526@Getifld
$LN525@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN526@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN852@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	ecx, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	BYTE PTR [ecx+5], al
	mov	eax, ecx
	jmp	SHORT $LN520@Getifld
$LN852@Getifld:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
$LN521@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [eax], 0
$LN520@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [eax+4], 1
$LN489@Getifld:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	jne	$LN838@Getifld
	test	eax, eax
	jne	$LN492@Getifld
$LN493@Getifld:
	mov	DWORD PTR __Ptr$1$[ebp], edi
	mov	DWORD PTR __Group$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 791  : 		if (_Group == 0)

	test	ebx, ebx
	je	SHORT $LN855@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 793  : 		else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+ebx], 0
	jle	$LN29@Getifld

; 794  : 			++_Group;	// add trailing group to group count

	inc	ebx
	mov	DWORD PTR __Group$1$[ebp], ebx
$LN855@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	al, BYTE PTR __Seendigit$1$[ebp]
$LN30@Getifld:

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ebx, DWORD PTR __Grouping$[ebp+20]

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ecx, DWORD PTR __Grouping$[ebp]

; 1798 : 		if (_Large_string_engaged())

	mov	esi, DWORD PTR __Grouping$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ebx, 16					; 00000010H

; 1798 : 		if (_Large_string_engaged())

	cmovae	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 798  : 		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )

	test	al, al
	je	$LN837@Getifld
	npad	7
$LL5@Getifld:
	mov	eax, DWORD PTR __Group$1$[ebp]
	mov	edi, ecx
	test	eax, eax
	je	$LN820@Getifld

; 799  : 			if (*_Pg == CHAR_MAX)

	mov	dl, BYTE PTR [ecx]
	cmp	dl, 127					; 0000007fH
	je	$LN820@Getifld

; 802  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	sub	eax, 1
	mov	DWORD PTR __Group$1$[ebp], eax
	je	SHORT $LN832@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 802  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	mov	ebx, DWORD PTR __Group$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 802  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	dl, BYTE PTR [eax+ebx]
	mov	ebx, DWORD PTR __Grouping$[ebp+20]
	jne	$LN837@Getifld
	mov	eax, DWORD PTR __Group$1$[ebp]
$LN832@Getifld:
	test	eax, eax
	jne	SHORT $LN833@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$[ebp+20], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 802  : 				|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	dl, BYTE PTR [eax]
	jl	$LN837@Getifld
$LN833@Getifld:

; 798  : 		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )

	cmp	BYTE PTR [ecx+1], 0

; 803  : 				_Seendigit = false;	// bad group size, fail
; 804  : 			else if ('\0' < _Pg[1])

	lea	eax, DWORD PTR [ecx+1]
	mov	ecx, eax
	cmovle	ecx, edi
	jmp	SHORT $LL5@Getifld
$LN838@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	$LN493@Getifld
$LN492@Getifld:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN542@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN547@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN551@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN551@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN552@Getifld
$LN551@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN552@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN547@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN546@Getifld
$LN547@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN546@Getifld:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN542@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR __Atoms$[ebp]
	lea	eax, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	cl, cl
	je	SHORT $LN569@Getifld
$LL570@Getifld:
	cmp	cl, dl
	je	SHORT $LN569@Getifld
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL570@Getifld
$LN569@Getifld:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	ecx, DWORD PTR __Atoms$[ebp]
	sub	eax, ecx

; 764  : 			_First != _Last; ++_First)
; 765  : 			{	// look for digits and separators
; 766  : 			size_t _Idx = _Find_elem(_Atoms, *_First);
; 767  : 			if (_Idx < _Dlen)

	cmp	eax, DWORD PTR __Dlen$1$[ebp]
	jae	SHORT $LN19@Getifld

; 768  : 				{	// got a digit, characterize it and add to group size
; 769  : 				*_Ptr = _Src[_Idx];
; 770  : 				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)

	cmp	BYTE PTR __Nonzero$1$[ebp], 0
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	al, BYTE PTR ?_Src@?1??_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1HABVlocale@3@@Z@4QBDB[eax]
	mov	BYTE PTR [ecx], al
	jne	SHORT $LN22@Getifld
	cmp	al, 48					; 00000030H
	je	SHORT $LN21@Getifld
$LN22@Getifld:
	mov	edx, DWORD PTR __Ac$GSCopy$1$[ebp]
	lea	eax, DWORD PTR [edx+31]
	cmp	ecx, eax
	jae	SHORT $LN21@Getifld

; 771  : 					{
; 772  : 					++_Ptr;

	inc	ecx

; 773  : 					_Nonzero = true;

	mov	BYTE PTR __Nonzero$1$[ebp], 1
	mov	DWORD PTR __Ptr$1$[ebp], ecx
$LN21@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR __Groups$[ebp+20]

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 776  : 				_Seendigit = true;

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 777  : 				if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+ebx], 127			; 0000007fH
	je	$LN2@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 778  : 					++_Groups[_Group];

	inc	BYTE PTR [eax+ebx]

; 779  : 				}
; 780  : 			else if (_Groups[_Group] == '\0'

	jmp	$LN859@Getifld
$LN19@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groups$[ebp+20]

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 782  : 				|| *_First != _Kseparator)

	cmp	BYTE PTR [eax+ebx], 0
	je	$LN493@Getifld
	mov	al, BYTE PTR __Kseparator$1$[ebp]
	test	al, al
	je	$LN493@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN612@Getifld

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN617@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN621@Getifld
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN621@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN622@Getifld
$LN621@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN622@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN617@Getifld

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN616@Getifld
$LN617@Getifld:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN616@Getifld:
	mov	edx, DWORD PTR __Groups$[ebp+20]
	mov	al, BYTE PTR __Kseparator$1$[ebp]

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN612@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 782  : 				|| *_First != _Kseparator)

	cmp	BYTE PTR [esi+5], al
	jne	$LN493@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2580 : 		const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR __Groups$[ebp+16]
	mov	eax, edx
	sub	eax, ecx

; 2581 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	eax, 1
	jb	SHORT $LN638@Getifld

; 2582 : 			{
; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+1]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 2583 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Groups$[ebp+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	WORD PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2587 : 			return (*this);

	jmp	SHORT $LN637@Getifld
$LN638@Getifld:

; 2588 : 			}
; 2589 : 
; 2590 : 		return (_Reallocate_grow_by(_Count,

	push	0
	push	1
	mov	BYTE PTR $T117[ebp], 0
	lea	ecx, DWORD PTR __Groups$[ebp]
	push	DWORD PTR $T117[ebp]
	push	1
	call	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN637@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 787  : 				++_Group;

	inc	ebx
$LN859@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	edi, DWORD PTR __Groups$[ebp]
$LN2@Getifld:
	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN850@Getifld

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN469@Getifld
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN469@Getifld

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN470@Getifld
$LN469@Getifld:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN470@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN850@Getifld

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	$LL464@Getifld
$LN850@Getifld:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL464@Getifld
$LN29@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 796  : 			_Seendigit = false;	// trailing separator, fail

	xor	al, al
	jmp	$LN30@Getifld
$LN820@Getifld:

; 805  : 				++_Pg;	// group size okay, advance to next test
; 806  : 
; 807  : 		if (_Seendigit && !_Nonzero)

	cmp	BYTE PTR __Nonzero$1$[ebp], 0
	mov	eax, DWORD PTR __Ptr$1$[ebp]
	jne	SHORT $LN40@Getifld

; 808  : 			*_Ptr++ = '0';	// zero field, replace stripped zero(s)

	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax
	jmp	SHORT $LN40@Getifld
$LN837@Getifld:

; 809  : 		else if (!_Seendigit)
; 810  : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	eax, DWORD PTR __Ac$GSCopy$1$[ebp]
$LN40@Getifld:

; 811  : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Groups$[ebp+20]
	cmp	eax, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN744@Getifld
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	edx, DWORD PTR __Groups$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, edx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN743@Getifld

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edx-4]
	add	ecx, 35					; 00000023H
	sub	eax, edx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN797@Getifld
$LN743@Getifld:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	mov	ebx, DWORD PTR __Grouping$[ebp+20]
	add	esp, 8
	mov	esi, DWORD PTR __Grouping$[ebp]
$LN744@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ebx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN799@Getifld

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, esi

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN798@Getifld

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	esi, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H
	sub	eax, esi

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN797@Getifld
$LN798@Getifld:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN799@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 812  : 		return (_Base);

	mov	eax, DWORD PTR __Base$1$[ebp]

; 813  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN797@Getifld:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN857@Getifld:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$0:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z$1:
	lea	ecx, DWORD PTR __Groups$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getifld
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 105  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 108  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 99   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 98   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]

; 99   : 			{	// lock the stream buffer, if there

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 102  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1659 : 		{	// put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, esp
	push	esi

; 1660 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

	mov	esi, DWORD PTR __Dest$[ebp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	SHORT $LN3@Rep
	push	ebx
	mov	bl, BYTE PTR __Ch$[ebp]
$LL4@Rep:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	test	esi, esi
	je	SHORT $LN12@Rep

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [esi+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Rep
	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ecx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN16@Rep

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	BYTE PTR [edx], bl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, bl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN17@Rep
$LN16@Rep:
	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, bl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	push	eax
	call	DWORD PTR [edx+12]
$LN17@Rep:

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	mov	esi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	jne	SHORT $LN2@Rep
$LN12@Rep:

; 647  : 				_Strbuf->sputc(_Right)))
; 648  : 			_Failed = true;

	mov	BYTE PTR __Dest$[ebp], 1
$LN2@Rep:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1660 : 		for (; 0 < _Count; --_Count, (void)++_Dest)

	sub	edi, 1
	jne	SHORT $LL4@Rep
	pop	ebx
$LN3@Rep:

; 1661 : 			*_Dest = _Ch;
; 1662 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1663 : 		}

	pop	ebp
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Ch$1$ = 31						; size = 1
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1651 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp
	push	esi

; 1652 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

	mov	esi, DWORD PTR __Dest$[ebp+4]
	push	edi
	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	SHORT $LN3@Put
	push	ebx
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LL4@Put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	test	esi, esi
	je	SHORT $LN12@Put

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [esi+32]

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	mov	cl, BYTE PTR [ebx]
	mov	BYTE PTR __Ch$1$[ebp], cl

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@Put
	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN16@Put

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR __Ch$1$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN17@Put
$LN16@Put:
	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, cl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+12]
$LN17@Put:

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	mov	esi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	jne	SHORT $LN2@Put
$LN12@Put:

; 647  : 				_Strbuf->sputc(_Right)))
; 648  : 			_Failed = true;

	mov	BYTE PTR __Dest$[ebp], 1
$LN2@Put:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1652 : 		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)

	inc	ebx
	sub	edi, 1
	jne	SHORT $LL4@Put
	pop	ebx
$LN3@Put:

; 1653 : 			*_Dest = *_Ptr;
; 1654 : 		return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1655 : 		}

	pop	ebp
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -92				; size = 4
__Iosbase$GSCopy$1$ = -88				; size = 4
__Prefix$1$ = -84					; size = 4
$T7 = -80						; size = 8
$T3 = -80						; size = 8
__Punct_fac$1$ = -76					; size = 4
__Ctype_fac$1$ = -76					; size = 4
__Kseparator$42 = -76					; size = 1
$T28 = -72						; size = 8
$T26 = -72						; size = 8
$T24 = -72						; size = 8
$T23 = -72						; size = 8
$T21 = -72						; size = 8
$T19 = -72						; size = 8
$T43 = -68						; size = 4
__Buf$GSCopy$1$ = -68					; size = 4
$T12 = -68						; size = 1
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1593 : 		{	// put formatted integer to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Iosbase$[ebp]
	mov	ecx, DWORD PTR __Buf$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], edx
	mov	DWORD PTR __Buf$GSCopy$1$[ebp], ecx

; 1594 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

	test	edi, edi
	je	SHORT $LN14@Iput
	mov	al, BYTE PTR [ecx]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN13@Iput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN14@Iput
$LN13@Iput:
	mov	esi, 1
	jmp	SHORT $LN287@Iput
$LN14@Iput:
	xor	esi, esi
$LN287@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1598 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	and	eax, 3584				; 00000e00H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	DWORD PTR __Prefix$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1598 : 			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN4@Iput
	lea	eax, DWORD PTR [esi+2]
	cmp	eax, edi
	ja	SHORT $LN4@Iput
	cmp	BYTE PTR [ecx+esi], 48			; 00000030H
	jne	SHORT $LN4@Iput
	mov	cl, BYTE PTR [ecx+esi+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN5@Iput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN4@Iput
$LN5@Iput:

; 1599 : 			_Prefix += 2;

	mov	esi, eax
	mov	DWORD PTR __Prefix$1$[ebp], esi
$LN4@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [edx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ebx, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, ebx
	mov	DWORD PTR $T3[ebp+4], ebx
	mov	eax, DWORD PTR [ebx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1601 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	ebx, ebx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN32@Iput

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN32@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN32@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1602 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

	push	0
	push	edi
	lea	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1602 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1603 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	mov	ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	mov	ebx, DWORD PTR __Ctype_fac$1$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1603 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [ecx+edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	push	eax
	mov	edx, DWORD PTR [ebx]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T43[ebp], ecx
	mov	DWORD PTR $T7[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1605 : 		const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR __Punct_fac$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T43[ebp]
	test	ecx, ecx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN58@Iput

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN58@Iput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN58@Iput:

; 407  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 134  : 		return (do_grouping());

	lea	ecx, DWORD PTR __Grouping$[ebp]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	mov	ecx, ebx
	call	DWORD PTR [eax+20]

; 1606 : 		const string _Grouping = _Punct_fac.grouping();

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ebx, DWORD PTR __Grouping$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H

; 1798 : 		if (_Large_string_engaged())

	cmovae	ebx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1608 : 		if (*_Pg != CHAR_MAX && '\0' < *_Pg)

	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	je	$LN3@Iput
	test	al, al
	jle	$LN3@Iput

; 129  : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1609 : 			{	// grouping specified, add thousands separators
; 1610 : 			const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$42[ebp], al

; 1612 : 				&& (size_t)*_Pg < _Count - _Prefix)

	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	je	$LN3@Iput
	npad	5
$LL2@Iput:
	test	al, al
	jle	$LN3@Iput
	movsx	ecx, al
	mov	eax, edi
	sub	eax, esi
	cmp	ecx, eax
	jae	SHORT $LN3@Iput

; 1613 : 				{	// insert thousands separator
; 1614 : 				_Count -= *_Pg;

	sub	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1813 : 		if (_Mysize < _Off)

	mov	ecx, DWORD PTR __Groupstring$[ebp+16]
	cmp	ecx, edi
	jb	$LN280@Iput

; 2771 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR __Groupstring$[ebp+20]
	mov	eax, edx
	sub	eax, ecx

; 2772 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	eax, 1
	jb	SHORT $LN81@Iput

; 2773 : 			{
; 2774 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+1]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Groupstring$[ebp]

; 2774 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[ebp+16], eax

; 1787 : 		if (_Large_string_engaged())

	cmovae	esi, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	sub	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2776 : 			_Elem * const _Insert_at = _Old_ptr + _Off;

	add	esi, edi

; 2777 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2777 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	eax
	call	_memmove

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	ecx, BYTE PTR __Kseparator$42[ebp]

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2779 : 			return (*this);

	mov	esi, DWORD PTR __Prefix$1$[ebp]
	jmp	SHORT $LN80@Iput
$LN81@Iput:

; 2780 : 			}
; 2781 : 
; 2782 : 		return (_Reallocate_grow_by(_Count,

	push	DWORD PTR __Kseparator$42[ebp]
	mov	BYTE PTR $T12[ebp], 0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	push	1
	push	edi
	push	DWORD PTR $T12[ebp]
	push	1
	call	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN80@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1612 : 				&& (size_t)*_Pg < _Count - _Prefix)

	cmp	BYTE PTR [ebx+1], 0

; 1615 : 				_Groupstring.insert(_Count, 1, _Kseparator);
; 1616 : 				if ('\0' < _Pg[1])

	lea	eax, DWORD PTR [ebx+1]
	cmovle	eax, ebx
	mov	ebx, eax
	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Iput
$LN3@Iput:

; 1623 : 			|| (size_t)_Iosbase.width() <= _Count

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	ebx, DWORD PTR __Groupstring$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1623 : 			|| (size_t)_Iosbase.width() <= _Count

	cmp	DWORD PTR [eax+36], 0
	mov	edi, DWORD PTR [eax+32]
	jl	SHORT $LN16@Iput
	jg	SHORT $LN284@Iput
	test	edi, edi
	je	SHORT $LN16@Iput
$LN284@Iput:
	cmp	edi, ebx
	jbe	SHORT $LN16@Iput
	sub	edi, ebx
	jmp	SHORT $LN17@Iput
$LN16@Iput:
	xor	edi, edi
$LN17@Iput:

; 1624 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1625 : 
; 1626 : 		ios_base::fmtflags _Adjustfield =
; 1627 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [eax+20]
	and	eax, 448				; 000001c0H

; 1628 : 		if (_Adjustfield != ios_base::left
; 1629 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN10@Iput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN283@Iput

; 1630 : 			{	// put leading fill
; 1631 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	lea	eax, DWORD PTR $T19[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, eax

; 1632 : 			_Fillcount = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1633 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1633 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T21[ebp]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	SHORT $LN288@Iput
$LN283@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1637 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1637 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T23[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	ecx, eax

; 1638 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
	lea	eax, DWORD PTR $T24[ebp]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1639 : 			_Fillcount = 0;

	xor	edi, edi

; 1640 : 			}
; 1641 : 		else

	jmp	SHORT $LN288@Iput
$LN10@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1642 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1642 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T26[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN288@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ecx, DWORD PTR [eax]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1644 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebx, esi
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3183 : 		return (_My_data._Myptr()[_Off]);

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1644 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T28[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	DWORD PTR __Dest$[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1644 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1646 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR __Fill$[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1646 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Grouping$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1646 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN208@Iput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN207@Iput

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN260@Iput
$LN207@Iput:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN208@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groupstring$[ebp+20]

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[ebp+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR __Grouping$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN262@Iput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN261@Iput

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN260@Iput
$LN261@Iput:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN262@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1646 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, esi

; 1647 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN280@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1815 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN260@Iput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN286@Iput:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1565 : 		{	// generate sprintf format for integer

	push	ebp
	mov	ebp, esp

; 1566 : 		char *_Ptr = _Fmt;
; 1567 : 		*_Ptr++ = '%';
; 1568 : 
; 1569 : 		if (_Flags & ios_base::showpos)

	mov	eax, DWORD PTR __Flags$[ebp]
	push	esi
	mov	esi, DWORD PTR __Fmt$[ebp]
	push	edi
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	ecx, DWORD PTR [esi+1]
	test	al, 32					; 00000020H
	je	SHORT $LN2@Ifmt

; 1570 : 			*_Ptr++ = '+';

	mov	BYTE PTR [ecx], 43			; 0000002bH
	inc	ecx
$LN2@Ifmt:

; 1571 : 		if (_Flags & ios_base::showbase)

	test	al, 8
	je	SHORT $LN3@Ifmt

; 1572 : 			*_Ptr++ = '#';

	mov	BYTE PTR [ecx], 35			; 00000023H
	inc	ecx
$LN3@Ifmt:

; 1573 : 		if (_Spec[0] != 'L')

	mov	edi, DWORD PTR __Spec$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	push	ebx
	mov	bl, BYTE PTR [edi]
	cmp	bl, 76					; 0000004cH
	je	SHORT $LN4@Ifmt

; 1574 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	BYTE PTR [ecx], bl

; 1575 : 		else

	jmp	SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1576 : 
; 1577 : 			{	/* change L to I64 */
; 1578 : 			*_Ptr++ = 'I';

	mov	BYTE PTR [ecx], 73			; 00000049H

; 1579 : 			*_Ptr++ = '6';

	mov	WORD PTR [edx], 13366			; 00003436H

; 1580 : 			*_Ptr++ = '4';

	add	edx, 2
$LN5@Ifmt:

; 1581 : 			}
; 1582 : 
; 1583 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	ecx, eax
	and	ecx, 3584				; 00000e00H
	pop	ebx

; 1584 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 1024				; 00000400H
	jne	SHORT $LN9@Ifmt
	mov	al, 111					; 0000006fH
	mov	BYTE PTR [edx], al

; 1585 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1586 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1587 : 		*_Ptr = '\0';
; 1588 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1589 : 		}

	pop	ebp
	ret	0
$LN9@Ifmt:

; 1584 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

	cmp	ecx, 2048				; 00000800H
	je	SHORT $LN7@Ifmt
	mov	al, BYTE PTR [edi+1]
	mov	BYTE PTR [edx], al

; 1585 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1586 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1587 : 		*_Ptr = '\0';
; 1588 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1589 : 		}

	pop	ebp
	ret	0
$LN7@Ifmt:

; 1584 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'

	shl	al, 3
	not	al
	and	al, 32					; 00000020H
	or	al, 88					; 00000058H
	mov	BYTE PTR [edx], al

; 1585 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1586 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';
; 1587 : 		*_Ptr = '\0';
; 1588 : 		return (_Fmt);

	mov	eax, esi
	pop	edi
	mov	BYTE PTR [edx+1], 0
	pop	esi

; 1589 : 		}

	pop	ebp
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$1$ = -112				; size = 4
$T30 = -108						; size = 8
$T44 = -104						; size = 4
__Buf$GSCopy$1$ = -104					; size = 4
$T7 = -100						; size = 8
$T45 = -96						; size = 4
__Kseparator$ = -96					; size = 1
__Prefix$1$ = -92					; size = 4
$T28 = -88						; size = 8
$T26 = -88						; size = 8
$T25 = -88						; size = 8
$T23 = -88						; size = 8
$T21 = -88						; size = 8
__Eoff$1$ = -84						; size = 4
$T14 = -84						; size = 1
__Iosbase$GSCopy$1$ = -80				; size = 4
$T3 = -76						; size = 8
__Punct_fac$1$ = -72					; size = 4
__Ctype_fac$1$ = -72					; size = 4
__Dp$ = -68						; size = 2
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1493 : 		{	// put formatted floating-point to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	mov	edi, DWORD PTR __Buf$[ebp]
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], eax
	mov	DWORD PTR __Iosbase$GSCopy$1$[ebp], ecx
	mov	DWORD PTR __Buf$GSCopy$1$[ebp], edi

; 1494 : 		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')

	test	ebx, ebx
	je	SHORT $LN16@Fput
	mov	al, BYTE PTR [edi]
	cmp	al, 43					; 0000002bH
	je	SHORT $LN15@Fput
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN16@Fput
$LN15@Fput:
	mov	esi, 1
	jmp	SHORT $LN305@Fput
$LN16@Fput:
	xor	esi, esi
$LN305@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1498 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

	and	eax, 12288				; 00003000H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	DWORD PTR __Prefix$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1498 : 		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)

	cmp	eax, 12288				; 00003000H
	je	SHORT $LN4@Fput

; 1499 : 			_Exps = "eE";

	mov	edx, OFFSET ??_C@_02MDKMJEGG@eE?$AA@

; 1500 : 		else

	jmp	SHORT $LN6@Fput
$LN4@Fput:

; 1501 : 			{	// correct for hexadecimal floating-point
; 1502 : 			_Exps = "pP";
; 1503 : 			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1504 : 				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))

	lea	eax, DWORD PTR [esi+2]
	mov	edx, OFFSET ??_C@_02OOPEBDOJ@pP?$AA@
	cmp	eax, ebx
	ja	SHORT $LN6@Fput
	cmp	BYTE PTR [edi+esi], 48			; 00000030H
	jne	SHORT $LN6@Fput
	mov	cl, BYTE PTR [edi+esi+1]
	cmp	cl, 120					; 00000078H
	je	SHORT $LN7@Fput
	cmp	cl, 88					; 00000058H
	jne	SHORT $LN6@Fput
$LN7@Fput:

; 1505 : 				_Prefix += 2;

	mov	esi, eax
	mov	DWORD PTR __Prefix$1$[ebp], esi
$LN6@Fput:

; 1506 : 			}
; 1507 : 		const size_t _Eoff =
; 1508 : 			_CSTD strcspn(&_Buf[0], _Exps);	// find exponent

	push	edx
	push	edi
	call	_strcspn
	mov	DWORD PTR __Eoff$1$[ebp], eax

; 1509 : 		char _Dp[2] = {"."};

	mov	eax, 46					; 0000002eH
	mov	WORD PTR __Dp$[ebp], ax

; 1510 : 		_Dp[0] = _CSTD localeconv()->decimal_point[0];

	call	_localeconv
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR __Dp$[ebp], al

; 1511 : 		const size_t _Poff =
; 1512 : 			_CSTD strcspn(&_Buf[0], &_Dp[0]);	// find decimal point

	lea	eax, DWORD PTR __Dp$[ebp]
	push	eax
	push	edi
	call	_strcspn
	mov	edi, eax
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T45[ebp], ecx
	mov	DWORD PTR $T3[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1514 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T45[ebp]
	test	ecx, ecx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN34@Fput

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN34@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN34@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1515 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

	push	0
	push	ebx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 407  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1515 : 		_Mystr _Groupstring(_Count, _Elem(0));	// reserve space

	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1516 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	mov	ecx, DWORD PTR __Buf$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	mov	edx, DWORD PTR __Ctype_fac$1$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1516 : 		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	push	eax
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR __Ctype_fac$1$[ebp]
	call	DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	ecx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T44[ebp], ecx
	mov	DWORD PTR $T7[ebp+4], ecx

; 300  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1518 : 		const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T7[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR __Punct_fac$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T44[ebp]
	test	edx, edx

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN60@Fput

; 406  : 			delete _Ptr->_Decref();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+8]
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN302@Fput
	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN302@Fput:

; 407  : 		}

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN60@Fput:
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 134  : 		return (do_grouping());

	lea	edx, DWORD PTR __Grouping$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+20]

; 1519 : 		const string _Grouping = _Punct_fac.grouping();

	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 129  : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1520 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	BYTE PTR __Kseparator$[ebp], al

; 1521 : 
; 1522 : 		if (_Poff != _Count)

	cmp	edi, ebx
	je	SHORT $LN306@Fput

; 124  : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 124  : 		return (do_decimal_point());

	mov	cl, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1525 : 		size_t _Off = _Poff == _Count ? _Eoff : _Poff;

	cmp	edi, ebx
	mov	BYTE PTR [eax+edi], cl
$LN306@Fput:
	cmove	edi, DWORD PTR __Eoff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ebx, DWORD PTR __Grouping$[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H

; 1798 : 		if (_Large_string_engaged())

	cmovae	ebx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1528 : 			&& (size_t)*_Pg < _Off - _Prefix)

	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	je	$LN3@Fput
$LL2@Fput:
	test	al, al
	jle	$LN3@Fput
	movsx	ecx, al
	mov	eax, edi
	sub	eax, esi
	cmp	ecx, eax
	jae	SHORT $LN3@Fput

; 1529 : 			{	// add thousands separator
; 1530 : 			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);

	sub	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1813 : 		if (_Mysize < _Off)

	mov	ecx, DWORD PTR __Groupstring$[ebp+16]
	cmp	ecx, edi
	jb	$LN297@Fput

; 2771 : 		const size_type _Old_size = _My_data._Mysize;

	mov	edx, DWORD PTR __Groupstring$[ebp+20]
	mov	eax, edx
	sub	eax, ecx

; 2772 : 		if (_Count <= _My_data._Myres - _Old_size)

	cmp	eax, 1
	jb	SHORT $LN98@Fput

; 2773 : 			{
; 2774 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+1]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	esi, DWORD PTR __Groupstring$[ebp]

; 2774 : 			_My_data._Mysize = _Old_size + _Count;

	mov	DWORD PTR __Groupstring$[ebp+16], eax

; 1787 : 		if (_Large_string_engaged())

	cmovae	esi, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	sub	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2776 : 			_Elem * const _Insert_at = _Old_ptr + _Off;

	add	esi, edi

; 2777 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2777 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	eax
	call	_memmove

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	ecx, BYTE PTR __Kseparator$[ebp]

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movzx	eax, cl
	shl	cx, 8
	or	cx, ax
	mov	BYTE PTR [esi], cl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2779 : 			return (*this);

	mov	esi, DWORD PTR __Prefix$1$[ebp]
	jmp	SHORT $LN97@Fput
$LN98@Fput:

; 2780 : 			}
; 2781 : 
; 2782 : 		return (_Reallocate_grow_by(_Count,

	push	DWORD PTR __Kseparator$[ebp]
	mov	BYTE PTR $T14[ebp], 0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	push	1
	push	edi
	push	DWORD PTR $T14[ebp]
	push	1
	call	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN97@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1528 : 			&& (size_t)*_Pg < _Off - _Prefix)

	cmp	BYTE PTR [ebx+1], 0

; 1531 : 			if ('\0' < _Pg[1])

	lea	eax, DWORD PTR [ebx+1]
	cmovle	eax, ebx
	mov	ebx, eax
	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	jne	$LL2@Fput
$LN3@Fput:

; 1537 : 			|| (size_t)_Iosbase.width() <= _Count

	mov	eax, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3275 : 		return (this->_Get_data()._Mysize);

	mov	ebx, DWORD PTR __Groupstring$[ebp+16]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1537 : 			|| (size_t)_Iosbase.width() <= _Count

	cmp	DWORD PTR [eax+36], 0
	mov	edi, DWORD PTR [eax+32]
	jl	SHORT $LN18@Fput
	jg	SHORT $LN301@Fput
	test	edi, edi
	je	SHORT $LN18@Fput
$LN301@Fput:
	cmp	edi, ebx
	jbe	SHORT $LN18@Fput
	sub	edi, ebx
	jmp	SHORT $LN19@Fput
$LN18@Fput:
	xor	edi, edi
$LN19@Fput:

; 1538 : 				? 0 : (size_t)_Iosbase.width() - _Count;
; 1539 : 
; 1540 : 		ios_base::fmtflags _Adjustfield =
; 1541 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	eax, DWORD PTR [eax+20]
	and	eax, 448				; 000001c0H

; 1542 : 		if (_Adjustfield != ios_base::left
; 1543 : 			&& _Adjustfield != ios_base::internal)

	cmp	eax, 64					; 00000040H
	je	$LN12@Fput
	cmp	eax, 256				; 00000100H
	je	SHORT $LN300@Fput

; 1544 : 			{	// put leading fill
; 1545 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	lea	eax, DWORD PTR $T21[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	mov	ecx, eax

; 1546 : 			_Fillcount = 0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1547 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1547 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR [ecx+4]
	lea	eax, DWORD PTR $T23[ebp]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 48					; 00000030H
	jmp	SHORT $LN307@Fput
$LN300@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1551 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1551 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T25[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	mov	ecx, eax

; 1552 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	push	edi
	push	DWORD PTR __Fill$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Dest$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Dest$[ebp+4], eax
	lea	eax, DWORD PTR $T26[ebp]
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 48					; 00000030H

; 1553 : 			_Fillcount = 0;

	xor	edi, edi

; 1554 : 			}
; 1555 : 		else

	jmp	SHORT $LN307@Fput
$LN12@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1556 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1556 : 			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

	push	eax
	push	DWORD PTR __Dest$[ebp+4]
	lea	eax, DWORD PTR $T28[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	eax
	push	DWORD PTR _this$[ebp]
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
$LN307@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ecx, DWORD PTR [eax]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groupstring$[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR __Groupstring$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1558 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	sub	ebx, esi
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3183 : 		return (_My_data._Myptr()[_Off]);

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1558 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	edx
	push	ecx
	lea	eax, DWORD PTR $T30[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	DWORD PTR __Dest$[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1558 : 		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

	push	eax
	push	ebx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR __Iosbase$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1560 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	esi, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR __Fill$[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	ecx
	push	esi
	push	ebx
	mov	DWORD PTR __Dest$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1560 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Grouping$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1560 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN225@Fput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN224@Fput

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN277@Fput
$LN224@Fput:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN225@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groupstring$[ebp+20]

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR __Grouping$[ebp+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Grouping$[ebp+20], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR __Grouping$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN279@Fput
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groupstring$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN278@Fput

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN277@Fput
$LN278@Fput:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN279@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1560 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, esi

; 1561 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN297@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1815 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN277@Fput:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN304@Fput:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$1:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$2:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z$3:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1463 : 		{	// generate sprintf format for floating-point

	push	ebp
	mov	ebp, esp

; 1464 : 		char *_Ptr = _Fmt;
; 1465 : 		*_Ptr++ = '%';
; 1466 : 
; 1467 : 		if (_Flags & ios_base::showpos)

	mov	edx, DWORD PTR __Flags$[ebp]
	push	esi
	mov	esi, DWORD PTR __Fmt$[ebp]
	mov	BYTE PTR [esi], 37			; 00000025H
	lea	eax, DWORD PTR [esi+1]
	test	dl, 32					; 00000020H
	je	SHORT $LN2@Ffmt

; 1468 : 			*_Ptr++ = '+';

	mov	BYTE PTR [eax], 43			; 0000002bH
	inc	eax
$LN2@Ffmt:

; 1469 : 		if (_Flags & ios_base::showpoint)

	test	dl, 16					; 00000010H
	je	SHORT $LN3@Ffmt

; 1470 : 			*_Ptr++ = '#';

	mov	BYTE PTR [eax], 35			; 00000023H
	inc	eax
$LN3@Ffmt:

; 1471 : 		*_Ptr++ = '.';
; 1472 : 		*_Ptr++ = '*';	// for precision argument
; 1473 : 		if (_Spec != '\0')

	mov	cl, BYTE PTR __Spec$[ebp]
	mov	WORD PTR [eax], 10798			; 00002a2eH
	add	eax, 2
	test	cl, cl
	je	SHORT $LN4@Ffmt

; 1474 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	BYTE PTR [eax], cl
	inc	eax
$LN4@Ffmt:

; 1475 : 
; 1476 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	ecx, edx
	and	ecx, 12288				; 00003000H

; 1477 : 		if (_Flags & ios_base::uppercase)

	test	dl, 4
	je	SHORT $LN5@Ffmt

; 1478 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN16@Ffmt
	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN8@Ffmt
	mov	cl, 65					; 00000041H

; 1483 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1484 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1485 : 
; 1486 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1487 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1488 : 		}

	pop	ebp
	ret	0
$LN8@Ffmt:

; 1478 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+69]

; 1483 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1484 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1485 : 
; 1486 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1487 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1488 : 		}

	pop	ebp
	ret	0
$LN5@Ffmt:

; 1479 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1480 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1481 : 		else
; 1482 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	ecx, 8192				; 00002000H
	jne	SHORT $LN14@Ffmt
$LN16@Ffmt:

; 1483 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1484 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1485 : 
; 1486 : 		*_Ptr = '\0';

	mov	cl, 102					; 00000066H
	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1487 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1488 : 		}

	pop	ebp
	ret	0
$LN14@Ffmt:

; 1479 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1480 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1481 : 		else
; 1482 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	ecx, 12288				; 00003000H
	jne	SHORT $LN12@Ffmt
	mov	cl, 97					; 00000061H

; 1483 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1484 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1485 : 
; 1486 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1487 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1488 : 		}

	pop	ebp
	ret	0
$LN12@Ffmt:

; 1479 : 				: _Ffl == ios_base::hexfloat ? 'A'	// added with TR1
; 1480 : 				: _Ffl == ios_base::scientific ? 'E' : 'G';	// specifier
; 1481 : 		else
; 1482 : 			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'

	cmp	ecx, 4096				; 00001000H
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+101]

; 1483 : 				: _Ffl == ios_base::hexfloat ? 'a'	// added with TR1
; 1484 : 				: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier
; 1485 : 
; 1486 : 		*_Ptr = '\0';

	mov	BYTE PTR [eax], cl
	mov	BYTE PTR [eax+1], 0

; 1487 : 		return (_Fmt);

	mov	eax, esi
	pop	esi

; 1488 : 		}

	pop	ebp
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 355  : 		return (_Myval2);

	mov	eax, ecx

; 356  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 350  : 		return (_Myval2);

	mov	eax, ecx

; 351  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 335  : 		return (*this);

	mov	eax, ecx

; 336  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 330  : 		return (*this);

	mov	eax, ecx

; 331  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 931  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

	or	eax, -1

; 932  : 		}

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
$T39 = 12						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2639 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2640 : 		auto& _My_data = this->_Get_data();
; 2641 : 		if (_Count <= _My_data._Myres)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR __Old$1$[ebp], ecx
	cmp	edi, ecx
	ja	SHORT $LN2@assign

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	ebx, esi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@assign
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
$LN9@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	edi
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2644 : 			_My_data._Mysize = _Count;

	mov	DWORD PTR [esi+16], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2654 : 		}

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:

; 3863 : 		if (_New_size > max_size())

	cmp	edi, 2147483647				; 7fffffffH
	ja	$LN123@assign

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	ebx, edi
	or	ebx, 15					; 0000000fH
	cmp	ebx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN43@assign

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN43@assign:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN44@assign

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@assign
$LN44@assign:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN75@assign

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 102  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	SHORT $LN106@assign

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN121@assign
$LN75@assign:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN76@assign

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	jmp	SHORT $LN121@assign
$LN76@assign:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	eax, eax
$LN121@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
	push	DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR $T39[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [esi+16], edi

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [esi+20], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	call	_memcpy

; 489  : 		_Left = _Right;

	mov	ebx, DWORD PTR $T39[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	eax, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN21@assign

; 3878 : 			{
; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN107@assign

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN106@assign

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN107@assign:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN21@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2650 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	mov	DWORD PTR [esi], ebx

; 2654 : 		}

	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN106@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN123@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN119@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$dead$ = ecx

; 2650 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2650 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	edi, DWORD PTR __Count$[ebp]
	push	edi
	push	DWORD PTR __Ptr$[ebp]
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2653 : 			}, _Ptr));

	pop	ebp
	ret	12					; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBE@QADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2513 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp
	push	esi

; 2514 : 		push_back(_Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	esi, ecx
	call	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 2515 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2516 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T5 = 8							; size = 1
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2494 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	eax, DWORD PTR __Right$[ebp]

; 2494 : 		{	// append _Right

	push	ebx
	push	esi
	push	edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2494 : 		{	// append _Right

	mov	edi, ecx

; 1797 : 		const value_type * _Result = _Bx._Buf;

	mov	ecx, eax

; 1798 : 		if (_Large_string_engaged())

	jb	SHORT $LN10@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [eax]
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2521 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

	mov	ebx, DWORD PTR [eax+16]

; 2554 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	esi, DWORD PTR [edi+20]
	mov	eax, esi
	mov	edx, DWORD PTR [edi+16]
	sub	eax, edx
	cmp	ebx, eax
	ja	SHORT $LN17@operator

; 2555 : 			{
; 2556 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [edx+ebx]
	mov	DWORD PTR [edi+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN24@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
$LN24@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2558 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	esi, DWORD PTR [eax+edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2495 : 		return (append(_Right));

	mov	eax, edi
	pop	edi

; 2496 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
$LN17@operator:

; 2563 : 		return (_Reallocate_grow_by(_Count,

	push	ebx
	push	ecx
	mov	BYTE PTR $T5[ebp], 0
	mov	ecx, edi
	push	DWORD PTR $T5[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
	pop	edi

; 2496 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2298 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2285 : 		if (this != _STD addressof(_Right))

	mov	edi, DWORD PTR __Right$[ebp]

; 2298 : 		{	// assign by moving _Right

	mov	esi, ecx

; 2285 : 		if (this != _STD addressof(_Right))

	cmp	esi, edi
	je	SHORT $LN93@assign

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN44@assign
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN43@assign

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN42@assign

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN43@assign:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN44@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
$LN93@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2300 : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 2301 : 		}

	pop	ebp
	ret	4
$LN42@assign:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN95@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$8 = -20						; size = 8
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 578  : 		{	// flush output stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 579  : 		if (_Myios::rdbuf() != 0)

	cmp	DWORD PTR [eax+esi+56], 0
	je	SHORT $LN46@flush

; 580  : 			{	// buffer exists, flush it
; 581  : 			const sentry _Ok(*this);

	push	esi
	lea	ecx, DWORD PTR __Ok$8[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 583  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

	cmp	BYTE PTR __Ok$8[ebp+4], 0
	je	SHORT $LN15@flush
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 143  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 583  : 			if (_Ok && _Myios::rdbuf()->pubsync() == -1)

	cmp	eax, -1
	jne	SHORT $LN15@flush

; 584  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 584  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, DWORD PTR [ecx+esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 584  : 				_Myios::setstate(ios_base::badbit);	// sync failed

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	or	eax, 4
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN15@flush:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	test	al, al
	jne	SHORT $LN34@flush

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR __Ok$8[ebp]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN34@flush:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR __Ok$8[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN46@flush

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN46@flush:

; 585  : 			}
; 586  : 		return (*this);
; 587  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:
	lea	ecx, DWORD PTR __Ok$8[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 176  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx

; 177  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 178  : 		if (this->good() && this->flags() & ios_base::unitbuf)

	jne	SHORT $LN21@Osfx
	test	BYTE PTR [eax+esi+20], 2
	je	SHORT $LN21@Osfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 143  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+52]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 179  : 			if (_Myios::rdbuf()->pubsync() == -1)	// flush stream as needed

	cmp	eax, -1
	jne	SHORT $LN21@Osfx

; 180  : 				_Myios::setstate(ios_base::badbit);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 180  : 				_Myios::setstate(ios_base::badbit);

	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, DWORD PTR [ecx+esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 180  : 				_Myios::setstate(ios_base::badbit);

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	or	eax, 4
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN21@Osfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 183  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 181  : 		_CATCH_ALL
; 182  : 		_CATCH_END

	mov	eax, $LN21@Osfx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T5 = -32						; size = 8
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Noskip$dead$ = 8					; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 132  : 		{	// test stream state and skip whitespace as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 133  : 		if (this->good())

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 133  : 		if (this->good())

	jne	$LN12@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+edi+60]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 135  : 			if (_Myios::tie() != 0)

	test	eax, eax
	je	SHORT $LN172@Ipfx

; 136  : 				_Myios::tie()->flush();

	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	ecx, DWORD PTR [edi]
$LN172@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 138  : 			if (!_Noskip && this->flags() & ios_base::skipws)

	test	BYTE PTR [eax+edi+20], 1
	je	$LN17@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [eax+edi+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	esi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, esi
	mov	DWORD PTR $T5[ebp+4], esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 140  : 				const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	test	esi, esi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN37@Ipfx

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN37@Ipfx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN37@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 142  : 				_TRY_IO_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN44@Ipfx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN44@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LL4@Ipfx
$LN44@Ipfx:
	mov	eax, DWORD PTR [ecx]
$LN174@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 146  : 					if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	call	DWORD PTR [eax+24]
$LL4@Ipfx:
	cmp	eax, -1
	jne	SHORT $LN9@Ipfx

; 148  : 						_Myios::setstate(ios_base::eofbit);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 148  : 						_Myios::setstate(ios_base::eofbit);

	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 148  : 						_Myios::setstate(ios_base::eofbit);

	add	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [ecx+56], eax
	sete	al
	lea	eax, DWORD PTR [eax*4+1]
	or	eax, DWORD PTR [ecx+12]
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 149  : 						break;

	jmp	$LN3@Ipfx
$LN9@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2338 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

	movzx	ecx, al
	mov	eax, DWORD PTR [ebx+12]
	test	BYTE PTR [eax+ecx*2], 72		; 00000048H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 151  : 					else if (!_Ctype_fac.is(_Ctype::space,

	je	$LN3@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN64@Ipfx
	mov	eax, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN65@Ipfx
$LN64@Ipfx:
	xor	eax, eax
$LN65@Ipfx:

; 166  : 		return (1 < _Gnavail()

	cmp	eax, 1
	jle	SHORT $LN60@Ipfx

; 275  : 		--*_IGcount;

	mov	eax, DWORD PTR [esi+44]
	dec	DWORD PTR [eax]

; 276  : 		return (++(*_IGnext));

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	inc	ecx
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 166  : 		return (1 < _Gnavail()

	jmp	SHORT $LL4@Ipfx
$LN60@Ipfx:

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	test	ecx, ecx
	je	SHORT $LN72@Ipfx
	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [ecx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN72@Ipfx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN73@Ipfx
$LN72@Ipfx:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+28]
$LN73@Ipfx:

; 166  : 		return (1 < _Gnavail()

	cmp	eax, -1
	jne	SHORT $LN58@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 524  : 		return (EOF);

	or	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 166  : 		return (1 < _Gnavail()

	jmp	$LL4@Ipfx
$LN58@Ipfx:

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN90@Ipfx
	mov	eax, DWORD PTR [esi+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN90@Ipfx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LL4@Ipfx
$LN90@Ipfx:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 145  : 				for (; ; _Meta = _Myios::rdbuf()->snextc())

	jmp	$LN174@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 154  : 				_CATCH_IO_END

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 154  : 				_CATCH_IO_END

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN134@Ipfx
	or	eax, 4
$LN134@Ipfx:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 154  : 				_CATCH_IO_END

	mov	eax, $LN18@Ipfx
	ret	0
$LN18@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	edi, DWORD PTR _this$[ebp]
$LN3@Ipfx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 157  : 			if (this->good())

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:
	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [ecx+4]
	cmp	DWORD PTR [eax+edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 157  : 			if (this->good())

	jne	SHORT $LN12@Ipfx

; 158  : 				return (true);

	mov	al, 1

; 162  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@Ipfx:

; 160  : 		_Myios::setstate(ios_base::failbit);

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 160  : 		_Myios::setstate(ios_base::failbit);

	add	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	push	0
	cmp	DWORD PTR [ecx+56], eax
	sete	al
	lea	eax, DWORD PTR [eax*4+2]
	or	eax, DWORD PTR [ecx+12]
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\istream

; 161  : 		return (false);

	xor	al, al

; 162  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 79   : 		return (_Tiestr);

	mov	eax, DWORD PTR [ecx+60]

; 80   : 		}

	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 43   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	edx, DWORD PTR __State$[ebp]
	push	DWORD PTR __Reraise$[ebp]
	or	edx, 4
	cmp	DWORD PTR [ecx+56], 0
	cmovne	edx, DWORD PTR __State$[ebp]
	push	edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 45   : 			? (int)_State | (int)badbit : (int)_State), _Reraise);
; 46   : 		}

	pop	ebp
	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 175  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 257  : 		_CSTD free((void *)_Grouping);

	push	DWORD PTR [esi+8]

; 175  : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@

; 257  : 		_CSTD free((void *)_Grouping);

	call	_free

; 258  : 		_CSTD free((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 259  : 		_CSTD free((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xfacet

; 26   : 		{	// ensure that derived classes can be destroyed properly

	mov	DWORD PTR [esi], OFFSET ??_7_Facet_base@std@@6B@
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN14@scalar
	push	24					; 00000018H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN14@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 256  : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 257  : 		_CSTD free((void *)_Grouping);

	push	DWORD PTR [esi+8]
	call	_free

; 258  : 		_CSTD free((void *)_Falsename);

	push	DWORD PTR [esi+16]
	call	_free

; 259  : 		_CSTD free((void *)_Truename);

	push	DWORD PTR [esi+20]
	call	_free
	add	esp, 12					; 0000000cH
	pop	esi

; 260  : 		}

	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 133  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp

; 134  : 		return (do_grouping());

	mov	edx, DWORD PTR [ecx]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR [edx+20]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 		}

	pop	ebp
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 129  : 		return (do_thousands_sep());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	jmp	eax
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 124  : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	jmp	eax
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
_TEXT	SEGMENT
$T5 = -148						; size = 8
$T2 = -148						; size = 8
__Pg$1$ = -144						; size = 4
__Phexexp$GSCopy$1$ = -140				; size = 4
__Ac$GSCopy$1$ = -136					; size = 4
__Punct_fac$1$ = -132					; size = 4
__Max_sig_dig$1$ = -128					; size = 4
__Significant$2$ = -128					; size = 4
__Significant$1$ = -124					; size = 4
__Phex$1$ = -120					; size = 4
__Kseparator$1$ = -113					; size = 1
__Last$GSCopy$1$ = -112					; size = 4
__Bad$1$ = -105						; size = 1
__Ptr$1$ = -104						; size = 4
__Seendigit$1$ = -97					; size = 1
__Grouping$ = -96					; size = 24
__Groups$324 = -72					; size = 24
__Atoms$ = -48						; size = 29
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Ac$ = 12						; size = 4
__First$ = 16						; size = 4
__Last$ = 20						; size = 4
__Iosbase$ = 24						; size = 4
__Phexexp$ = 28						; size = 4
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx, COMDAT

; 1031 : 		{	// get hex floating-point field from [_First, _Last) into _Ac

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR __Ac$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	ebx, DWORD PTR __Iosbase$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1031 : 		{	// get hex floating-point field from [_First, _Last) into _Ac

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Ac$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR __Phexexp$[ebp]
	mov	DWORD PTR __Phexexp$GSCopy$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1031 : 		{	// get hex floating-point field from [_First, _Last) into _Ac

	mov	DWORD PTR __Last$GSCopy$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, edi
	mov	DWORD PTR $T2[ebp+4], edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1032 : 		const _Mypunct& _Punct_fac = _STD use_facet<_Mypunct>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR __Punct_fac$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	edi, edi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN92@Getffldx

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN2014@Getffldx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN2014@Getffldx:

; 407  : 		}

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
$LN92@Getffldx:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 134  : 		return (do_grouping());

	lea	edx, DWORD PTR __Grouping$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+20]

; 1033 : 		const string _Grouping = _Punct_fac.grouping();

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 435  : 		return (*_Ploc);

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 299  : 		{	// construct by copying

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edi, DWORD PTR [eax+4]

; 300  : 		_Ptr->_Incref();

	mov	ecx, edi
	mov	DWORD PTR $T5[ebp+4], edi
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1041 : 		const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

	lea	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 404  : 		{	// destroy the object

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	test	edi, edi

; 405  : 		if (_Ptr != 0)

	je	SHORT $LN107@Getffldx

; 406  : 			delete _Ptr->_Decref();

	mov	edx, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [edx+8]
	test	eax, eax
	je	SHORT $LN107@Getffldx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx]
$LN107@Getffldx:

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	lea	ecx, DWORD PTR __Atoms$[ebp]

; 407  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2396 : 		return (do_widen(_First, _Last, _Dest));

	mov	eax, DWORD PTR [ebx]
	push	ecx
	push	OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB+29
	push	OFFSET ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB ; `std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx'::`2'::_Src
	mov	ecx, ebx
	call	DWORD PTR [eax+28]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1044 : 		char *_Ptr = _Ac;

	mov	ebx, DWORD PTR __Ac$GSCopy$1$[ebp]

; 1045 : 		bool _Bad = false;

	mov	BYTE PTR __Bad$1$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN115@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN125@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN129@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN129@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN130@Getffldx
$LN129@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN130@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN125@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN124@Getffldx
$LN125@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN124@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN115@Getffldx:

; 551  : 		if (!_Right._Got)

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN116@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN148@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN152@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN152@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN153@Getffldx
$LN152@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN153@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN148@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN147@Getffldx
$LN148@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN147@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN116@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1898@Getffldx
	test	eax, eax
	je	$LN247@Getffldx
	jmp	SHORT $LN1850@Getffldx
$LN1898@Getffldx:
	test	eax, eax
	jne	$LN247@Getffldx
$LN1850@Getffldx:

; 512  : 		if (!_Got)

	mov	dl, BYTE PTR [esi+4]
	test	dl, dl
	jne	SHORT $LN169@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN174@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN178@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN178@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN179@Getffldx
$LN178@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [esi]
$LN179@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN174@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN173@Getffldx
$LN174@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN173@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	dl, 1
$LN169@Getffldx:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1050 : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN24@Getffldx

; 1051 : 			{	// gather plus sign
; 1052 : 			*_Ptr++ = '+';

	mov	eax, ebx
	mov	BYTE PTR [eax], 43			; 0000002bH
	lea	ebx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN199@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN203@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN203@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN204@Getffldx
$LN203@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN204@Getffldx:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN199@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1055 : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN247@Getffldx
$LN199@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1055 : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN247@Getffldx
$LN24@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	dl, dl
	jne	SHORT $LN218@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN223@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN227@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN227@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN228@Getffldx
$LN227@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN228@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN1849@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN222@Getffldx
$LN1849@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+5]
$LN223@Getffldx:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN222@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN218@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1055 : 		else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN247@Getffldx

; 1056 : 			{	// gather minus sign
; 1057 : 			*_Ptr++ = '-';

	mov	eax, ebx
	mov	BYTE PTR [eax], 45			; 0000002dH
	lea	ebx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN248@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN252@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN252@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN253@Getffldx
$LN252@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN253@Getffldx:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN248@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN247@Getffldx
$LN248@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN247@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1061 : 		*_Ptr++ = '0';

	mov	WORD PTR [ebx], 30768			; 00007830H

; 1062 : 		*_Ptr++ = 'x';
; 1063 : 
; 1064 : 		bool _Seendigit = false;	// seen a digit in input
; 1065 : 		int _Significant = 0;	// number of significant digits

	xor	eax, eax
	add	ebx, 2
	mov	DWORD PTR __Significant$1$[ebp], eax
	mov	DWORD PTR __Ptr$1$[ebp], ebx
	xor	bl, bl
	mov	BYTE PTR __Seendigit$1$[ebp], bl

; 1066 : 		int _Phex = 0;	// power of 10 multiplier

	mov	DWORD PTR __Phex$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], al
	jne	SHORT $LN269@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN279@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN283@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN283@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN284@Getffldx
$LN283@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN284@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN279@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN278@Getffldx
$LN279@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN278@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN269@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN270@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN302@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN306@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN306@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN307@Getffldx
$LN306@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN307@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN302@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN301@Getffldx
$LN302@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN301@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN270@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1897@Getffldx
	test	eax, eax
	je	$LN1986@Getffldx
	jmp	SHORT $LN1852@Getffldx
$LN1897@Getffldx:
	test	eax, eax
	jne	$LN1986@Getffldx
$LN1852@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN323@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN328@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1938@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1938@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN333@Getffldx
$LN1938@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN333@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN328@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN327@Getffldx
$LN328@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN327@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN323@Getffldx:

; 522  : 		return (_Val);

	mov	al, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1068 : 		if (_First == _Last || *_First != _Atoms[0])

	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	$LN1986@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1984@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN357@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN357@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN358@Getffldx
$LN357@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN358@Getffldx:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN1984@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
	jmp	SHORT $LN352@Getffldx
$LN1984@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
$LN352@Getffldx:

; 549  : 		if (!_Got)

	mov	BYTE PTR [esi+4], al
	test	al, al
	jne	SHORT $LN1854@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN386@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN390@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN390@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN391@Getffldx
$LN390@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN391@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN386@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN385@Getffldx
$LN386@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN385@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1854@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN377@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN409@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN413@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN413@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN414@Getffldx
$LN413@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN414@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN409@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN408@Getffldx
$LN409@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN408@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN377@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1896@Getffldx
	test	eax, eax
	jne	SHORT $LN380@Getffldx
$LN30@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1075 : 			_Seendigit = true;	// '0' not followed by 'x' or 'X'

	mov	BYTE PTR __Seendigit$1$[ebp], 1
$LN1986@Getffldx:

; 1077 : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	ecx, DWORD PTR __Phexexp$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1797 : 		const value_type * _Result = _Bx._Buf;

	lea	ebx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1077 : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	eax, 36					; 00000024H
	mov	edx, 768				; 00000300H
	cmp	DWORD PTR [ecx], 1000000000		; 3b9aca00H
	cmove	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Grouping$[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1077 : 		const int _Max_sig_dig = (*_Phexexp == _ENABLE_V2_BEHAVIOR ? _MAX_SIG_DIG_V2 : _MAX_SIG_DIG_V1);

	mov	DWORD PTR __Max_sig_dig$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1798 : 		if (_Large_string_engaged())

	cmovae	ebx, DWORD PTR __Grouping$[ebp]
	mov	DWORD PTR __Pg$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1080 : 		if (*_Pg == CHAR_MAX || *_Pg <= '\0')

	mov	al, BYTE PTR [ebx]
	cmp	al, 127					; 0000007fH
	je	$LL1976@Getffldx
	test	al, al
	jle	$LL1976@Getffldx

; 1092 : 					}
; 1093 : 		else
; 1094 : 			{	// grouping specified, gather digits and group sizes
; 1095 : 			const _Elem _Kseparator = _Grouping.size() == 0

	cmp	DWORD PTR __Grouping$[ebp+16], 0
	jne	$LN78@Getffldx
	mov	BYTE PTR __Kseparator$1$[ebp], 0
	jmp	$LN79@Getffldx
$LN1896@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN30@Getffldx
$LN380@Getffldx:

; 512  : 		if (!_Got)

	mov	al, BYTE PTR [esi+4]
	test	al, al
	jne	SHORT $LN430@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN435@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1939@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1939@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN440@Getffldx
$LN1939@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN440@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN435@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN434@Getffldx
$LN435@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN434@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	al, 1
$LN430@Getffldx:

; 522  : 		return (_Val);

	mov	cl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1071 : 			&& (*_First == _Atoms[_NUMGET_XOFF + 1]

	cmp	cl, BYTE PTR __Atoms$[ebp+25]
	je	SHORT $LN32@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN456@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN461@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN465@Getffldx
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN465@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN466@Getffldx
$LN465@Getffldx:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	cl, BYTE PTR [esi+5]
$LN466@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN461@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	cl, al
	mov	BYTE PTR [esi+5], cl
	jmp	SHORT $LN460@Getffldx
$LN461@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN460@Getffldx:
	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN456@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1071 : 			&& (*_First == _Atoms[_NUMGET_XOFF + 1]

	cmp	cl, BYTE PTR __Atoms$[ebp+24]
	jne	$LN30@Getffldx
$LN32@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1985@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN490@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN490@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN491@Getffldx
$LN490@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN491@Getffldx:

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN1985@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1074 : 		else

	mov	BYTE PTR [esi+4], al
	jmp	$LN1986@Getffldx
$LN1985@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1074 : 		else

	mov	BYTE PTR [esi+4], al
	jmp	$LN1986@Getffldx
$LN78@Getffldx:

; 129  : 		return (do_thousands_sep());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+16]
	call	eax

; 1092 : 					}
; 1093 : 		else
; 1094 : 			{	// grouping specified, gather digits and group sizes
; 1095 : 			const _Elem _Kseparator = _Grouping.size() == 0

	mov	BYTE PTR __Kseparator$1$[ebp], al
$LN79@Getffldx:

; 1096 : 				? (_Elem)0 : _Punct_fac.thousands_sep();
; 1097 : 			string _Groups((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$324[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	bl, BYTE PTR __Kseparator$1$[ebp]

; 1098 : 			size_t _Group = 0;

	xor	edi, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	npad	3
$LL641@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN665@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN675@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN679@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN679@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN680@Getffldx
$LN679@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN680@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN675@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN674@Getffldx
$LN675@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN674@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN665@Getffldx:

; 551  : 		if (!_Right._Got)

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [eax+4], 0
	jne	SHORT $LN666@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN698@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN702@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN702@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN703@Getffldx
$LN702@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN703@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN2012@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	ecx, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	BYTE PTR [ecx+5], al
	mov	eax, ecx
	jmp	SHORT $LN697@Getffldx
$LN2012@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
$LN698@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [eax], 0
$LN697@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [eax+4], 1
$LN666@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1895@Getffldx
	test	eax, eax
	jne	SHORT $LN669@Getffldx
$LN670@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1125 : 			if (_Group == 0)

	mov	ebx, DWORD PTR __Pg$1$[ebp]
	test	edi, edi
	je	SHORT $LL8@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$324[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$324[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1127 : 			else if ('\0' < _Groups[_Group])

	cmp	BYTE PTR [eax+edi], 0
	jle	$LN58@Getffldx

; 1128 : 				++_Group;	// add trailing group to group count

	inc	edi
	npad	3
$LL8@Getffldx:

; 1129 : 			else
; 1130 : 				_Bad = true;	// trailing separator, fail
; 1131 : 
; 1132 : 			while (!_Bad && 0 < _Group)

	mov	edx, ebx
	test	edi, edi
	je	$LN1808@Getffldx

; 1133 : 				if (*_Pg == CHAR_MAX)

	mov	cl, BYTE PTR [ebx]
	cmp	cl, 127					; 0000007fH
	je	$LN1808@Getffldx

; 1136 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	sub	edi, 1
	je	SHORT $LN1856@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$324[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$324[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1136 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax+edi]
	jne	$LN58@Getffldx
$LN1856@Getffldx:
	test	edi, edi
	jne	SHORT $LN1857@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$324[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$324[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1136 : 					|| (0 == _Group && *_Pg < _Groups[_Group]))

	cmp	cl, BYTE PTR [eax]
	jl	$LN58@Getffldx
$LN1857@Getffldx:

; 1129 : 			else
; 1130 : 				_Bad = true;	// trailing separator, fail
; 1131 : 
; 1132 : 			while (!_Bad && 0 < _Group)

	cmp	BYTE PTR [ebx+1], 0

; 1137 : 					_Bad = true;	// bad group size, fail
; 1138 : 				else if ('\0' < _Pg[1])

	lea	eax, DWORD PTR [ebx+1]
	mov	ebx, eax
	cmovle	ebx, edx

; 1140 : 			}

	jmp	SHORT $LL8@Getffldx
$LN1895@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN670@Getffldx
$LN669@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN719@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN724@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN728@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN728@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN729@Getffldx
$LN728@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN729@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN724@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN723@Getffldx
$LN724@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN723@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN719@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN746@Getffldx
	npad	3
$LL747@Getffldx:
	cmp	al, dl
	je	SHORT $LN746@Getffldx
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL747@Getffldx
$LN746@Getffldx:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 1099 : 
; 1100 : 			for (; _First != _Last; ++_First)
; 1101 : 				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)

	cmp	ecx, 22					; 00000016H
	jae	SHORT $LN40@Getffldx

; 1102 : 					{	// got a digit, add to group size
; 1103 : 					_Seendigit = true;
; 1104 : 					if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Significant$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], 1
	cmp	DWORD PTR __Max_sig_dig$1$[ebp], edx
	jg	SHORT $LN42@Getffldx

; 1105 : 						++_Phex;	// just scale by 10

	inc	DWORD PTR __Phex$1$[ebp]
	jmp	SHORT $LN45@Getffldx
$LN42@Getffldx:

; 1106 : 					else if (_Idx == 0 && _Significant == 0)

	test	ecx, ecx
	jne	SHORT $LN44@Getffldx
	test	edx, edx
	je	SHORT $LN45@Getffldx
$LN44@Getffldx:

; 1107 : 						;	// drop leading zeros
; 1108 : 					else
; 1109 : 						{	// save a significant digit
; 1110 : 						*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx

; 1111 : 						++_Significant;

	inc	edx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Significant$1$[ebp], edx
$LN45@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groups$324[ebp+20]

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	mov	ecx, DWORD PTR __Groups$324[ebp]

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1113 : 					if (_Groups[_Group] != CHAR_MAX)

	cmp	BYTE PTR [eax+edi], 127			; 0000007fH
	je	SHORT $LN5@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1114 : 						++_Groups[_Group];

	inc	BYTE PTR [eax+edi]

; 1115 : 					}
; 1116 : 				else if (_Groups[_Group] == '\0'

	jmp	SHORT $LN5@Getffldx
$LN40@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Groups$324[ebp+20], 16	; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Groups$324[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, DWORD PTR __Groups$324[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1118 : 					|| *_First != _Kseparator)

	cmp	BYTE PTR [eax+edi], 0
	je	$LN670@Getffldx
	test	bl, bl
	je	$LN670@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN789@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN794@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN798@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN798@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN799@Getffldx
$LN798@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN799@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	cmp	eax, -1
	je	SHORT $LN794@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN793@Getffldx
$LN794@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN793@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN789@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1118 : 					|| *_First != _Kseparator)

	cmp	BYTE PTR [esi+5], bl
	jne	$LN670@Getffldx

; 1119 : 					break;	// not a group separator, done
; 1120 : 				else
; 1121 : 					{	// add a new group to _Groups string
; 1122 : 					_Groups.append((size_t)1, '\0');

	push	0
	push	1
	lea	ecx, DWORD PTR __Groups$324[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1123 : 					++_Group;

	inc	edi
$LN5@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1987@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN646@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN646@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN647@Getffldx
$LN646@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN647@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1987@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	$LL641@Getffldx
$LN1987@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL641@Getffldx
$LN58@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1140 : 			}

	mov	BYTE PTR __Bad$1$[ebp], 1
$LN1808@Getffldx:
	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Groups$324[ebp+20]
	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2013@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Groups$324[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN889@Getffldx

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN2021@Getffldx
$LN889@Getffldx:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2013@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1142 : 		if (_Seendigit && _Significant == 0)

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
$LN550@Getffldx:
	cmp	BYTE PTR __Seendigit$1$[ebp], 0
	je	SHORT $LN61@Getffldx
	cmp	DWORD PTR __Significant$1$[ebp], 0
	jne	SHORT $LN61@Getffldx

; 1143 : 			*_Ptr++ = '0';	// save at least one leading digit

	mov	eax, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN61@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	$LN913@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN923@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN927@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	$LN927@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LN928@Getffldx
$LL1976@Getffldx:

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN545@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN555@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN559@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN559@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN560@Getffldx
$LN559@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN560@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN555@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN554@Getffldx
$LN555@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN554@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN545@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN546@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN578@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN582@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN582@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN583@Getffldx
$LN582@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN583@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN578@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN577@Getffldx
$LN578@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN577@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN546@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1894@Getffldx
	test	eax, eax
	je	$LN550@Getffldx
	jmp	SHORT $LN1859@Getffldx
$LN1894@Getffldx:
	test	eax, eax
	jne	$LN550@Getffldx
$LN1859@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN599@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN604@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN608@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN608@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN609@Getffldx
$LN608@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN609@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN604@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN603@Getffldx
$LN604@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN603@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN599@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN626@Getffldx
	npad	2
$LL627@Getffldx:
	cmp	al, dl
	je	SHORT $LN626@Getffldx
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL627@Getffldx
$LN626@Getffldx:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 1081 : 			for (; _First != _Last
; 1082 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;

	cmp	ecx, 22					; 00000016H
	jae	$LN550@Getffldx

; 1084 : 				if (_Max_sig_dig <= _Significant)

	mov	edx, DWORD PTR __Significant$1$[ebp]
	cmp	DWORD PTR __Max_sig_dig$1$[ebp], edx
	jg	SHORT $LN36@Getffldx

; 1085 : 					++_Phex;	// just scale by 10

	inc	DWORD PTR __Phex$1$[ebp]
	jmp	SHORT $LN2@Getffldx
$LN36@Getffldx:

; 1086 : 				else if (_Idx == 0 && _Significant == 0)

	test	ecx, ecx
	jne	SHORT $LN38@Getffldx
	test	edx, edx
	je	SHORT $LN2@Getffldx
$LN38@Getffldx:

; 1087 : 					;	// drop leading zeros
; 1088 : 				else
; 1089 : 					{	// save a significant digit
; 1090 : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx

; 1091 : 					++_Significant;

	inc	edx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Significant$1$[ebp], edx
$LN2@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1083 : 					_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1988@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN526@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN526@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN527@Getffldx
$LN526@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN527@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1988@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	$LL1976@Getffldx
$LN1988@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1976@Getffldx
$LN927@Getffldx:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN928@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN923@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN922@Getffldx
$LN923@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN922@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN913@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN914@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN946@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN950@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN950@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN951@Getffldx
$LN950@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN951@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN946@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN945@Getffldx
$LN946@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN945@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN914@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1893@Getffldx
	test	eax, eax
	je	$LN1989@Getffldx
	jmp	SHORT $LN1862@Getffldx
$LN1893@Getffldx:
	test	eax, eax
	jne	$LN1989@Getffldx
$LN1862@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN967@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN972@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1940@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1940@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN977@Getffldx
$LN1940@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN977@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN972@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN971@Getffldx
$LN972@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN971@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN967@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 124  : 		return (do_decimal_point());

	mov	ecx, DWORD PTR __Punct_fac$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	bl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 124  : 		return (do_decimal_point());

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+12]
	call	eax

; 1144 : 
; 1145 : 		if (_First != _Last && *_First == _Punct_fac.decimal_point())

	cmp	bl, al
	jne	SHORT $LN1989@Getffldx

; 1146 : 			{	// add .
; 1147 : 			*_Ptr++ = localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR __Ptr$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN999@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1941@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1941@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1004@Getffldx
$LN1941@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1004@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN999@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN1989@Getffldx
$LN999@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1989@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1151 : 		if (_Significant == 0)

	mov	ebx, DWORD PTR __Significant$1$[ebp]
	test	ebx, ebx
	jne	$LN1832@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+4]
	mov	ebx, DWORD PTR __Phex$1$[ebp]
$LL1021@Getffldx:

; 549  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN1045@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1055@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1059@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1059@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1060@Getffldx
$LN1059@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1060@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1055@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1054@Getffldx
$LN1055@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1054@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1045@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1046@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1078@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1082@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1082@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1083@Getffldx
$LN1082@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1083@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1078@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1077@Getffldx
$LN1078@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1077@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1046@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1892@Getffldx
	test	eax, eax
	jne	SHORT $LN1863@Getffldx
$LN1943@Getffldx:
	mov	DWORD PTR __Phex$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1156 : 			if (_Phex < 0)

	test	ebx, ebx
	mov	ebx, DWORD PTR __Significant$1$[ebp]
	jns	SHORT $LN1832@Getffldx

; 1157 : 				{	// put one back
; 1158 : 				*_Ptr++ = '0';

	mov	eax, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [eax], 48			; 00000030H
	inc	eax

; 1159 : 				++_Phex;

	inc	DWORD PTR __Phex$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], eax
$LN1832@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+4]
	npad	4
$LL1824@Getffldx:

; 549  : 		if (!_Got)

	test	al, al
	jne	$LN1152@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN1162@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN1166@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	$LN1166@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LN1167@Getffldx
$LN1892@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN1943@Getffldx
$LN1863@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN1099@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1104@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1942@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1942@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1109@Getffldx
$LN1942@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1109@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1104@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1103@Getffldx
$LN1104@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1103@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1099@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1153 : 			for (; _First != _Last && *_First == _Atoms[0];

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	$LN1943@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1155 : 				--_Phex;	// just count leading fraction zeros

	dec	ebx
	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1990@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1026@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1026@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1027@Getffldx
$LN1026@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1027@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1990@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	al, al
	jmp	$LL1021@Getffldx
$LN1990@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1021@Getffldx
$LN1166@Getffldx:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1167@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1162@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1161@Getffldx
$LN1162@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1161@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1152@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1153@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1866@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1189@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1189@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1190@Getffldx
$LN1189@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1190@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1866@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1184@Getffldx
$LN1866@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1184@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1153@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1891@Getffldx
	test	eax, eax
	jne	SHORT $LN1868@Getffldx
$LN1944@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1173 : 			&& (*_First == _Atoms[_NUMGET_POFF + 1]

	mov	bl, BYTE PTR __Seendigit$1$[ebp]
	test	bl, bl
	je	$LN1663@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	$LN1241@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	$LN1251@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN1255@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	$LN1255@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	$LN1256@Getffldx
$LN1891@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN1944@Getffldx
$LN1868@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN1206@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1211@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1215@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1215@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1216@Getffldx
$LN1215@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1216@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1211@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1210@Getffldx
$LN1211@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1210@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1206@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN1233@Getffldx
	npad	6
$LL1234@Getffldx:
	cmp	al, dl
	je	SHORT $LN1233@Getffldx
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL1234@Getffldx
$LN1233@Getffldx:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 1160 : 				}
; 1161 : 			}
; 1162 : 
; 1163 : 		for (; _First != _Last
; 1164 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;

	cmp	ecx, 22					; 00000016H
	jae	$LN1944@Getffldx

; 1166 : 			if (_Significant < _Max_sig_dig)

	cmp	ebx, DWORD PTR __Max_sig_dig$1$[ebp]
	jge	SHORT $LN13@Getffldx

; 1167 : 				{	// save a significant fraction digit
; 1168 : 				*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 1169 : 				++_Significant;

	inc	ebx
$LN13@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1165 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1991@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1133@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1133@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1134@Getffldx
$LN1133@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1134@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1991@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	al, al
	jmp	$LL1824@Getffldx
$LN1991@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1824@Getffldx
$LN1255@Getffldx:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1256@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1251@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1250@Getffldx
$LN1251@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1250@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1241@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1242@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1274@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1278@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1278@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1279@Getffldx
$LN1278@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1279@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1274@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1273@Getffldx
$LN1274@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1273@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1242@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1890@Getffldx
	test	eax, eax
	je	$LN1663@Getffldx
	jmp	SHORT $LN1870@Getffldx
$LN1890@Getffldx:
	test	eax, eax
	jne	$LN1663@Getffldx
$LN1870@Getffldx:

; 512  : 		if (!_Got)

	mov	al, BYTE PTR [esi+4]
	test	al, al
	jne	SHORT $LN1295@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1300@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1945@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1945@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1305@Getffldx
$LN1945@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1305@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1300@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1299@Getffldx
$LN1300@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1299@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	al, 1
$LN1295@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1173 : 			&& (*_First == _Atoms[_NUMGET_POFF + 1]

	mov	cl, BYTE PTR [esi+5]
	cmp	cl, BYTE PTR __Atoms$[ebp+27]
	je	SHORT $LN67@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	al, al
	jne	SHORT $LN1321@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	edx, DWORD PTR [esi]
	mov	al, cl
	test	edx, edx
	je	SHORT $LN1326@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN1330@Getffldx
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1330@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	edx, BYTE PTR [edi]
	mov	al, cl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1331@Getffldx
$LN1330@Getffldx:
	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
	mov	edx, eax
	mov	al, BYTE PTR [esi+5]
$LN1331@Getffldx:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1326@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], cl
	jmp	SHORT $LN1325@Getffldx
$LN1326@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	mov	cl, al
$LN1325@Getffldx:
	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1321@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1173 : 			&& (*_First == _Atoms[_NUMGET_POFF + 1]

	cmp	cl, BYTE PTR __Atoms$[ebp+26]
	jne	$LN1663@Getffldx
$LN67@Getffldx:

; 1176 : 			*_Ptr++ = 'p';

	mov	ebx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR [ebx], 112			; 00000070H
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1176 : 			*_Ptr++ = 'p';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1992@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1355@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1355@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1356@Getffldx
$LN1355@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1356@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1992@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
	jmp	SHORT $LN1350@Getffldx
$LN1992@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1
$LN1350@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1178 : 			_Seendigit = false;

	mov	BYTE PTR [esi+4], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1178 : 			_Seendigit = false;

	mov	BYTE PTR __Seendigit$1$[ebp], 0

; 1179 : 			_Significant = 0;

	mov	DWORD PTR __Significant$2$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	jne	SHORT $LN1372@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1382@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1386@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1386@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1387@Getffldx
$LN1386@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1387@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1382@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1381@Getffldx
$LN1382@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1381@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1372@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1373@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1405@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1409@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1409@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1410@Getffldx
$LN1409@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1410@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1405@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1404@Getffldx
$LN1405@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1404@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN1373@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	test	ecx, ecx
	jne	SHORT $LN1889@Getffldx
	test	eax, eax
	je	$LN2003@Getffldx
	jmp	SHORT $LN1873@Getffldx
$LN1889@Getffldx:
	test	eax, eax
	jne	$LN2003@Getffldx
$LN1873@Getffldx:

; 512  : 		if (!_Got)

	mov	dl, BYTE PTR [esi+4]
	test	dl, dl
	jne	SHORT $LN1426@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1431@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1435@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1435@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1436@Getffldx
$LN1435@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [esi]
$LN1436@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1431@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1430@Getffldx
$LN1431@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
	xor	ecx, ecx
$LN1430@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	dl, 1
$LN1426@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1183 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp+23]
	jne	SHORT $LN70@Getffldx

; 1185 : 				*_Ptr++ = '+';

	mov	BYTE PTR [ebx], 43			; 0000002bH
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1185 : 				*_Ptr++ = '+';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1993@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1460@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1460@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1461@Getffldx
$LN1460@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1461@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1993@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1188 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN2003@Getffldx
$LN1993@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1188 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	mov	BYTE PTR [esi+4], al
	jmp	$LN2003@Getffldx
$LN70@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	test	dl, dl
	jne	SHORT $LN1475@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1480@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1484@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1484@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1485@Getffldx
$LN1484@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1485@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1872@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1479@Getffldx
$LN1872@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	al, BYTE PTR [esi+5]
$LN1480@Getffldx:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1479@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1475@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1188 : 			else if (*_First == _Atoms[_NUMGET_SIGNOFF])

	cmp	al, BYTE PTR __Atoms$[ebp+22]
	jne	SHORT $LN2003@Getffldx

; 1190 : 				*_Ptr++ = '-';

	mov	BYTE PTR [ebx], 45			; 0000002dH
	inc	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1190 : 				*_Ptr++ = '-';

	mov	DWORD PTR __Ptr$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1994@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1946@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1946@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1510@Getffldx
$LN1946@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1510@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1994@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	jmp	SHORT $LN2003@Getffldx
$LN1994@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN2003@Getffldx:
	mov	bh, BYTE PTR __Seendigit$1$[ebp]
$LL1981@Getffldx:

; 549  : 		if (!_Got)

	mov	cl, BYTE PTR [esi+4]
	mov	al, cl
	test	cl, cl
	jne	SHORT $LN1551@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1561@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1565@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1565@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1566@Getffldx
$LN1565@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1566@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1561@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1560@Getffldx
$LN1561@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1560@Getffldx:

; 582  : 		_Got = true;

	mov	cl, 1
	mov	BYTE PTR [esi+4], 1
	mov	al, cl
$LN1551@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN1552@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN1584@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1588@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1588@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1589@Getffldx
$LN1588@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1589@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1584@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN1583@Getffldx
$LN1584@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN1583@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
	mov	cl, BYTE PTR [esi+4]
	mov	al, cl
$LN1552@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	edx, DWORD PTR [esi]
	mov	bl, al
	mov	edi, DWORD PTR [edi]
	test	edx, edx
	jne	SHORT $LN1927@Getffldx
	test	edi, edi
	je	SHORT $LN1556@Getffldx
$LN1875@Getffldx:
	xor	ah, ah
	mov	bl, al
$LN1557@Getffldx:

; 613  : 	return (!(_Left == _Right));

	test	ah, ah
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1194 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	jne	$LN17@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 512  : 		if (!_Got)

	mov	cl, bl
	test	bl, bl
	jne	SHORT $LN1605@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	edx, edx
	je	SHORT $LN1610@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1947@Getffldx
	mov	eax, DWORD PTR [edx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1947@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1615@Getffldx
$LN1927@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	edi, edi
	je	SHORT $LN1875@Getffldx
$LN1556@Getffldx:
	mov	ah, 1
	jmp	SHORT $LN1557@Getffldx
$LN1947@Getffldx:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+24]
$LN1615@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1610@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1609@Getffldx
$LN1610@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1609@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	mov	cl, 1
$LN1605@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1194 : 			for (; _First != _Last && *_First == _Atoms[0]; ++_First)

	mov	al, BYTE PTR [esi+5]
	cmp	al, BYTE PTR __Atoms$[ebp]
	jne	SHORT $LN17@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1196 : 				_Seendigit = true;

	mov	bh, 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1995@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1532@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1532@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1533@Getffldx
$LN1532@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1533@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1995@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	BYTE PTR [esi+4], 0
	jmp	$LL1981@Getffldx
$LN1995@Getffldx:

; 566  : 			}
; 567  : 		else

	mov	edi, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	DWORD PTR [esi], 0
	mov	BYTE PTR [esi+4], 1
	jmp	$LL1981@Getffldx
$LN17@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1199 : 			if (_Seendigit)

	mov	edi, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR __Seendigit$1$[ebp], bh
	test	bh, bh
	je	SHORT $LN1835@Getffldx

; 1200 : 				*_Ptr++ = '0';	// put one back

	mov	BYTE PTR [edi], 48			; 00000030H
	inc	edi
	mov	cl, BYTE PTR [esi+4]
$LN1835@Getffldx:
	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
$LL1827@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	test	cl, cl
	jne	SHORT $LN1658@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN1668@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1672@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1672@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1673@Getffldx
$LN1672@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1673@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1668@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1667@Getffldx
$LN1668@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1667@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1658@Getffldx:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN1659@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN1691@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1695@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1695@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1696@Getffldx
$LN1695@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1696@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1691@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN1690@Getffldx
$LN1691@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN1690@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN1659@Getffldx:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN1888@Getffldx
	test	eax, eax
	jne	SHORT $LN1662@Getffldx
$LN2011@Getffldx:
	mov	bl, BYTE PTR __Seendigit$1$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], edi
$LN1663@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1211 : 		if (_Bad || !_Seendigit)

	cmp	BYTE PTR __Bad$1$[ebp], 0
	jne	SHORT $LN76@Getffldx
	test	bl, bl
	jne	$LN2015@Getffldx
$LN76@Getffldx:

; 1212 : 			_Ptr = _Ac;	// roll back pointer to indicate failure

	mov	ecx, DWORD PTR __Ac$GSCopy$1$[ebp]
	jmp	$LN75@Getffldx
$LN1888@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN2011@Getffldx
$LN1662@Getffldx:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN1712@Getffldx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1717@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN1721@Getffldx
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN1721@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1722@Getffldx
$LN1721@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN1722@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1717@Getffldx

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN1716@Getffldx
$LN1717@Getffldx:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN1716@Getffldx:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN1712@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	al, BYTE PTR __Atoms$[ebp]
	lea	ecx, DWORD PTR __Atoms$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 522  : 		return (_Val);

	mov	dl, BYTE PTR [esi+5]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	test	al, al
	je	SHORT $LN1739@Getffldx
$LL1740@Getffldx:
	cmp	al, dl
	je	SHORT $LN1739@Getffldx
	mov	al, BYTE PTR [ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL1740@Getffldx
$LN1739@Getffldx:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	lea	eax, DWORD PTR __Atoms$[ebp]
	sub	ecx, eax

; 1201 : 			for (; _First != _Last
; 1202 : 				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;

	cmp	ecx, 22					; 00000016H
	jae	SHORT $LN2011@Getffldx

; 1204 : 				if (_Significant < _MAX_EXP_DIG)

	mov	edx, DWORD PTR __Significant$2$[ebp]
	cmp	edx, 8
	jge	SHORT $LN19@Getffldx

; 1205 : 					{	// save a significant exponent digit
; 1206 : 					*_Ptr++ = _Src[_Idx];

	mov	al, BYTE PTR ?_Src@?1??_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@3@1AAVios_base@3@PAH@Z@4QBDB[ecx]
	mov	BYTE PTR [edi], al
	inc	edi

; 1207 : 					++_Significant;

	inc	edx
	mov	DWORD PTR __Significant$2$[ebp], edx
$LN19@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1203 : 				_Seendigit = true, (void)++_First)

	mov	BYTE PTR __Seendigit$1$[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN1996@Getffldx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1639@Getffldx
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN1639@Getffldx

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN1640@Getffldx
$LN1639@Getffldx:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN1640@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN1996@Getffldx

; 568  : 			{
; 569  : 			_Got = false;

	mov	BYTE PTR [esi+4], 0
	xor	cl, cl
	jmp	$LL1827@Getffldx
$LN1996@Getffldx:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	cl, 1
	mov	BYTE PTR [esi+4], 1

; 566  : 			}
; 567  : 		else

	jmp	$LL1827@Getffldx
$LN2015@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1211 : 		if (_Bad || !_Seendigit)

	mov	ecx, DWORD PTR __Ptr$1$[ebp]
$LN75@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR __Grouping$[ebp+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1214 : 		*_Phexexp = _Phex;	// power of 16 multiplier

	mov	eax, DWORD PTR __Phex$1$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	ecx, DWORD PTR __Phexexp$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN1779@Getffldx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	ecx, DWORD PTR __Grouping$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, ecx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN1778@Getffldx

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	ecx, DWORD PTR [ecx-4]
	add	edx, 35					; 00000023H
	sub	eax, ecx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN2022@Getffldx
$LN1778@Getffldx:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	edx
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN1779@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1215 : 		return (0);	// power of 10 multiplier

	xor	eax, eax

; 1216 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2021@Getffldx:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN2022@Getffldx:
	call	__invalid_parameter_noinfo_noreturn
$LN2018@Getffldx:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$1:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__unwindfunclet$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z$3:
	lea	ecx, DWORD PTR __Groups$324[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getffldx@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1AAVios_base@2@PAH@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getffldx
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 526  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@operator
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN10@operator

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN11@operator
$LN10@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN11@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN6@operator

; 566  : 			}
; 567  : 		else
; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al

; 527  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 528  : 		if (_Strbuf == 0)
; 529  : 			{
; 530  : 			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
; 531  : 			}
; 532  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 533  : 
; 534  : 		_Inc();
; 535  : 		return (*this);
; 536  : 		}

	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	pop	esi
	ret	0
$LN6@operator:

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [esi], 0

; 527  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 528  : 		if (_Strbuf == 0)
; 529  : 			{
; 530  : 			_DEBUG_ERROR("istreambuf_iterator is not incrementable");
; 531  : 			}
; 532  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 533  : 
; 534  : 		_Inc();
; 535  : 		return (*this);
; 536  : 		}

	mov	BYTE PTR [esi+4], al
	mov	eax, esi
	pop	esi
	ret	0
??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 511  : 		{	// return designated value

	push	esi
	mov	esi, ecx

; 512  : 		if (!_Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN27@operator

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN7@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN11@operator
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN11@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN12@operator
$LN11@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN12@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN7@operator

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
	pop	esi

; 513  : 			_Peek();
; 514  : 
; 515  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 516  : 		if (_Strbuf == 0)
; 517  : 			{
; 518  : 			_DEBUG_ERROR("istreambuf_iterator is not dereferencable");
; 519  : 			}
; 520  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 521  : 
; 522  : 		return (_Val);
; 523  : 		}

	ret	0
$LN7@operator:

; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN27@operator:

; 513  : 			_Peek();
; 514  : 
; 515  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 516  : 		if (_Strbuf == 0)
; 517  : 			{
; 518  : 			_DEBUG_ERROR("istreambuf_iterator is not dereferencable");
; 519  : 			}
; 520  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 521  : 
; 522  : 		return (_Val);
; 523  : 		}

	mov	al, BYTE PTR [esi+5]
	pop	esi
	ret	0
??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 659  : 		return (*this);

	mov	eax, ecx

; 660  : 		}

	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 654  : 		return (*this);

	mov	eax, ecx

; 655  : 		}

	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 644  : 		{	// store element and increment

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN3@operator

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN7@operator

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR __Right$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	push	eax
	call	DWORD PTR [edx+12]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 646  : 			|| traits_type::eq_int_type(_Traits::eof(),

	jne	SHORT $LN24@operator
$LN3@operator:

; 647  : 				_Strbuf->sputc(_Right)))
; 648  : 			_Failed = true;

	mov	BYTE PTR [esi], 1
$LN24@operator:

; 649  : 		return (*this);
; 650  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
tv632 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3202 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 3203 : 		auto& _My_data = this->_Get_data();
; 3204 : 		const size_type _Old_size = _My_data._Mysize;

	mov	ecx, DWORD PTR [esi+16]

; 3205 : 		if (_Old_size < _My_data._Myres)

	mov	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __Old_size$1$[ebp], ecx
	mov	DWORD PTR __Old$1$[ebp], edi
	cmp	ecx, edi
	jae	SHORT $LN2@push_back

; 3206 : 			{
; 3207 : 			_My_data._Mysize = _Old_size + 1;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+16], eax

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	edi, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN9@push_back
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN9@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	pop	edi
	mov	BYTE PTR [esi+ecx], al
	mov	BYTE PTR [esi+ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3221 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@push_back:

; 3897 : 		if (max_size() - _Old_size < _Size_increase)

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	sub	eax, ecx
	cmp	eax, 1
	jb	$LN135@push_back
	push	ebx

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	lea	ebx, DWORD PTR [ecx+1]

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	ebx, 15					; 0000000fH
	cmp	ebx, edx

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN43@push_back

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	ebx, edx
	jmp	SHORT $LN42@push_back
$LN43@push_back:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, edi
	shr	eax, 1
	sub	edx, eax
	cmp	edi, edx
	jbe	SHORT $LN44@push_back

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	ebx, 2147483647				; 7fffffffH
	jmp	SHORT $LN42@push_back
$LN44@push_back:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	ebx, eax
	cmovb	ebx, eax
$LN42@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3906 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	edx, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN75@push_back

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	ecx, -1
	cmp	eax, edx
	cmovbe	eax, ecx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN110@push_back

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN74@push_back
$LN75@push_back:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	edx, edx
	je	SHORT $LN76@push_back

; 52   : 		return (::operator new(_Bytes));

	push	edx
	call	??2@YAPAXI@Z				; operator new

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edi, eax
	jmp	SHORT $LN74@push_back
$LN76@push_back:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	edi, edi
$LN74@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3911 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+20], ebx
	lea	ebx, DWORD PTR [edi+ecx]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR tv632[ebp], ebx
	push	ecx
	jb	SHORT $LN21@push_back

; 3912 : 			{
; 3913 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	edi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	ecx, DWORD PTR tv632[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx], al
	mov	BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN111@push_back

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [ebx-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	ebx, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	lea	eax, DWORD PTR [ebx-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN110@push_back

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ebx, edx
$LN111@push_back:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [esi], edi
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3221 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN21@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	esi
	push	edi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [ebx], al
	mov	BYTE PTR [ebx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	DWORD PTR [esi], edi
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3221 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN135@push_back:

; 3899 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN110@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN132@push_back:
	int	3
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$dead$ = ecx

; 3216 : 				const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3216 : 				const _Elem _Ch) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	edi, DWORD PTR __Old_size$[ebp]
	push	edi
	push	DWORD PTR __Old_ptr$[ebp]
	push	esi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], al
	mov	BYTE PTR [esi+edi+1], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3220 : 			}, _Ch);

	pop	ebp
	ret	16					; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3187 : 		{	// subscript immutable sequence

	push	ebp
	mov	ebp, esp

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1798 : 		if (_Large_string_engaged())

	mov	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3191 : 		}

	add	eax, ecx
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
$T2 = 8							; size = 1
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2768 : 		{	// insert _Count * _Ch at _Off

	push	ebp
	mov	ebp, esp

; 1813 : 		if (_Mysize < _Off)

	mov	edx, DWORD PTR __Off$[ebp]

; 2768 : 		{	// insert _Count * _Ch at _Off

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1813 : 		if (_Mysize < _Off)

	mov	ecx, DWORD PTR [edi+16]
	cmp	ecx, edx
	jb	SHORT $LN25@insert

; 2769 : 		auto& _My_data = this->_Get_data();
; 2770 : 		_My_data._Check_offset(_Off);
; 2771 : 		const size_type _Old_size = _My_data._Mysize;
; 2772 : 		if (_Count <= _My_data._Myres - _Old_size)

	mov	esi, DWORD PTR [edi+20]
	mov	eax, esi
	mov	ebx, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	ebx, eax
	ja	SHORT $LN2@insert

; 2773 : 			{
; 2774 : 			_My_data._Mysize = _Old_size + _Count;

	lea	eax, DWORD PTR [ecx+ebx]
	mov	DWORD PTR [edi+16], eax

; 1786 : 		value_type * _Result = _Bx._Buf;

	mov	eax, edi

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	esi, 16					; 00000010H

; 1787 : 		if (_Large_string_engaged())

	jb	SHORT $LN13@insert
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
$LN13@insert:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2776 : 			_Elem * const _Insert_at = _Old_ptr + _Off;

	lea	esi, DWORD PTR [eax+edx]

; 2777 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	ecx
	lea	eax, DWORD PTR [esi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 478  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

	push	ecx
	push	esi
	push	eax
	call	_memmove

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	ebx
	push	eax
	push	esi
	call	_memset
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2779 : 			return (*this);

	mov	eax, edi
	pop	edi

; 2783 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2784 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {
; 2785 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2786 : 			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2788 : 			}, _Off, _Count, _Ch));
; 2789 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	12					; 0000000cH
$LN2@insert:

; 2780 : 			}
; 2781 : 
; 2782 : 		return (_Reallocate_grow_by(_Count,

	push	DWORD PTR __Ch$[ebp]
	mov	BYTE PTR $T2[ebp], 0
	mov	ecx, edi
	push	ebx
	push	edx
	push	DWORD PTR $T2[ebp]
	push	ebx
	call	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
	pop	edi

; 2783 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2784 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {
; 2785 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2786 : 			_Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2788 : 			}, _Off, _Count, _Ch));
; 2789 : 		}

	pop	esi
	pop	ebx
	pop	ebp
	ret	12					; 0000000cH
$LN25@insert:

; 1815 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN23@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$dead$ = ecx

; 2784 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {

	push	ebp
	mov	ebp, esp
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	ebx, DWORD PTR __Old_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2784 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2784 : 				const size_type _Off, const size_type _Count, const _Elem _Ch) {

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	mov	edi, DWORD PTR __Off$[ebp]
	push	edi
	push	ebx
	push	esi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2786 : 			_Traits::assign(_New_ptr + _Off, _Count, _Ch);

	add	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	mov	esi, DWORD PTR __Count$[ebp]
	push	esi
	push	eax
	push	edi
	call	_memset
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Old_size$[ebp]
	sub	eax, ecx
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	call	_memcpy
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2788 : 			}, _Off, _Count, _Ch));

	pop	ebp
	ret	24					; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2284 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2285 : 		if (this != _STD addressof(_Right))

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	SHORT $LN89@operator

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN40@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN39@operator

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN38@operator

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN39@operator:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN40@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3969 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3970 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [esi], xmm0
	movq	xmm0, QWORD PTR [edi+16]
	movq	QWORD PTR [esi+16], xmm0

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [edi+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
$LN89@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2294 : 		return (*this);

	pop	edi
	mov	eax, esi
	pop	esi

; 2295 : 		}

	pop	ebp
	ret	4
$LN38@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN90@operator:
	int	3
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Pnavail
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	cdq

; 313  : 		}

	ret	0
$LN3@Pnavail:

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	xor	eax, eax
	cdq

; 313  : 		}

	ret	0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Gnavail
	mov	eax, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	cdq

; 282  : 		}

	ret	0
$LN3@Gnavail:

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	xor	eax, eax
	cdq

; 282  : 		}

	ret	0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 269  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+44]
	dec	DWORD PTR [eax]

; 270  : 		return ((*_IGnext)++);

	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 271  : 		}

	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 225  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [eax]

; 226  : 		}

	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 165  : 		{	// point to next character and return it

	push	esi
	mov	esi, ecx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN17@snextc
	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [ecx]

; 166  : 		return (1 < _Gnavail()

	cmp	eax, 1
	jle	SHORT $LN22@snextc

; 275  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 276  : 		return (++(*_IGnext));

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	inc	ecx
	mov	DWORD PTR [eax], ecx
$LN46@snextc:

; 170  : 		}

	movzx	eax, BYTE PTR [ecx]
	pop	esi
	ret	0
$LN22@snextc:

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN17@snextc

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [ecx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN18@snextc
$LN17@snextc:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+28]
$LN18@snextc:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 166  : 		return (1 < _Gnavail()

	jne	SHORT $LN3@snextc
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 524  : 		return (EOF);

	or	eax, eax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 170  : 		}

	ret	0
$LN3@snextc:

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN35@snextc
	mov	eax, DWORD PTR [esi+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jg	SHORT $LN46@snextc
$LN35@snextc:
	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR [eax+24]
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN3@sgetc
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN3@sgetc
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 156  : 		}

	ret	0
$LN3@sgetc:

; 154  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+24]
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 143  : 		return (sync());

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+52]
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ
_TEXT	SEGMENT
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek, COMDAT
; _this$ = ecx

; 574  : 		{	// peek at next input element

	push	esi
	mov	esi, ecx

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@Peek

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Peek
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN8@Peek
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN9@Peek
$LN8@Peek:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN9@Peek:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN4@Peek

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al

; 582  : 		_Got = true;
; 583  : 		return (_Val);
; 584  : 		}

	mov	BYTE PTR [esi+4], 1
	pop	esi
	ret	0
$LN4@Peek:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	al, BYTE PTR [esi+5]
	mov	DWORD PTR [esi], 0

; 582  : 		_Got = true;
; 583  : 		return (_Val);
; 584  : 		}

	mov	BYTE PTR [esi+4], 1
	pop	esi
	ret	0
?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@ABEDXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Peek
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc, COMDAT
; _this$ = ecx

; 559  : 		{	// skip to next input element

	push	esi
	mov	esi, ecx

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@Inc

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN8@Inc
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN8@Inc

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN9@Inc
$LN8@Inc:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN9@Inc:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN4@Inc

; 566  : 			}
; 567  : 		else
; 568  : 			{
; 569  : 			_Got = false;

	xor	al, al

; 570  : 			}
; 571  : 		}

	mov	BYTE PTR [esi+4], al
	pop	esi
	ret	0
$LN4@Inc:

; 562  : 				_Strbuf->sbumpc()))
; 563  : 			{
; 564  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0

; 565  : 			_Got = true;

	mov	al, 1

; 570  : 			}
; 571  : 		}

	mov	BYTE PTR [esi+4], al
	pop	esi
	ret	0
?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::_Inc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 1812 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp

; 1813 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN6@Check_offs

; 1816 : 			}
; 1817 : 		}

	pop	ebp
	ret	4
$LN6@Check_offs:

; 1814 : 			{
; 1815 : 			_Xran();

	call	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN4@Check_offs:
	int	3
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 1911 : 		_Pocma(_Getal(), _Al);
; 1912 : 		}

	ret	4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2304 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

	push	ebp
	mov	ebp, esp

; 2348 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3950 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3951 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2309 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 275  : 		--*_IGcount;

	mov	eax, DWORD PTR [ecx+44]
	dec	DWORD PTR [eax]

; 276  : 		return (++(*_IGnext));

	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR [ecx]
	inc	eax
	mov	DWORD PTR [ecx], eax

; 277  : 		}

	ret	0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 197  : 		{	// put a character

	push	ebp
	mov	ebp, esp

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sputc
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN3@sputc

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 201  : 		}

	pop	ebp
	ret	4
$LN3@sputc:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Ch$[ebp], eax

; 201  : 		}

	pop	ebp

; 198  : 		return (0 < _Pnavail()

	jmp	DWORD PTR [edx+12]
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@sbumpc
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN3@sbumpc

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 150  : 		}

	ret	0
$LN3@sbumpc:

; 148  : 		return (0 < _Gnavail()

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1829 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN3@Xran:
	int	3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 306  : 		--*_IPcount;

	mov	eax, DWORD PTR [ecx+48]
	dec	DWORD PTR [eax]

; 307  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR [edx], ecx

; 308  : 		}

	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T3 = -100						; size = 52
$T4 = -48						; size = 16
__Lock$26 = -28						; size = 4
__Psave$1$ = -24					; size = 4
$T2 = -24						; size = 4
__Psave_guard$27 = -24					; size = 4
__Lock$28 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 501  : 	{	// get facet reference from locale

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -8					; fffffff8H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$26[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id

; 503  : 		const locale::facet *_Psave =
; 504  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$1$[ebp], eax

; 116  : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN12@use_facet

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$28[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, edi ; std::ctype<char>::id
	jne	SHORT $LN13@use_facet

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A, eax ; std::ctype<char>::id
$LN13@use_facet:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$28[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
$LN12@use_facet:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR __Loc$[ebx]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN21@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	$LN95@use_facet
	jmp	SHORT $LN97@use_facet
$LN21@use_facet:

; 428  : 		}
; 429  : 
; 430  : 	const facet *_Getfacet(size_t _Id) const
; 431  : 		{	// look up a facet in locale object
; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN97@use_facet:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN18@use_facet

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN98@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 505  : 
; 506  : 		size_t _Id = _Facet::id;
; 507  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 508  : 
; 509  : 		if (_Pf != 0)

	test	esi, esi
	jne	$LN95@use_facet
$LN98@use_facet:

; 510  : 			;	// got facet from locale
; 511  : 		else if (_Psave != 0)

	mov	eax, DWORD PTR __Psave$1$[ebp]
	test	eax, eax
	je	SHORT $LN4@use_facet

; 512  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, eax

; 513  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	jmp	SHORT $LN95@use_facet
$LN4@use_facet:

; 2444 : 			*_Ppf = new ctype<_Elem>(

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Loc$[ebx]

; 2444 : 			*_Ppf = new ctype<_Elem>(

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN36@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN41@use_facet
$LN36@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN41@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN41@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2444 : 			*_Ppf = new ctype<_Elem>(

	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2436 : 		{	// construct from current locale

	mov	DWORD PTR [esi], OFFSET ??_7?$ctype@D@std@@6B@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 117  : 		return (::_Getctype());

	call	__Getctype
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 2444 : 			*_Ppf = new ctype<_Elem>(

	lea	ecx, DWORD PTR $T3[ebp]

; 2470 : 		_Ctype = _Lobj._Getctype();

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+8], xmm0

; 2444 : 			*_Ppf = new ctype<_Elem>(

	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$27[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 529  : 			_Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 530  :  #endif /* defined(_M_CEE) */
; 531  : 
; 532  : 			_Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 533  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::ctype<char> >::_Psave
$LN95@use_facet:

; 534  : 			_Pf = _Psave;
; 535  : 
; 536  : 			(void) _Psave_guard.release();
; 537  : 			}
; 538  : 
; 539  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$26[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 540  : 	_END_LOCK()
; 541  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$26[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$3:
	push	24					; 00000018H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$27[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ PROC ; std::_Immortalize<std::_Iostream_error_category>, COMDAT

; 608  : 	static_assert(sizeof(void *) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 609  : 	static_assert(alignof(void *) == alignof(once_flag), "TRANSITION, VSO#406237");
; 610  : 	static void * _Flag = nullptr;
; 611  : 	static aligned_union_t<1, _Ty> _Storage;
; 612  : 	if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)

	push	OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage
	push	OFFSET ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ; std::_Immortalize_impl<std::_Iostream_error_category>
	push	OFFSET ?_Flag@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4PAXA ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Flag
	call	?_Execute_once@std@@YAHAAUonce_flag@1@P6GHPAX1PAPAX@Z1@Z ; std::_Execute_once
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	_terminate

; 613  : 		{	// _Execute_once should never fail if the callback never fails
; 614  : 		_STD terminate();
; 615  : 		}
; 616  : 
; 617  : 	return (reinterpret_cast<_Ty&>(_Storage));

	mov	eax, OFFSET ?_Storage@?1???$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@1@XZ@4T?$_Align_type@H$07@1@A ; `std::_Immortalize<std::_Iostream_error_category>'::`2'::_Storage

; 618  : 	}

	ret	0
??$_Immortalize@V_Iostream_error_category@std@@@std@@YAAAV_Iostream_error_category@0@XZ ENDP ; std::_Immortalize<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Pad$41 = -56						; size = 8
__Ok$ = -44						; size = 8
tv1263 = -36						; size = 4
__Ostr$ = -32						; size = 4
__State$ = -28						; size = 4
__Pad$2$ = -24						; size = 4
$T42 = -17						; size = 1
$T43 = -17						; size = 1
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Ch$dead$ = dl

; 828  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR __Ostr$[ebp], edi

; 100  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [edi]

; 829  : 	typedef char _Elem;
; 830  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 831  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi
	mov	DWORD PTR __State$[ebp], esi

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

	test	edx, edx
	je	SHORT $LN27@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [edi]
$LN27@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, ecx
	mov	ebx, DWORD PTR [ecx+4]
	mov	edx, ecx

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ebx+edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN23@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	ebx, DWORD PTR [ebx+edi+60]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ebx, ebx
	je	SHORT $LN23@operator
	cmp	ebx, edi
	je	SHORT $LN23@operator

; 123  : 				_Ostr.tie()->flush();

	mov	ecx, ebx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [edi]
	mov	edx, eax
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+edi+12]
	add	ecx, edi

; 339  : 		return (rdstate() == goodbit);

	test	eax, eax

; 315  : 		return (_Mystate);

	mov	DWORD PTR tv1263[ebp], ecx

; 339  : 		return (rdstate() == goodbit);

	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 832  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 833  : 
; 834  : 	if (_Ok)

	jne	$LN20@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 423  : 		return (_Wide);

	mov	ebx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR [ecx+36]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 836  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	test	ecx, ecx
	jg	SHORT $LN15@operator
	jl	SHORT $LN186@operator
	cmp	ebx, 1
	ja	SHORT $LN15@operator
$LN186@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$41[ebp], xmm0
	mov	ecx, DWORD PTR __Pad$41[ebp+4]
	mov	ebx, DWORD PTR __Pad$41[ebp]
	jmp	SHORT $LN195@operator
$LN15@operator:
	sub	ebx, 1
	sbb	ecx, 0
$LN195@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR tv1263[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 838  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	DWORD PTR __Pad$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [eax+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 839  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN180@operator
	npad	7
$LL4@operator:

; 840  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	$LN6@operator
	mov	edx, DWORD PTR [edi]
	test	ecx, ecx
	jl	SHORT $LN180@operator
	jg	SHORT $LN187@operator
	test	ebx, ebx
	je	SHORT $LN180@operator
$LN187@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [edx+4]
	mov	cl, BYTE PTR [eax+edi+64]
	mov	BYTE PTR $T43[ebp], cl

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN61@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN61@operator

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR $T43[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN62@operator
$LN61@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR $T43[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN62@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 841  : 				--_Pad)	// pad on left

	mov	ecx, DWORD PTR __Pad$2$[ebp]
	add	ebx, -1
	mov	esi, 4
	adc	ecx, -1
	xor	edx, edx
	cmp	eax, -1
	mov	DWORD PTR __Pad$2$[ebp], ecx
	cmovne	esi, edx
	mov	DWORD PTR __State$[ebp], esi
	jmp	SHORT $LL4@operator
$LN180@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN81@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN81@operator

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	BYTE PTR [edx], 10			; 0000000aH
	jmp	SHORT $LN192@operator
$LN81@operator:
	mov	eax, DWORD PTR [ecx]
	push	10					; 0000000aH
	call	DWORD PTR [eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 847  : 			&& _Traits::eq_int_type(_Traits::eof(),

	cmp	eax, -1
	mov	eax, 4
	cmove	esi, eax
	mov	DWORD PTR __State$[ebp], esi
$LN192@operator:
	mov	eax, DWORD PTR __Pad$2$[ebp]
$LL189@operator:

; 848  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 849  : 			_State |= ios_base::badbit;
; 850  : 
; 851  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	$LN6@operator
	test	eax, eax
	jl	$LN6@operator
	jg	SHORT $LN188@operator
	test	ebx, ebx
	je	$LN6@operator
$LN188@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+edi+64]
	mov	BYTE PTR $T42[ebp], cl

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+edi+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN103@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN103@operator

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR $T42[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	ecx, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN104@operator
$LN103@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR $T42[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
	mov	ecx, eax
$LN104@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 852  : 			--_Pad)	// pad on right

	mov	eax, DWORD PTR __Pad$2$[ebp]
	add	ebx, -1
	mov	esi, 4
	adc	eax, -1
	xor	edx, edx
	cmp	ecx, -1
	mov	DWORD PTR __Pad$2$[ebp], eax
	cmovne	esi, edx
	mov	DWORD PTR __State$[ebp], esi
	jmp	SHORT $LL189@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 856  : 		_CATCH_IO_(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 856  : 		_CATCH_IO_(_Ostr)

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN126@operator
	or	eax, 4
$LN126@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 856  : 		_CATCH_IO_(_Ostr)

	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	edi, DWORD PTR __Ostr$[ebp]
	mov	esi, DWORD PTR __State$[ebp]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 857  : 		}
; 858  : 
; 859  : 	_Ostr.width(0);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN20@operator:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+edi+32], 0
	mov	DWORD PTR [eax+edi+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 860  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	esi, esi
	je	SHORT $LN141@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [ecx+12]
	or	edx, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [ecx+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN141@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN160@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN160@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN190@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN190@operator:

; 861  : 	return (_Ostr);
; 862  : 	}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -56						; size = 8
__Pad$ = -56						; size = 8
__State$ = -44						; size = 4
tv1128 = -40						; size = 4
__Val$1$ = -40						; size = 4
__Count$1$ = -36					; size = 4
__Pad$1$ = -32						; size = 4
tv1131 = -28						; size = 4
tv1124 = -28						; size = 4
__Ostr$ = -24						; size = 4
$T37 = -17						; size = 1
$T38 = -17						; size = 1
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 782  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 785  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	lea	esi, DWORD PTR [ecx+1]
$LL171@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL171@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 787  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	mov	edx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 447  : 		return (_CSTD strlen(_First));

	sub	ecx, esi
	mov	DWORD PTR __Count$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
	mov	DWORD PTR tv1131[ebp], eax
	mov	edi, DWORD PTR [eax+36]
	mov	esi, DWORD PTR [eax+32]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 787  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN173@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN173@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN173@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN186@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN186@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+56]
	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 98   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Pad$1$[ebp], edi
	mov	DWORD PTR __Ok$[ebp], ebx

; 99   : 			{	// lock the stream buffer, if there
; 100  : 			if (_Myostr.rdbuf() != 0)

	test	eax, eax
	je	SHORT $LN37@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, DWORD PTR tv1131[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+56]
	call	DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ebx]
	mov	ecx, edx
$LN37@operator:

; 120  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+4]
	add	eax, ebx
	mov	DWORD PTR tv1124[ebp], eax
	mov	eax, edx

; 339  : 		return (rdstate() == goodbit);

	mov	ebx, DWORD PTR tv1124[ebp]
	cmp	DWORD PTR [ebx+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	mov	ebx, DWORD PTR __Ostr$[ebp]
	jne	SHORT $LN33@operator
	mov	ebx, DWORD PTR tv1124[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 79   : 		return (_Tiestr);

	mov	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 122  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	cmp	DWORD PTR [ebx+60], 0
	mov	ebx, DWORD PTR __Ostr$[ebp]
	je	SHORT $LN33@operator
	mov	edi, DWORD PTR tv1124[ebp]
	mov	edx, DWORD PTR [edi+60]
	mov	edi, DWORD PTR __Pad$1$[ebp]
	cmp	edx, ebx
	je	SHORT $LN33@operator

; 123  : 				_Ostr.tie()->flush();

	mov	ecx, edx
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
	mov	eax, DWORD PTR [ebx]
	mov	ecx, eax
$LN33@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+ebx+12]

; 339  : 		return (rdstate() == goodbit);

	test	eax, eax
	sete	BYTE PTR __Ok$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 789  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
	test	eax, eax

; 790  : 
; 791  : 	if (!_Ok)

	je	SHORT $LN8@operator

; 792  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 793  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 794  : 		{	// state okay, insert
; 795  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+ebx+20]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 796  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN167@operator
	npad	5
$LL4@operator:

; 797  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN174@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN174@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+ebx+64]
	mov	BYTE PTR $T38[ebp], cl

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN67@operator
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [edx]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN67@operator

; 306  : 		--*_IPcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR $T38[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN68@operator
$LN67@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR $T38[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN68@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 798  : 				if (_Traits::eq_int_type(_Traits::eof(),

	cmp	eax, -1
	jne	SHORT $LN2@operator

; 799  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 800  : 					{	// insertion failed, quit
; 801  : 					_State |= ios_base::badbit;

	lea	ecx, DWORD PTR [eax+5]

; 802  : 					break;

	jmp	$LN6@operator
$LN2@operator:

; 797  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:

; 806  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	mov	ecx, DWORD PTR [ebx]
$LN167@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 206  : 		return (xsputn(_Ptr, _Count));

	push	0
	push	DWORD PTR __Count$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 206  : 		return (xsputn(_Ptr, _Count));

	push	DWORD PTR __Val$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+36]
	call	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 806  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	eax, DWORD PTR __Count$1$[ebp]
	jne	SHORT $LN175@operator
	test	edx, edx
	jne	SHORT $LN175@operator
$LL177@operator:

; 807  : 			_State |= ios_base::badbit;
; 808  : 
; 809  : 		if (_State == ios_base::goodbit)
; 810  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN181@operator
	jg	SHORT $LN176@operator
	test	esi, esi
	je	SHORT $LN181@operator
$LN176@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 112  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 91   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]

; 112  : 		return (_Fillch);

	mov	dl, BYTE PTR [eax+ebx+64]
	mov	BYTE PTR $T37[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 312  : 		return (*_IPnext != 0 ? *_IPcount : 0);

	mov	eax, DWORD PTR [ecx+32]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN93@operator
	mov	eax, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]

; 198  : 		return (0 < _Pnavail()

	test	eax, eax
	jle	SHORT $LN93@operator

; 306  : 		--*_IPcount;

	mov	edx, DWORD PTR [ecx+48]
	dec	eax
	mov	DWORD PTR [edx], eax

; 307  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax

; 198  : 		return (0 < _Pnavail()

	mov	al, BYTE PTR $T37[ebp]
	mov	BYTE PTR [edx], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	jmp	SHORT $LN94@operator
$LN93@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, dl
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 198  : 		return (0 < _Pnavail()

	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+12]
$LN94@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 811  : 				if (_Traits::eq_int_type(_Traits::eof(),

	cmp	eax, -1
	jne	SHORT $LN5@operator
$LN175@operator:

; 812  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 813  : 					{	// insertion failed, quit
; 814  : 					_State |= ios_base::badbit;
; 815  : 					break;
; 816  : 					}
; 817  : 		_Ostr.width(0);

	mov	ecx, 4
	jmp	SHORT $LN6@operator
$LN5@operator:

; 807  : 			_State |= ios_base::badbit;
; 808  : 
; 809  : 		if (_State == ios_base::goodbit)
; 810  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL177@operator
$LN181@operator:

; 812  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 813  : 					{	// insertion failed, quit
; 814  : 					_State |= ios_base::badbit;
; 815  : 					break;
; 816  : 					}
; 817  : 		_Ostr.width(0);

	xor	ecx, ecx
$LN6@operator:
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream
	jmp	SHORT $LN187@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 818  : 		_CATCH_IO_(_Ostr)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [edx+ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 818  : 		_CATCH_IO_(_Ostr)

	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 59   : 			clear((iostate)((int)rdstate() | (int)_State), _Reraise);

	or	eax, 4

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN118@operator
	or	eax, 4
$LN118@operator:
	push	1
	push	eax
	mov	ecx, edx
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 818  : 		_CATCH_IO_(_Ostr)

	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN187@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 819  : 		}
; 820  : 
; 821  : 	_Ostr.setstate(_State);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [eax+4]
	add	esi, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 58   : 		if (_State != goodbit)

	test	ecx, ecx
	je	SHORT $LN131@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xiosbase

; 315  : 		return (_Mystate);

	mov	edx, DWORD PTR [esi+12]
	or	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ios

; 44   : 		ios_base::clear((iostate)(_Mystrbuf == 0

	mov	ecx, esi
	mov	eax, edx
	or	eax, 4
	cmp	DWORD PTR [esi+56], 0
	push	0
	cmovne	eax, edx
	push	eax
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear
$LN131@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\ostream

; 135  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 136  :  #if _HAS_EXCEPTIONS
; 137  : 			if (!_STD uncaught_exception())	// TRANSITION, OS#15518458

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN150@operator

; 138  : 				{
; 139  : 				this->_Myostr._Osfx();

	mov	ecx, esi
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN150@operator:

; 105  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 106  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN178@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN178@operator:

; 822  : 	return (_Ostr);
; 823  : 	}

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 23   : 	{	// return smaller of _Left and _Right

	push	ebp
	mov	ebp, esp

; 24   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 25   : 	}

	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 388  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 389  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 390  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1555 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1556 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1557 : 	}

	pop	ebp
	ret	0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1902 : 		}

	mov	eax, ecx

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1902 : 		}

	ret	4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1555 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1556 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1557 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T3 = -72						; size = 52
__Lock$23 = -20						; size = 4
$T2 = -16						; size = 4
__Lock$24 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$25 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 501  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$23[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id

; 503  : 		const locale::facet *_Psave =
; 504  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 116  : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN12@use_facet

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$24[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN13@use_facet

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN13@use_facet:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$24[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN21@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	$LN91@use_facet
	jmp	SHORT $LN93@use_facet
$LN21@use_facet:

; 428  : 		}
; 429  : 
; 430  : 	const facet *_Getfacet(size_t _Id) const
; 431  : 		{	// look up a facet in locale object
; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN93@use_facet:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN18@use_facet

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN94@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 505  : 
; 506  : 		size_t _Id = _Facet::id;
; 507  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 508  : 
; 509  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN91@use_facet
$LN94@use_facet:

; 510  : 			;	// got facet from locale
; 511  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 512  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx

; 513  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	jmp	SHORT $LN91@use_facet
$LN4@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN36@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN41@use_facet
$LN36@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN41@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN41@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	lea	ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1278 : 		{	// construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$25[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 529  : 			_Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 530  :  #endif /* defined(_M_CEE) */
; 531  : 
; 532  : 			_Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 533  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN91@use_facet:

; 534  : 			_Pf = _Psave;
; 535  : 
; 536  : 			(void) _Psave_guard.release();
; 537  : 			}
; 538  : 
; 539  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$23[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 540  : 	_END_LOCK()
; 541  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$23[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$25[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T3 = -72						; size = 52
__Lock$23 = -20						; size = 4
$T2 = -16						; size = 4
__Lock$24 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$25 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 501  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$23[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id

; 503  : 		const locale::facet *_Psave =
; 504  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 116  : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN12@use_facet

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$24[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, edi ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
	jne	SHORT $LN13@use_facet

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A, eax ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN13@use_facet:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$24[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::id
$LN12@use_facet:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN21@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	$LN91@use_facet
	jmp	SHORT $LN93@use_facet
$LN21@use_facet:

; 428  : 		}
; 429  : 
; 430  : 	const facet *_Getfacet(size_t _Id) const
; 431  : 		{	// look up a facet in locale object
; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN93@use_facet:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN18@use_facet

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN94@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 505  : 
; 506  : 		size_t _Id = _Facet::id;
; 507  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 508  : 
; 509  : 		if (_Pf != 0)

	test	esi, esi
	jne	SHORT $LN91@use_facet
$LN94@use_facet:

; 510  : 			;	// got facet from locale
; 511  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 512  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx

; 513  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	jmp	SHORT $LN91@use_facet
$LN4@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN36@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN41@use_facet
$LN36@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN41@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN41@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	lea	ecx, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 348  : 		{	// construct from specified locale

	mov	DWORD PTR [esi], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$25[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 529  : 			_Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 530  :  #endif /* defined(_M_CEE) */
; 531  : 
; 532  : 			_Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 533  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >::_Psave
$LN91@use_facet:

; 534  : 			_Pf = _Psave;
; 535  : 
; 536  : 			(void) _Psave_guard.release();
; 537  : 			}
; 538  : 
; 539  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$23[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 540  : 	_END_LOCK()
; 541  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$23[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$3:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$25[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator==<char,std::char_traits<char> >, COMDAT

; 603  : 	{	// test for istreambuf_iterator equality

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 549  : 		if (!_Got)

	mov	edi, DWORD PTR __Left$[ebp]
	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN4@operator

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN14@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN18@operator
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN18@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN19@operator
$LN18@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN19@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN14@operator

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN13@operator
$LN14@operator:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN13@operator:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN4@operator:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN5@operator

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN37@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN41@operator
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN41@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN42@operator
$LN41@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN42@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN37@operator

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN36@operator
$LN37@operator:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN36@operator:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN5@operator:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
	jne	SHORT $LN58@operator
	test	eax, eax
	je	SHORT $LN9@operator
$LN8@operator:
	xor	al, al

; 604  : 	return (_Left.equal(_Right));
; 605  : 	}

	pop	ebp
	ret	0
$LN58@operator:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	je	SHORT $LN8@operator
$LN9@operator:
	mov	al, 1

; 604  : 	return (_Left.equal(_Right));
; 605  : 	}

	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T3 = -76						; size = 52
$T2 = -24						; size = 4
__Lock$24 = -20						; size = 4
$T1 = -16						; size = 4
__Lock$25 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Psave_guard$26 = 8					; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 501  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 502  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$24[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 116  : 			if (_Id == 0)

	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id

; 503  : 		const locale::facet *_Psave =
; 504  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	ebx, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave

; 116  : 			if (_Id == 0)

	test	edi, edi
	jne	SHORT $LN12@use_facet

; 117  : 				{	// still zero, allocate stamp
; 118  : 				_BEGIN_LOCK(_LOCK_LOCALE)

	push	edi
	lea	ecx, DWORD PTR __Lock$25[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 119  : 					if (_Id == 0)

	cmp	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, edi ; std::numpunct<char>::id
	jne	SHORT $LN13@use_facet

; 120  : 						_Id = ++_Id_cnt;

	mov	eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	inc	eax
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
	mov	DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A, eax ; std::numpunct<char>::id
$LN13@use_facet:

; 121  : 				_END_LOCK()

	lea	ecx, DWORD PTR __Lock$25[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	edi, DWORD PTR ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
$LN12@use_facet:

; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	mov	ecx, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+12]
	jae	SHORT $LN21@use_facet
	mov	eax, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	test	esi, esi
	jne	$LN90@use_facet
	jmp	SHORT $LN92@use_facet
$LN21@use_facet:

; 428  : 		}
; 429  : 
; 430  : 	const facet *_Getfacet(size_t _Id) const
; 431  : 		{	// look up a facet in locale object
; 432  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

	xor	esi, esi
$LN92@use_facet:

; 433  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 434  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN18@use_facet

; 435  : 			return (_Facptr);	// found facet or not transparent
; 436  : 		else
; 437  : 			{	// look in current locale
; 438  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

	call	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale

; 439  : 			return (_Id < _Ptr0->_Facetcount

	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN93@use_facet
	mov	eax, DWORD PTR [eax+8]
	mov	esi, DWORD PTR [eax+edi*4]
$LN18@use_facet:

; 505  : 
; 506  : 		size_t _Id = _Facet::id;
; 507  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 508  : 
; 509  : 		if (_Pf != 0)

	test	esi, esi
	jne	$LN90@use_facet
$LN93@use_facet:

; 510  : 			;	// got facet from locale
; 511  : 		else if (_Psave != 0)

	test	ebx, ebx
	je	SHORT $LN4@use_facet

; 512  : 			_Pf = _Psave;	// lazy facet already allocated

	mov	esi, ebx

; 513  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

	jmp	$LN90@use_facet
$LN4@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 168  : 			*_Ppf = new numpunct<_Elem>(

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR __Loc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $LN36@use_facet
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN41@use_facet
$LN36@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jne	SHORT $LN41@use_facet
	lea	eax, DWORD PTR [ecx+28]
$LN41@use_facet:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 168  : 			*_Ppf = new numpunct<_Elem>(

	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR $T1[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 161  : 		_Init(_Lobj, _Isdef);

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, esi
	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 168  : 			*_Ppf = new numpunct<_Elem>(

	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR __Psave_guard$26[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 529  : 			_Facet_Register(_Pfmod);

	push	esi
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	call	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register

; 530  :  #endif /* defined(_M_CEE) */
; 531  : 
; 532  : 			_Pfmod->_Incref();

	mov	edx, DWORD PTR [esi]
	add	esp, 4
	mov	ecx, esi
	call	DWORD PTR [edx+4]

; 533  : 			_Facetptr<_Facet>::_Psave = _Psave;

	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, esi ; std::_Facetptr<std::numpunct<char> >::_Psave
$LN90@use_facet:

; 534  : 			_Pf = _Psave;
; 535  : 
; 536  : 			(void) _Psave_guard.release();
; 537  : 			}
; 538  : 
; 539  : 		return (static_cast<const _Facet&>(*_Pf));	// should be dynamic_cast

	lea	ecx, DWORD PTR __Lock$24[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, esi

; 540  : 	_END_LOCK()
; 541  : 	}	// end of use_facet body

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
	lea	ecx, DWORD PTR __Lock$24[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$3:
	push	24					; 00000018H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$4:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN32@use_facet
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN32@use_facet:
	ret	0
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$5:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
	lea	ecx, DWORD PTR __Psave_guard$26[ebp]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT
tv1324 = -72						; size = 4
__Ans$1$ = -68						; size = 4
__Numfields$2$ = -64					; size = 4
__Last$GSCopy$1$ = -60					; size = 4
__Ptr$1$ = -56						; size = 4
__Str$1$ = -52						; size = 4
__Column$1$ = -48					; size = 4
__Prefix$1$ = -41					; size = 1
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Numfields$ = 16					; size = 4
__Ptr$ = 20						; size = 4
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z PROC ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT

; 548  : 	{	// find field at _Ptr that matches longest in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edi, DWORD PTR __First$[ebp]

; 549  : 	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)

	mov	esi, DWORD PTR __Numfields$[ebp]
	mov	DWORD PTR __Last$GSCopy$1$[ebp], ecx
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	bl, BYTE PTR [ecx]
	test	bl, bl
	je	SHORT $LN320@Getloctxt
	mov	dl, bl
$LL4@Getloctxt:
	cmp	dl, bl
	lea	eax, DWORD PTR [esi+1]
	mov	dl, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	cmovne	eax, esi
	mov	esi, eax
	test	dl, dl
	jne	SHORT $LL4@Getloctxt
	mov	DWORD PTR __Numfields$2$[ebp], eax
	jmp	SHORT $LN3@Getloctxt
$LN320@Getloctxt:
	mov	DWORD PTR __Numfields$2$[ebp], esi
$LN3@Getloctxt:

; 550  : 		if (_Ptr[_Off] == _Ptr[0])
; 551  : 			++_Numfields;	// add fields with leading mark to initial count
; 552  : 	string _Str(_Numfields, '\0');	// one column counter for each field

	push	0
	push	esi
	lea	ecx, DWORD PTR __Str$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 555  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	mov	eax, DWORD PTR __Str$[ebp+20]
	mov	ecx, DWORD PTR __Str$[ebp]
	mov	DWORD PTR __Ans$1$[ebp], -2		; fffffffeH
	mov	DWORD PTR __Column$1$[ebp], 1
	mov	DWORD PTR __Str$1$[ebp], eax
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	npad	6
$LL7@Getloctxt:

; 556  : 		{	// test each element against all viable fields
; 557  : 		bool _Prefix = false;	// seen at least one valid prefix

	xor	ebx, ebx
	mov	BYTE PTR __Prefix$1$[ebp], 0

; 558  : 		size_t _Off = 0;	// offset into fields

	xor	esi, esi

; 561  : 		for (; _Field < _Numfields; ++_Field)

	cmp	DWORD PTR __Numfields$2$[ebp], ebx
	jbe	$LN192@Getloctxt
	mov	edx, DWORD PTR __Ptr$[ebp]
$LL10@Getloctxt:

; 562  : 			{	// test element at _Column in field _Field
; 563  : 			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)

	mov	al, BYTE PTR [esi+edx]
	test	al, al
	je	SHORT $LN12@Getloctxt
	mov	cl, BYTE PTR [edx]
	npad	3
$LL13@Getloctxt:
	cmp	al, cl
	je	SHORT $LN321@Getloctxt
	mov	al, BYTE PTR [esi+edx+1]
	inc	esi
	test	al, al
	jne	SHORT $LL13@Getloctxt
$LN321@Getloctxt:
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
$LN12@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$1$[ebp], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 566  : 			if (_Str[_Field] != '\0')

	cmp	BYTE PTR [eax+ebx], 0
	je	SHORT $LN15@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$1$[ebp], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	eax, DWORD PTR __Str$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 567  : 				_Off += _Str[_Field];	// skip tested columns in field

	movsx	eax, BYTE PTR [eax+ebx]
	add	esi, eax

; 568  : 			else if (_Ptr[_Off += _Column] == _Ptr[0]

	jmp	$LN325@Getloctxt
$LN15@Getloctxt:

; 569  : 				|| _Ptr[_Off] == (_Elem)0)

	add	esi, DWORD PTR __Column$1$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR tv1324[ebp], eax
	mov	al, BYTE PTR [eax]
	cmp	al, BYTE PTR [edx]
	je	$LN19@Getloctxt
	test	al, al
	je	$LN19@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN92@Getloctxt

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN102@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN106@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN106@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN107@Getloctxt
$LN106@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN107@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN102@Getloctxt

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN101@Getloctxt
$LN102@Getloctxt:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN101@Getloctxt:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN92@Getloctxt:

; 551  : 		if (!_Right._Got)

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [eax+4], 0
	jne	SHORT $LN93@Getloctxt

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN125@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN129@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN129@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN130@Getloctxt
$LN129@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN130@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN322@Getloctxt

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	ecx, DWORD PTR __Last$GSCopy$1$[ebp]
	mov	BYTE PTR [ecx+5], al
	mov	eax, ecx
	jmp	SHORT $LN124@Getloctxt
$LN322@Getloctxt:

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	eax, DWORD PTR __Last$GSCopy$1$[ebp]
$LN125@Getloctxt:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [eax], 0
$LN124@Getloctxt:

; 582  : 		_Got = true;

	mov	BYTE PTR [eax+4], 1
$LN93@Getloctxt:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN316@Getloctxt
	test	eax, eax
	jne	SHORT $LN309@Getloctxt
$LN319@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$1$[ebp], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]

; 1787 : 		if (_Large_string_engaged())

	cmovae	edx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 578  : 			else

	jmp	SHORT $LN326@Getloctxt
$LN316@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN319@Getloctxt
$LN309@Getloctxt:

; 512  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN146@Getloctxt

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN151@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN155@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN155@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN156@Getloctxt
$LN155@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN156@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN151@Getloctxt

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN150@Getloctxt
$LN151@Getloctxt:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN150@Getloctxt:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN146@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 575  : 			else if (_First == _Last || _Ptr[_Off] != *_First)

	mov	eax, DWORD PTR tv1324[ebp]
	mov	al, BYTE PTR [eax]
	cmp	al, BYTE PTR [edi+5]
	jne	SHORT $LN319@Getloctxt

; 579  : 				_Prefix = true;	// still a valid prefix

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	ah, 1
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	BYTE PTR __Prefix$1$[ebp], ah
	jmp	SHORT $LN8@Getloctxt
$LN19@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	cmp	DWORD PTR __Str$1$[ebp], 16		; 00000010H

; 1786 : 		value_type * _Result = _Bx._Buf;

	lea	edx, DWORD PTR __Str$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 573  : 				_Ans = (int)_Field;	// save answer

	mov	DWORD PTR __Ans$1$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1787 : 		if (_Large_string_engaged())

	cmovae	edx, ecx
$LN326@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 561  : 		for (; _Field < _Numfields; ++_Field)

	mov	eax, DWORD PTR __Column$1$[ebp]
	mov	ecx, 127				; 0000007fH
	cmp	eax, ecx
	movzx	eax, al
	cmovb	ecx, eax
	mov	BYTE PTR [edx+ebx], cl
	mov	ecx, DWORD PTR __Str$[ebp]
	mov	eax, DWORD PTR __Str$[ebp+20]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Ptr$1$[ebp], ecx
	mov	DWORD PTR __Str$1$[ebp], eax
$LN325@Getloctxt:
	mov	ah, BYTE PTR __Prefix$1$[ebp]
$LN8@Getloctxt:
	inc	ebx
	cmp	ebx, DWORD PTR __Numfields$2$[ebp]
	jb	$LL10@Getloctxt

; 580  : 			}
; 581  : 
; 582  : 		if (!_Prefix || _First == _Last)

	test	ah, ah
	je	$LN192@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 549  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN187@Getloctxt

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN197@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN201@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN201@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN202@Getloctxt
$LN201@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN202@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN197@Getloctxt

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN196@Getloctxt
$LN197@Getloctxt:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN196@Getloctxt:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN187@Getloctxt:

; 551  : 		if (!_Right._Got)

	mov	ebx, DWORD PTR __Last$GSCopy$1$[ebp]
	cmp	BYTE PTR [ebx+4], 0
	jne	SHORT $LN188@Getloctxt

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN220@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN224@Getloctxt
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN224@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN225@Getloctxt
$LN224@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN225@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN220@Getloctxt

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [ebx+5], al
	jmp	SHORT $LN219@Getloctxt
$LN220@Getloctxt:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [ebx], 0
$LN219@Getloctxt:

; 582  : 		_Got = true;

	mov	BYTE PTR [ebx+4], 1
$LN188@Getloctxt:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ebx]
	test	ecx, ecx
	jne	SHORT $LN315@Getloctxt
	test	eax, eax
	jne	SHORT $LN191@Getloctxt
$LN192@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1808 : 		return (_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR __Str$1$[ebp]
	cmp	eax, 16					; 00000010H

; 3961 : 		if (_My_data._Large_string_engaged())

	jb	$LN277@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	edx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3966 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	lea	ecx, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, edx

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN276@Getloctxt

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edx-4]
	add	ecx, 35					; 00000023H
	sub	eax, edx

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	$LN328@Getloctxt
	jmp	SHORT $LN276@Getloctxt
$LN315@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	jne	SHORT $LN192@Getloctxt
$LN191@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 555  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	inc	DWORD PTR __Column$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	test	ecx, ecx
	je	SHORT $LN32@Getloctxt

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN36@Getloctxt
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edx]

; 148  : 		return (0 < _Gnavail()

	test	eax, eax
	jle	SHORT $LN36@Getloctxt

; 269  : 		--*_IGcount;

	dec	eax
	mov	DWORD PTR [edx], eax

; 270  : 		return ((*_IGnext)++);

	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 148  : 		return (0 < _Gnavail()

	jmp	SHORT $LN37@Getloctxt
$LN36@Getloctxt:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+28]
$LN37@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 561  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN32@Getloctxt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 555  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	mov	ecx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 569  : 			_Got = false;

	xor	al, al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 555  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	mov	BYTE PTR [edi+4], al
	mov	DWORD PTR __Ans$1$[ebp], -1
	jmp	$LL7@Getloctxt
$LN32@Getloctxt:
	mov	ecx, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 565  : 			_Got = true;

	mov	al, 1
	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 555  : 	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)

	mov	BYTE PTR [edi+4], al
	mov	DWORD PTR __Ans$1$[ebp], -1
	jmp	$LL7@Getloctxt
$LN276@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN277@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 585  : 	return (_Ans);	// return field number or negative value on failure

	mov	eax, DWORD PTR __Ans$1$[ebp]

; 586  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN328@Getloctxt:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN324@Getloctxt:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z$0:
	lea	ecx, DWORD PTR __Str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z ENDP ; std::_Getloctxt<char,std::istreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 316  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 316  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 372  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 373  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 374  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 926  : 		_Ptr->~_Uty();
; 927  : 		}

	ret	0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>, COMDAT
; _this$ = ecx

; 3861 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	push	ecx

; 3862 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3863 : 		if (_New_size > max_size())

	mov	eax, DWORD PTR __New_size$[ebp]
	push	ebx
	mov	ebx, ecx
	push	edi
	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN102@Reallocate

; 3866 : 			}
; 3867 : 
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	esi, eax

; 3866 : 			}
; 3867 : 
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], ecx

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN88@Reallocate

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	edi, edi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	movsx	eax, BYTE PTR _<_Args_0>$[ebp]
	push	eax
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [ebx+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	call	_memset

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR __New_size$[ebp]

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	ecx, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	pop	esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN89@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN88@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN89@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3887 : 		return (*this);

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	ebx

; 3888 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN88@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN102@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN100@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c6753c90be971fc9cc00b4f35f237a75>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_c6753c90be971fc9cc00b4f35f237a75>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
tv540 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv539 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
tv541 = 20						; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 3893 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 3894 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3895 : 		auto& _My_data = this->_Get_data();
; 3896 : 		const size_type _Old_size = _My_data._Mysize;
; 3897 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR __Size_increase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	push	edi
	cmp	eax, esi
	jb	$LN114@Reallocate

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [edx+esi]

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	edi, eax

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	cmp	edi, ecx

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3906 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN92@Reallocate

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	esi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	esi, esi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3908 : 		_My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 3909 : 		_My_data._Myres = _New_capacity;
; 3910 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	movsx	eax, BYTE PTR _<_Args_1>$[ebp]
	mov	DWORD PTR tv541[ebp], eax
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	edi, DWORD PTR [esi+edx]
	add	eax, edi
	mov	DWORD PTR tv540[ebp], edi

; 3911 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR tv539[ebp], eax
	push	edx
	jb	SHORT $LN3@Reallocate

; 3912 : 			{
; 3913 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
	push	esi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	DWORD PTR _<_Args_0>$[ebp]
	push	DWORD PTR tv541[ebp]
	push	DWORD PTR tv540[ebp]
	call	_memset

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR tv539[ebp]

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN92@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edi, edx
$LN93@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	esi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	DWORD PTR _<_Args_0>$[ebp]
	push	DWORD PTR tv541[ebp]
	push	edi
	call	_memset

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR tv539[ebp]

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	add	esp, 24					; 00000018H

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN114@Reallocate:

; 3898 : 			{
; 3899 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN92@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN112@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
tv533 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv532 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3893 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 3894 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3895 : 		auto& _My_data = this->_Get_data();
; 3896 : 		const size_type _Old_size = _My_data._Mysize;
; 3897 : 		if (max_size() - _Old_size < _Size_increase)

	mov	ecx, 2147483647				; 7fffffffH
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR __Size_increase$[ebp]
	mov	edx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	DWORD PTR __Old_size$1$[ebp], edx
	push	edi
	cmp	eax, esi
	jb	$LN114@Reallocate

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	lea	eax, DWORD PTR [edx+esi]

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	edi, eax

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	cmp	edi, ecx

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	edi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, esi
	shr	eax, 1
	sub	ecx, eax
	cmp	esi, ecx
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3906 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN92@Reallocate

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edx, DWORD PTR __Old_size$1$[ebp]

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	esi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	esi, esi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3908 : 		_My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax

; 3909 : 		_My_data._Myres = _New_capacity;
; 3910 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	DWORD PTR [ebx+20], edi
	lea	edi, DWORD PTR [esi+edx]
	add	eax, edi
	mov	DWORD PTR tv533[ebp], edi

; 3911 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR tv532[ebp], eax
	push	edx
	jb	SHORT $LN3@Reallocate

; 3912 : 			{
; 3913 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
	push	esi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	push	DWORD PTR _<_Args_0>$[ebp]
	push	DWORD PTR tv533[ebp]
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR tv532[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN92@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edi, edx
$LN93@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	esi
	call	_memcpy
	push	DWORD PTR _<_Args_1>$[ebp]
	push	DWORD PTR _<_Args_0>$[ebp]
	push	edi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR tv532[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 24					; 00000018H

; 489  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	eax, ebx
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN114@Reallocate:

; 3898 : 			{
; 3899 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN92@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN112@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 918  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 919  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 920  : 			_Objty(_STD forward<_Types>(_Args)...);
; 921  : 		}

	pop	ebp
	ret	0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 372  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 373  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 374  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 191  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

	push	ebp
	mov	ebp, esp

; 192  :  #if defined(_M_IX86) || defined(_M_X64)
; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	mov	ecx, DWORD PTR __Bytes$[ebp]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new

; 102  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	__invalid_parameter_noinfo_noreturn

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 205  : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 194  : 		{	// boost the alignment of big allocations to help autovectorization
; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

	mov	DWORD PTR __Bytes$[ebp], ecx

; 205  : 	}

	pop	ebp

; 52   : 		return (::operator new(_Bytes));

	jmp	??2@YAPAXI@Z				; operator new
$LN3@Allocate:

; 200  : 		{
; 201  : 		return (_Traits::_Allocate(_Bytes));
; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	eax, eax

; 205  : 	}

	pop	ebp
	ret	0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 210  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

	push	ebp
	mov	ebp, esp

; 211  :  #if defined(_M_IX86) || defined(_M_X64)
; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	mov	ecx, DWORD PTR __Bytes$[ebp]
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	ecx, 35					; 00000023H
	mov	edx, DWORD PTR [eax-4]

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	jbe	SHORT $LN7@Deallocate

; 140  : 		{
; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	jmp	__invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 211  :  #if defined(_M_IX86) || defined(_M_X64)
; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	mov	edx, DWORD PTR __Ptr$[ebp]
$LN7@Deallocate:

; 213  : 		{	// boost the alignment of big allocations to help autovectorization
; 214  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 215  : 		}
; 216  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 217  : 
; 218  : 	::operator delete(_Ptr, _Bytes);

	mov	DWORD PTR __Bytes$[ebp], ecx
	mov	DWORD PTR __Ptr$[ebp], edx

; 219  : 	}

	pop	ebp

; 213  : 		{	// boost the alignment of big allocations to help autovectorization
; 214  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 215  : 		}
; 216  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 217  : 
; 218  : 	::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPAXI@Z				; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z PROC ; std::operator!=<char,std::char_traits<char> >, COMDAT

; 612  : 	{	// test for istreambuf_iterator inequality

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 549  : 		if (!_Got)

	mov	edi, DWORD PTR __Left$[ebp]
	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN6@operator

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN16@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN20@operator
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN20@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN21@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN16@operator

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN15@operator
$LN16@operator:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN15@operator:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN6@operator:

; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN7@operator

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN39@operator

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN43@operator
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN43@operator
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN44@operator
$LN43@operator:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN44@operator:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN39@operator

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN38@operator
$LN39@operator:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN38@operator:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN7@operator:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
	jne	SHORT $LN60@operator
	test	eax, eax
	je	SHORT $LN11@operator
$LN10@operator:
	mov	al, 1

; 613  : 	return (!(_Left == _Right));
; 614  : 	}

	pop	ebp
	ret	0
$LN60@operator:

; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	je	SHORT $LN10@operator
$LN11@operator:
	xor	al, al

; 613  : 	return (!(_Left == _Right));
; 614  : 	}

	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??$_Find_elem@D@std@@YAIPADD@Z
_TEXT	SEGMENT
__Base$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$_Find_elem@D@std@@YAIPADD@Z PROC			; std::_Find_elem<char>, COMDAT

; 90   : 	{	// lookup _Ch in NUL-terminated string _Base

	push	ebp
	mov	ebp, esp
	push	esi

; 91   : 	_Elem *_Ptr = _Base;

	mov	esi, DWORD PTR __Base$[ebp]
	mov	eax, esi

; 92   : 	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)

	mov	cl, BYTE PTR [esi]
	test	cl, cl
	je	SHORT $LN10@Find_elem
	mov	dl, BYTE PTR __Ch$[ebp]
$LL4@Find_elem:
	cmp	cl, dl
	je	SHORT $LN10@Find_elem
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL4@Find_elem
$LN10@Find_elem:

; 93   : 		;
; 94   : 	return ((size_t)(_Ptr - _Base));

	sub	eax, esi
	pop	esi

; 95   : 	}

	pop	ebp
	ret	0
??$_Find_elem@D@std@@YAIPADD@Z ENDP			; std::_Find_elem<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3861 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	push	ecx

; 3862 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3863 : 		if (_New_size > max_size())

	mov	eax, DWORD PTR __New_size$[ebp]
	push	ebx
	mov	ebx, ecx
	push	edi
	cmp	eax, 2147483647				; 7fffffffH
	ja	$LN102@Reallocate

; 3866 : 			}
; 3867 : 
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	ecx, DWORD PTR [ebx+20]
	push	esi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	esi, eax

; 3866 : 			}
; 3867 : 
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], ecx

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	esi, 15					; 0000000fH
	cmp	esi, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	edx, ecx
	mov	eax, 2147483647				; 7fffffffH
	shr	edx, 1
	sub	eax, edx
	cmp	ecx, eax
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3872 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	SHORT $LN88@Reallocate

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	edi, edi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	DWORD PTR _<_Args_0>$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3874 : 		_My_data._Mysize = _New_size;

	mov	DWORD PTR [ebx+16], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3875 : 		_My_data._Myres = _New_capacity;

	mov	DWORD PTR [ebx+20], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	call	_memcpy

; 489  : 		_Left = _Right;

	mov	eax, DWORD PTR __New_size$[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	mov	ecx, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3877 : 		if (this->_BUF_SIZE <= _Old_capacity)

	pop	esi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN3@Reallocate
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 1031 : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3879 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN89@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [eax-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	eax, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	add	eax, -4					; fffffffcH
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN88@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, edx
$LN89@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3887 : 		return (*this);

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	ebx

; 3888 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN88@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN102@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3865 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN100@Reallocate:
	int	3
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
tv536 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$dead$ = 8				; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3893 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 3894 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3895 : 		auto& _My_data = this->_Get_data();
; 3896 : 		const size_type _Old_size = _My_data._Mysize;
; 3897 : 		if (max_size() - _Old_size < _Size_increase)

	mov	edx, 2147483647				; 7fffffffH
	mov	eax, edx
	push	esi
	push	edi
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, ecx
	mov	DWORD PTR __Old_size$1$[ebp], ecx
	cmp	eax, 1
	jb	$LN114@Reallocate

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	esi, DWORD PTR [ebx+20]
	lea	edi, DWORD PTR [ecx+1]

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	edi, 15					; 0000000fH

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;
; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], esi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	cmp	edi, edx

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	edi, edx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	cmp	esi, edx
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	edi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edi, eax
	cmovb	edi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3906 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	edx, DWORD PTR [edi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [edx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	ecx, -1
	cmp	eax, edx
	cmovbe	eax, ecx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN92@Reallocate

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	esi, DWORD PTR [eax+35]
	and	esi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [esi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	edx, edx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	edx
	call	??2@YAPAXI@Z				; operator new

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	ecx, DWORD PTR __Old_size$1$[ebp]

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	esi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	esi, esi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3911 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+20], edi
	lea	edi, DWORD PTR [esi+ecx]
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR tv536[ebp], edi
	push	ecx
	jb	SHORT $LN3@Reallocate

; 3912 : 			{
; 3913 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	edi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	edi
	push	esi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	ecx, DWORD PTR tv536[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR _<_Args_0>$[ebp]
	mov	BYTE PTR [ecx], al
	mov	BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [edi-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	edi, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	lea	eax, DWORD PTR [edi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN92@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	edi, edx
$LN93@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	esi
	call	_memcpy

; 489  : 		_Left = _Right;

	mov	al, BYTE PTR _<_Args_0>$[ebp]

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 12					; 0000000cH

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi], al
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 489  : 		_Left = _Right;

	mov	BYTE PTR [edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], esi
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN114@Reallocate:

; 3898 : 			{
; 3899 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN92@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN112@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
tv551 = -12						; size = 4
tv549 = -8						; size = 4
__New_size$1$ = -8					; size = 4
tv550 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Old$1$ = 8						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
tv552 = 24						; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 3893 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3894 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3895 : 		auto& _My_data = this->_Get_data();
; 3896 : 		const size_type _Old_size = _My_data._Mysize;
; 3897 : 		if (max_size() - _Old_size < _Size_increase)

	mov	edx, DWORD PTR __Size_increase$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 2147483647				; 7fffffffH
	push	esi
	mov	eax, ecx
	push	edi
	mov	esi, DWORD PTR [ebx+16]
	sub	eax, esi
	mov	DWORD PTR __Old_size$1$[ebp], esi
	cmp	eax, edx
	jb	$LN114@Reallocate

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	edi, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR [esi+edx]

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	esi, eax

; 3900 : 			}
; 3901 : 
; 3902 : 		const size_type _New_size = _Old_size + _Size_increase;

	mov	DWORD PTR __New_size$1$[ebp], eax

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	or	esi, 15					; 0000000fH

; 3903 : 		const size_type _Old_capacity = _My_data._Myres;

	mov	DWORD PTR __Old$1$[ebp], edi

; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	cmp	esi, ecx

; 3844 : 		if (_Masked > _Max)

	jbe	SHORT $LN25@Reallocate

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);

	mov	esi, ecx
	jmp	SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;
; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, edi
	shr	eax, 1
	sub	ecx, eax
	cmp	edi, ecx
	jbe	SHORT $LN26@Reallocate

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	esi, 2147483647				; 7fffffffH
	jmp	SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3853 : 			}
; 3854 : 
; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	esi, eax
	cmovb	esi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3906 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

	lea	ecx, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 193  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	lea	eax, DWORD PTR [ecx+35]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	cmp	eax, ecx
	cmovbe	eax, edx

; 52   : 		return (::operator new(_Bytes));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	eax, eax
	je	$LN92@Reallocate

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	edi, DWORD PTR [eax+35]
	and	edi, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [edi-4], eax

; 195  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 196  : 		}
; 197  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 198  : 
; 199  : 	if (_Bytes != 0)

	test	ecx, ecx
	je	SHORT $LN58@Reallocate

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 201  : 		return (_Traits::_Allocate(_Bytes));

	mov	edi, eax
	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 202  : 		}
; 203  : 
; 204  : 	return (nullptr);

	xor	edi, edi
$LN56@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3908 : 		_My_data._Mysize = _New_size;

	mov	eax, DWORD PTR __New_size$1$[ebp]

; 3909 : 		_My_data._Myres = _New_capacity;
; 3910 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

	mov	ecx, DWORD PTR __Old_size$1$[ebp]
	mov	DWORD PTR [ebx+16], eax
	movsx	eax, BYTE PTR _<_Args_2>$[ebp]
	mov	DWORD PTR tv552[ebp], eax
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	sub	ecx, eax
	inc	ecx
	mov	DWORD PTR [ebx+20], esi
	mov	DWORD PTR tv550[ebp], ecx
	mov	ecx, DWORD PTR _<_Args_1>$[ebp]
	lea	esi, DWORD PTR [edi+eax]
	add	ecx, esi
	mov	DWORD PTR tv551[ebp], esi

; 3911 : 		if (this->_BUF_SIZE <= _Old_capacity)

	cmp	DWORD PTR __Old$1$[ebp], 16		; 00000010H
	mov	DWORD PTR tv549[ebp], ecx
	push	eax
	jb	SHORT $LN3@Reallocate

; 3912 : 			{
; 3913 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	esi
	push	edi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	DWORD PTR _<_Args_1>$[ebp]
	push	DWORD PTR tv552[ebp]
	push	DWORD PTR tv551[ebp]
	call	_memset

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	DWORD PTR tv550[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	add	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	DWORD PTR tv549[ebp]
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	mov	ecx, DWORD PTR __Old$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3915 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 212  : 	if (_Bytes >= _Big_allocation_threshold)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN93@Reallocate

; 120  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

	mov	edx, DWORD PTR [esi-4]
	add	ecx, 35					; 00000023H

; 121  : 
; 122  :   #ifdef _DEBUG
; 123  : 	// If the following asserts, it likely means that we are performing
; 124  : 	// an aligned delete on memory coming from an unaligned allocation.
; 125  : 	if (_Ptr_user[-2] != _Big_allocation_sentinel)
; 126  : 		{
; 127  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;
; 128  : 		}
; 129  :   #endif /* _DEBUG */
; 130  : 
; 131  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 132  : 	// in range [_Min_back_shift, _Non_user_size]
; 133  :   #ifdef _DEBUG
; 134  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 135  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 136  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 137  :   #endif /* _DEBUG */
; 138  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	esi, edx

; 139  : 	if (_Back_shift < _Min_back_shift || _Back_shift > _Non_user_size)

	lea	eax, DWORD PTR [esi-4]
	cmp	eax, 31					; 0000001fH
	ja	SHORT $LN92@Reallocate

; 142  : 		}
; 143  : 
; 144  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	esi, edx
$LN93@Reallocate:

; 218  : 	::operator delete(_Ptr, _Bytes);

	push	ecx
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	ebx
	push	edi
	call	_memcpy

; 484  : 		return (static_cast<char *>(_CSTD memset(_First, _Ch, _Count)));

	push	DWORD PTR _<_Args_1>$[ebp]
	push	DWORD PTR tv552[ebp]
	push	esi
	call	_memset

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	DWORD PTR tv550[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 2787 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 454  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

	push	eax
	push	DWORD PTR tv549[ebp]
	call	_memcpy
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3924 : 		return (*this);

	mov	DWORD PTR [ebx], edi
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx

; 3925 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN114@Reallocate:

; 3898 : 			{
; 3899 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN92@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0

; 141  : 		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

	call	__invalid_parameter_noinfo_noreturn
$LN112@Reallocate:
	int	3
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 372  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 373  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 374  : 	}

	pop	ebp
	ret	0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1139 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1140 : 	_Pocma(_Left, _Right, _Tag);
; 1141 : 	}

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 68   :     {

	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 67   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	___std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7bad_cast@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 2283 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 2293 : 		pointer _Ans = get();
; 2294 : 		this->_Myptr() = pointer();

	mov	DWORD PTR [ecx], 0

; 2295 : 		return (_Ans);
; 2296 : 		}

	ret	0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 2265 : 		if (get() != pointer())

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN22@unique_ptr

; 2055 : 		delete _Ptr;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN22@unique_ptr:

; 2266 : 			{
; 2267 : 			this->get_deleter()(get());
; 2268 : 			}
; 2269 : 		}

	ret	0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T3 = -68						; size = 52
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 166  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T1[ebp], 0

; 167  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[ebp]
	test	esi, esi
	je	SHORT $LN25@Getcat
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN25@Getcat

; 168  : 			*_Ppf = new numpunct<_Elem>(

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 168  : 			*_Ppf = new numpunct<_Elem>(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN12@Getcat
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [edx+24]
	test	ecx, ecx
	jne	SHORT $LN17@Getcat
	lea	ecx, DWORD PTR [edx+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 168  : 			*_Ppf = new numpunct<_Elem>(

	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR $T1[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [edi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 161  : 		_Init(_Lobj, _Isdef);

	push	1
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, edi
	push	eax
	mov	DWORD PTR [edi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 168  : 			*_Ppf = new numpunct<_Elem>(

	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [esi], edi
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN25@Getcat:

; 169  : 				_Locinfo(_Ploc->c_str()), 0, true);
; 170  : 		return (_X_NUMERIC);
; 171  : 		}

	mov	eax, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	push	24					; 00000018H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN8@Getcat
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN8@Getcat:
	ret	0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$2:
	mov	ecx, DWORD PTR $T2[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T3 = -64						; size = 52
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 319  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 320  : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[ebp]
	test	esi, esi
	je	SHORT $LN26@Getcat
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN26@Getcat

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN12@Getcat
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN17@Getcat
	lea	ecx, DWORD PTR [eax+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [edi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	lea	ecx, DWORD PTR $T3[ebp]

; 348  : 		{	// construct from specified locale

	mov	DWORD PTR [edi], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 321  : 			*_Ppf = new num_get<_Elem, _InIt>(

	mov	DWORD PTR [esi], edi
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@Getcat:

; 322  : 				_Locinfo(_Ploc->c_str()));
; 323  : 		return (_X_NUMERIC);
; 324  : 		}

	mov	eax, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z PROC ; std::istreambuf_iterator<char,std::char_traits<char> >::equal, COMDAT
; _this$ = ecx

; 548  : 		{	// test for equality

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, ecx

; 549  : 		if (!_Got)

	cmp	BYTE PTR [edi+4], 0
	jne	SHORT $LN2@equal

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN12@equal

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN16@equal
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN16@equal
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN17@equal
$LN16@equal:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN17@equal:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN12@equal

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [edi+5], al
	jmp	SHORT $LN11@equal
$LN12@equal:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [edi], 0
$LN11@equal:

; 582  : 		_Got = true;

	mov	BYTE PTR [edi+4], 1
$LN2@equal:

; 550  : 			_Peek();
; 551  : 		if (!_Right._Got)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN3@equal

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN35@equal

; 281  : 		return (*_IGnext != 0 ? *_IGcount : 0);

	mov	eax, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN39@equal
	mov	eax, DWORD PTR [ecx+44]

; 154  : 		return (0 < _Gnavail()

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN39@equal
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 509  : 		return (static_cast<unsigned char>(_Ch));

	movzx	eax, BYTE PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 154  : 		return (0 < _Gnavail()

	jmp	SHORT $LN40@equal
$LN39@equal:
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+24]
$LN40@equal:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\iosfwd

; 514  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf

; 577  : 			|| traits_type::eq_int_type(traits_type::eof(),

	je	SHORT $LN35@equal

; 580  : 		else
; 581  : 			_Val = traits_type::to_char_type(_Meta);

	mov	BYTE PTR [esi+5], al
	jmp	SHORT $LN34@equal
$LN35@equal:

; 578  : 				_Meta = _Strbuf->sgetc()))
; 579  : 			_Strbuf = 0;

	mov	DWORD PTR [esi], 0
$LN34@equal:

; 582  : 		_Got = true;

	mov	BYTE PTR [esi+4], 1
$LN3@equal:

; 552  : 			_Right._Peek();
; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
	jne	SHORT $LN56@equal
	test	eax, eax
	je	SHORT $LN7@equal
$LN6@equal:
	xor	al, al

; 554  : 			|| (_Strbuf != 0 && _Right._Strbuf != 0));
; 555  : 		}

	pop	ebp
	ret	4
$LN56@equal:

; 552  : 			_Right._Peek();
; 553  : 		return ((_Strbuf == 0 && _Right._Strbuf == 0)

	test	eax, eax
	je	SHORT $LN6@equal
$LN7@equal:
	mov	al, 1

; 554  : 			|| (_Strbuf != 0 && _Right._Strbuf != 0));
; 555  : 		}

	pop	ebp
	ret	4
?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z ENDP ; std::istreambuf_iterator<char,std::char_traits<char> >::equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T3 = -64						; size = 52
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1249 : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1250 : 		if (_Ppf != 0 && *_Ppf == 0)

	mov	esi, DWORD PTR __Ppf$[ebp]
	test	esi, esi
	je	SHORT $LN26@Getcat
	cmp	DWORD PTR [esi], 0
	jne	SHORT $LN26@Getcat

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	ecx, DWORD PTR __Ploc$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 427  : 		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN12@Getcat
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN17@Getcat
$LN12@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 4201 : 		return (_Myptr != 0 ? _Myptr : &_Nul);

	mov	ecx, DWORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $LN17@Getcat
	lea	ecx, DWORD PTR [eax+28]
$LN17@Getcat:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	DWORD PTR [edi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	lea	ecx, DWORD PTR $T3[ebp]

; 1278 : 		{	// construct from specified locale

	mov	DWORD PTR [edi], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1251 : 			*_Ppf = new num_put<_Elem, _OutIt>(

	mov	DWORD PTR [esi], edi
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
$LN26@Getcat:

; 1252 : 				_Locinfo(_Ploc->c_str()));
; 1253 : 		return (_X_NUMERIC);
; 1254 : 		}

	mov	eax, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1770 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3978 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3840 : 		{	// determines the next array size to allocate

	push	ebp
	mov	ebp, esp

; 3841 : 		const size_type _Max = max_size();
; 3842 : 		auto& _My_data = this->_Get_data();
; 3843 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

	mov	edx, DWORD PTR __Requested$[ebp]
	or	edx, 15					; 0000000fH
	push	esi
	cmp	edx, 2147483647				; 7fffffffH

; 3844 : 		if (_Masked > _Max)

	ja	SHORT $LN25@Calculate_

; 3845 : 			{	// the mask overflows, settle for max_size()
; 3846 : 			return (_Max);
; 3847 : 			}
; 3848 : 
; 3849 : 		const size_type _Old = _My_data._Myres;

	mov	esi, DWORD PTR [ecx+20]

; 3850 : 		if (_Old > _Max - _Old / 2)

	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, esi
	shr	ecx, 1
	sub	eax, ecx
	cmp	esi, eax
	ja	SHORT $LN25@Calculate_

; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	lea	eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

	cmp	edx, eax
	pop	esi
	cmovb	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 3855 : 		return (_Max_value(_Masked, _Old + _Old / 2));

	mov	eax, edx

; 3856 : 		}

	pop	ebp
	ret	4
$LN25@Calculate_:

; 3851 : 			{	// similarly, geometric overflows
; 3852 : 			return (_Max);

	mov	eax, 2147483647				; 7fffffffH
	pop	esi

; 3856 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 1019 : 		{	// construct default allocator (do nothing)
; 1020 : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 205  : 		{	// put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp

; 206  : 		return (xsputn(_Ptr, _Count));

	push	DWORD PTR __Count$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [eax+36]
	call	eax

; 207  : 		}

	pop	ebp
	ret	12					; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2130 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2131 : 		}

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter, COMDAT
; _this$ = ecx

; 2120 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 2121 : 		}

	ret	0
?get_deleter@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get, COMDAT
; _this$ = ecx

; 2283 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 2284 : 		}

	ret	0
?get@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 2052 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp

; 2053 : 		static_assert(0 < sizeof (_Ty),
; 2054 : 			"can't delete an incomplete type");
; 2055 : 		delete _Ptr;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR __Ptr$[ebp], 1

; 2056 : 		}

	pop	ebp

; 2053 : 		static_assert(0 < sizeof (_Ty),
; 2054 : 			"can't delete an incomplete type");
; 2055 : 		delete _Ptr;

	jmp	DWORD PTR [eax]
$LN3@operator:

; 2056 : 		}

	pop	ebp
	ret	4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 160  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [esi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 161  : 		_Init(_Lobj, _Isdef);

	push	DWORD PTR __Isdef$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR __Lobj$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7?$numpunct@D@std@@6B@
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init

; 162  : 		}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@MAE@XZ		; std::locale::facet::~facet
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 348  : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 350  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	pop	ebp
	ret	8
??0?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1278 : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 167  : 			: _Myrefs(static_cast<_Atomic_integral_t>(_Initrefs))	// non-atomic initialization

	mov	eax, DWORD PTR __Refs$[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 1280 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
	pop	ebp
	ret	8
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1840 : 			{	// user-provided, for fancy pointers
; 1841 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 350  : 		return (_Myval2);

	mov	eax, ecx

; 351  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAPAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 330  : 		return (*this);

	mov	eax, ecx

; 331  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr, COMDAT
; _this$ = ecx

; 2135 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 2136 : 		}

	ret	0
?_Myptr@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
$T3 = -68						; size = 44
$T1 = -68						; size = 44
__Ptr$1$ = -24						; size = 4
_this$GSCopy$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 201  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 127  : 		return (localeconv());

	call	_localeconv
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 202  : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 202  : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	DWORD PTR __Ptr$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 122  : 		return (::_Getcvt());

	call	__Getcvt
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 205  : 		_Grouping = 0;

	mov	DWORD PTR [ebx+8], 0

; 210  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

	cmp	BYTE PTR __Isdef$[ebp], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	je	SHORT $LN6@Init
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN7@Init
$LN6@Init:
	mov	esi, DWORD PTR [esi+8]
$LN7@Init:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 122  : 		return (::_Getcvt());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	__Getcvt
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 662  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocinfo

; 122  : 		return (::_Getcvt());

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 662  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	lea	ecx, DWORD PTR [edi+1]
$LL63@Init:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL63@Init
	sub	edi, ecx
	inc	edi

; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 665  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 666  : 
; 667  : 	if (!_Ptrdest)

	test	edx, edx
	je	$LN67@Init

; 669  : 
; 670  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	edi, edi
	je	SHORT $LN20@Init
	mov	ecx, edx
	sub	ecx, esi
	npad	6
$LL21@Init:

; 671  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL21@Init
$LN20@Init:

; 662  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 6
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 210  : 		_Grouping = _MAKLOCSTR(char, _Isdef ? "" : _Ptr->grouping,

	mov	DWORD PTR [ebx+8], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 212  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

	mov	esi, OFFSET ??_C@_05LAPONLG@false?$AA@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 665  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 666  : 
; 667  : 	if (!_Ptrdest)

	test	edx, edx
	je	$LN68@Init

; 669  : 
; 670  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	ecx, edx
	sub	ecx, esi
$LL30@Init:

; 671  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL30@Init

; 662  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	edi, 5
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 212  : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Cvt);

	mov	DWORD PTR [ebx+16], edx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 213  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

	mov	esi, OFFSET ??_C@_04LOAJBDKD@true?$AA@
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	call	_calloc
	mov	edx, eax
	add	esp, 8

; 665  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 666  : 
; 667  : 	if (!_Ptrdest)

	test	edx, edx
	je	SHORT $LN69@Init

; 669  : 
; 670  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	ecx, edx
	sub	ecx, esi
$LL38@Init:

; 671  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL38@Init
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 213  : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Cvt);

	cmp	BYTE PTR __Isdef$[ebp], 0
	mov	DWORD PTR [ebx+20], edx

; 217  : 		_CATCH_END
; 218  : 
; 219  : 		if (_Isdef)

	je	SHORT $LN3@Init

; 220  : 			{	// apply defaults for required facets
; 221  : //			_Grouping = _MAKLOCSTR(char, "", _Cvt);
; 222  : 			_Dp = _MAKLOCCHR(_Elem, '.', _Cvt);

	mov	WORD PTR [ebx+12], 11310		; 00002c2eH

; 223  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 224  : 			}
; 225  : 		else
; 226  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 227  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@Init:

; 190  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

	mov	ecx, DWORD PTR __Ptr$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+12], al

; 191  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

	mov	eax, DWORD PTR [ecx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ebx+13], al

; 223  : 			_Kseparator = _MAKLOCCHR(_Elem, ',', _Cvt);
; 224  : 			}
; 225  : 		else
; 226  : 			_Getvals((_Elem)0, _Ptr, _Cvt);
; 227  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN67@Init:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale

; 668  : 		_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN68@Init:
	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN69@Init:
	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
__catch$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum

; 215  : 		_Tidy();

	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 216  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN65@Init:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 335  : 		}

	ret	4
?_Init@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1265 : 		}

	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second, COMDAT
; _this$ = ecx

; 355  : 		return (_Myval2);

	mov	eax, ecx

; 356  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QBEABQAV_Facet_base@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 2183 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory

; 2184 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\system_error
;	COMDAT ??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Storage_ptr$ = 12					; size = 4
___formal$ = 16						; size = 4
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z PROC ; std::_Immortalize_impl<std::_Iostream_error_category>, COMDAT

; 600  : 	{	// adapt True Placement New to _Execute_once

	push	ebp
	mov	ebp, esp

; 505  : 	_Iostream_error_category() _NOEXCEPT

	mov	eax, DWORD PTR __Storage_ptr$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 506  : 		{	// default constructor
; 507  : 		_Addr = _Iostream_addr;

	mov	DWORD PTR [eax+4], 5

; 601  : 	::new (_Storage_ptr) _Ty();
; 602  : 	return (1);

	mov	eax, 1

; 603  : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Immortalize_impl@V_Iostream_error_category@std@@@std@@YGHPAX0PAPAX@Z ENDP ; std::_Immortalize_impl<std::_Iostream_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1540 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1541 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1542 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1767 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 325  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xstring

; 1768 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 325  : 		}

	ret	8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1540 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1541 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1542 : 	}

	pop	ebp
	ret	0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 94   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

	push	ebp
	mov	ebp, esp

; 95   : 	size_t _Block_size = _Non_user_size + _Bytes;

	mov	eax, DWORD PTR __Bytes$[ebp]

; 96   : 	if (_Block_size <= _Bytes)

	or	edx, -1
	lea	ecx, DWORD PTR [eax+35]
	cmp	ecx, eax
	cmovbe	ecx, edx

; 52   : 		return (::operator new(_Bytes));

	push	ecx
	call	??2@YAPAXI@Z				; operator new

; 97   : 		{	// add overflow, try allocating all of memory and assume the
; 98   : 			// allocation function will throw bad_alloc
; 99   : 		_Block_size = static_cast<size_t>(-1);
; 100  : 		}
; 101  : 
; 102  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	ecx, eax

; 52   : 		return (::operator new(_Bytes));

	add	esp, 4

; 103  : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);	// validate even in release since we're doing p[-1]

	test	ecx, ecx
	je	__invalid_parameter_noinfo_noreturn

; 104  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 105  : 		& ~(_Big_allocation_alignment - 1));

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 106  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 107  : 
; 108  :   #ifdef _DEBUG
; 109  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 110  :   #endif /* _DEBUG */
; 111  : 	return (_Ptr);
; 112  : 	}

	pop	ebp
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1128 : 	_Left = _STD move(_Right);
; 1129 : 	}

	ret	0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 661  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	ebp
	mov	ebp, esp
	push	esi

; 662  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

	mov	esi, DWORD PTR __Ptr$[ebp]
	push	edi
	mov	edi, esi
	lea	ecx, DWORD PTR [edi+1]
	npad	3
$LL11@Maklocstr:
	mov	al, BYTE PTR [edi]
	inc	edi
	test	al, al
	jne	SHORT $LL11@Maklocstr
	sub	edi, ecx
	inc	edi

; 663  : 
; 664  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

	push	1
	push	edi
	call	_calloc
	mov	edx, eax
	add	esp, 8

; 665  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 666  : 
; 667  : 	if (!_Ptrdest)

	test	edx, edx
	je	SHORT $LN14@Maklocstr

; 669  : 
; 670  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	test	edi, edi
	je	SHORT $LN3@Maklocstr
	mov	ecx, edx
	sub	ecx, esi
$LL4@Maklocstr:

; 671  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	al, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	mov	BYTE PTR [ecx+esi-1], al
	sub	edi, 1
	jne	SHORT $LL4@Maklocstr
$LN3@Maklocstr:

; 672  : 
; 673  : 	return (_Ptrdest);

	pop	edi
	mov	eax, edx
	pop	esi

; 674  : 	}

	pop	ebp
	ret	0
$LN14@Maklocstr:

; 668  : 		_Xbad_alloc();

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN12@Maklocstr:
	int	3
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 628  : 	{	// convert char to _Elem using _Cvtvec

	push	ebp
	mov	ebp, esp

; 629  : 	return ((_Elem)(unsigned char)_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 630  : 	}

	pop	ebp
	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 189  : 		{	// get values

	push	ebp
	mov	ebp, esp

; 190  : 		_Dp = _MAKLOCCHR(_Elem2, _Ptr->decimal_point[0], _Cvt);

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+12], al

; 191  : 		_Kseparator = _MAKLOCCHR(_Elem2, _Ptr->thousands_sep[0], _Cvt);

	mov	eax, DWORD PTR [edx+4]
	movzx	eax, BYTE PTR [eax]
	mov	BYTE PTR [ecx+13], al

; 192  : 		}

	pop	ebp
	ret	52					; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory
;	COMDAT ??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>, COMDAT
; _this$ = ecx

; 2115 : 		{	// construct with compatible pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\memory

; 2116 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAV_Facet_base@std@@@?$_Unique_ptr_base@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::_Facet_base *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\xutility
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 315  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp

; 314  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 316  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.14.26428\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1540 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1541 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1542 : 	}

	pop	ebp
	ret	0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1497 :     {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 1498 :         int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	___stdio_common_vsprintf_s

; 1499 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1500 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1501 : 
; 1502 :         return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1503 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1841 :         {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1842 :             int _Result;
; 1843 :             va_list _ArgList;
; 1844 :             __crt_va_start(_ArgList, _Format);
; 1845 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	__vsprintf_s_l
	add	esp, 20					; 00000014H

; 1846 :             __crt_va_end(_ArgList);
; 1847 :             return _Result;
; 1848 :         }

	pop	ecx
	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
